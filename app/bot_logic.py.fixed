"""
æœºå™¨äººé€»è¾‘å±‚ - ç»Ÿä¸€ç®¡ç†æ‰€æœ‰Telegramæœºå™¨äººäº¤äº’
ã€æ ¸å¿ƒä¿®å¤ã€‘æ”¯æŒå¤šæœºå™¨äººåŒæ—¶è¿è¡Œï¼Œåªè¯»å–æ•°æ®åº“é…ç½®çš„Bot
"""
import asyncio
import sqlite3
import time
import os
import json
import logging
from datetime import datetime, timedelta, timezone
from telethon import TelegramClient, events, Button
from telethon.sessions import MemorySession
from telethon.tl.types import ChannelParticipantsAdmins
from telethon.tl.functions.channels import GetParticipantRequest
import socks

# å¯¼å…¥é…ç½®å’Œä¾èµ–æ¨¡å—
import os
import sys

# æ·»åŠ é¡¹ç›®æ ¹ç›®å½•åˆ°Pythonè·¯å¾„
project_root = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
if project_root not in sys.path:
    sys.path.insert(0, project_root)

from app.config import (
    API_ID, API_HASH, ADMIN_IDS, USE_PROXY,
    PROXY_TYPE, PROXY_HOST, PROXY_PORT
)
from app.database import DB, get_cn_time, get_system_config, get_db_conn
from app.core_functions import (
    get_upline_chain, check_user_conditions, update_level_path,
    distribute_vip_rewards, check_user_in_group, check_bot_is_admin,
    verify_group_link
)
from app.bot_commands_addon import (
    handle_bind_group, handle_join_upline, handle_group_link_message,
    handle_check_status, handle_my_team
)

# é…ç½®æ—¥å¿—
logging.basicConfig(format='%(asctime)s - %(name)s - %(levelname)s - %(message)s', level=logging.INFO)
logger = logging.getLogger(__name__)

# å…¨å±€å˜é‡
active_clients = [] # å­˜å‚¨æ‰€æœ‰è¿è¡Œä¸­çš„å®¢æˆ·ç«¯
bot = None # ä¸»Botå¯¹è±¡ï¼ˆç”¨äºä¸»åŠ¨å‘é€æ¶ˆæ¯ï¼Œé»˜è®¤å–ç¬¬ä¸€ä¸ªï¼‰


def compute_vip_price_from_config(config):
    """Compute effective VIP price: if per-level amounts configured, sum them; else use vip_price"""
    try:
        # support config 'level_amounts' as list or JSON string
        level_count = int(config.get('level_count', 10))
        level_amounts = config.get('level_amounts')
        if level_amounts:
            import json
            if isinstance(level_amounts, str):
                try:
                    parsed = json.loads(level_amounts)
                except Exception:
                    parsed = None
            else:
                parsed = level_amounts

            if isinstance(parsed, list):
                # sum first level_count entries (pad with zeros)
                vals = [float(x) for x in parsed[:level_count]]
                if len(vals) < level_count:
                    vals += [0.0] * (level_count - len(vals))
                return sum(vals)
            elif isinstance(parsed, dict):
                total = 0.0
                for i in range(1, level_count + 1):
                    v = parsed.get(str(i)) or parsed.get(i) or 0
                    total += float(v)
                return total
    except Exception:
        pass
    # fallback to simple vip_price
    try:
        return float(config.get('vip_price', 10))
    except Exception:
        return 10.0

# æŒ‰é’®æ–‡å­—å¸¸é‡
BTN_PROFILE = 'ğŸ‘¤ ä¸ªäººä¸­å¿ƒ'
BTN_FISSION = 'ğŸ”— ç¾¤è£‚å˜åŠ å…¥'
BTN_VIEW_FISSION = 'ğŸ“Š æˆ‘çš„è£‚å˜'
BTN_RESOURCES = 'ğŸ“ è¡Œä¸šèµ„æº'
BTN_PROMOTE = 'ğŸ’° èµšé’±æ¨å¹¿'
BTN_SUPPORT = 'ğŸ‘©â€ğŸ’¼ åœ¨çº¿å®¢æœ'
BTN_BACK = 'ğŸ”™ è¿”å›ä¸»èœå•'
BTN_ADMIN = 'âš™ï¸ ç®¡ç†åå°'
BTN_VIP = 'ğŸ’ å¼€é€šä¼šå‘˜'
BTN_MY_PROMOTE = 'ğŸ’« æˆ‘çš„æ¨å¹¿'
BTN_EARNINGS = 'ğŸ“Š æ”¶ç›Šè®°å½•'


async def send_vip_required_prompt(event_or_id, reply_method='respond'):
    """ç»™æœªå¼€é€šVIPçš„ç”¨æˆ·å‘é€ç»Ÿä¸€æç¤ºæ–‡æ¡ˆï¼Œæ”¯æŒ event æˆ– telegram_id"""
    try:
        if isinstance(event_or_id, int):
            telegram_id = event_or_id
            member = DB.get_member(telegram_id)
        else:
            original = event_or_id
            try:
                original_sender_id = original.sender_id
                original.sender_id = get_main_account_id(original_sender_id, getattr(original.sender, 'username', None))
            except Exception:
                pass
            member = DB.get_member(original.sender_id)
            telegram_id = original.sender_id

        config = get_system_config()
        vip_price = config.get('vip_price', 10)
        balance = member['balance'] if member else 0

        text = "æŠ±æ­‰ æ‚¨è¿˜ä¸æ˜¯VIP\n\n"
        text += "ä¸èƒ½ä½¿ç”¨æ­¤åŠŸèƒ½ è¯·å…ˆå¼€é€šVIP\n"
        text += "ç‚¹å‡»ä¸‹æ–¹ã€Œå¼€é€šVIPã€æŒ‰é’® å¼€é€šåœ¨æ¥å“¦\n\n"
        text += f"ğŸ’° VIPä»·æ ¼: {vip_price} U\n"
        text += f"ğŸ’µ å½“å‰ä½™é¢: {balance} U\n"

        buttons = []
        # å¦‚æœä½™é¢è¶³å¤Ÿï¼Œæä¾›ä½™é¢å¼€é€šæŒ‰é’®ï¼›å¦åˆ™æä¾›å……å€¼å…¥å£
        if balance >= vip_price:
            buttons = [[Button.inline('ğŸ’ ä½™é¢å¼€é€šVIP', b'confirm_vip')]]
        else:
            buttons = [[Button.inline('ğŸ’³ å……å€¼å¼€é€šVIP', b'recharge_for_vip')]]

        if isinstance(event_or_id, int):
            try:
                await bot.send_message(telegram_id, text, buttons=buttons)
            except Exception:
                pass
        else:
            # event-like
            try:
                if reply_method == 'respond':
                    await event_or_id.respond(text, buttons=buttons)
                else:
                    await event_or_id.answer(text, alert=True)
            except Exception:
                try:
                    await event_or_id.answer(text, alert=True)
                except Exception:
                    pass
    except Exception as e:
        print(f"[VIPæç¤º] å‘é€å¤±è´¥: {e}")

def get_active_bot_tokens():
    """è·å–æ‰€æœ‰æ´»è·ƒçš„æœºå™¨äººtoken"""
    try:
        conn = get_db_conn()
        c = conn.cursor()
        c.execute('SELECT bot_token FROM bot_configs WHERE is_active = 1 ORDER BY id ASC')
        rows = c.fetchall()
        conn.close()
        tokens = [row[0] for row in rows if row[0]]
        print(f"[æœºå™¨äººåˆå§‹åŒ–] æ‰¾åˆ° {len(tokens)} ä¸ªæ´»è·ƒæœºå™¨äººtoken")
        return tokens
    except Exception as e:
        print(f"[æœºå™¨äººåˆå§‹åŒ–] è·å–æ´»è·ƒtokenå¤±è´¥: {e}")
        return []

# ==================== æœºå™¨äººåˆå§‹åŒ–é€»è¾‘ ====================

def init_bots():
    """åˆå§‹åŒ–å¹¶å¯åŠ¨æ‰€æœ‰é…ç½®çš„æœºå™¨äºº"""
    global bot, active_clients

    tokens = get_active_bot_tokens()

    if not tokens:
        logger.error("âŒ é”™è¯¯ï¼šæ•°æ®åº“ä¸­æ²¡æœ‰æ´»è·ƒçš„æœºå™¨äººTokenï¼è¯·å…ˆåœ¨åå°æ·»åŠ æœºå™¨äººã€‚")
        return []

    # ä»£ç†é…ç½®
    proxy = None
if USE_PROXY:
    if PROXY_TYPE.lower() == 'socks5':
        proxy = (socks.SOCKS5, PROXY_HOST, PROXY_PORT)
    elif PROXY_TYPE.lower() == 'socks4':
        proxy = (socks.SOCKS4, PROXY_HOST, PROXY_PORT)
    elif PROXY_TYPE.lower() == 'http':
        proxy = (socks.HTTP, PROXY_HOST, PROXY_PORT)
    else:
        proxy = (socks.SOCKS5, PROXY_HOST, PROXY_PORT)

    active_clients = []

    for idx, token in enumerate(tokens):
        try:
            # ä¸ºæ¯ä¸ªtokenåˆ›å»ºä¸€ä¸ªç‹¬ç«‹çš„sessionæ–‡ä»¶ï¼Œé¿å…å†²çª
            session_name = f'bot_session_{idx}'
            client = TelegramClient(session_name, API_ID, API_HASH, proxy=proxy)
            client.start(bot_token=token)

            # æ³¨å†Œæ‰€æœ‰äº‹ä»¶å¤„ç†å™¨
            register_handlers(client)

            active_clients.append(client)
            logger.info(f"âœ… æœºå™¨äºº #{idx+1} å¯åŠ¨æˆåŠŸ (Token: {token[:10]}...)")

        except Exception as e:
            logger.error(f"âŒ æœºå™¨äºº #{idx+1} å¯åŠ¨å¤±è´¥: {e}")

    if active_clients:
        bot = active_clients[0] # å°†ç¬¬ä¸€ä¸ªå¯åŠ¨æˆåŠŸçš„è®¾ä¸ºä¸»Botï¼Œç”¨äºä¸»åŠ¨æ¨é€
        logger.info(f"âœ… æ€»è®¡å¯åŠ¨ {len(active_clients)} ä¸ªæœºå™¨äººï¼Œä¸»Botå·²å°±ç»ª")
    else:
        logger.error("âŒ æ²¡æœ‰æœºå™¨äººå¯åŠ¨æˆåŠŸ")

    return active_clients

# å…¨å±€é˜Ÿåˆ—
pending_broadcasts = []
notify_queue = []
process_recharge_queue = []
waiting_for_group_link = {}
waiting_for_backup = {}
waiting_for_recharge_amount = {}
waiting_for_withdraw_amount = {}
waiting_for_withdraw_address = {}
withdraw_temp_data = {}
admin_waiting = {}

# å¯¼å…¥æ”¯ä»˜æ¨¡å—
from app.payment import create_recharge_order, PAYMENT_CONFIG, generate_payment_sign

# ==================== è´¦å·å…³è”é€»è¾‘ ====================

def get_main_account_id(telegram_id, username=None):
    """è·å–ä¸»è´¦å·IDï¼ˆç²¾å‡†IDåŒ¹é…ç‰ˆï¼‰"""
    try:
        target_id_str = str(telegram_id).strip()
        clean_username = (username or '').strip().lstrip('@')
        
        conn = get_db_conn()
        c = conn.cursor()
        
        # æ ¸å¿ƒæŸ¥è¯¢ï¼šæŸ¥æ‰¾æ˜¯å¦æœ‰äººçš„ backup_account å­—æ®µç­‰äºå½“å‰è®¿é—®è€…çš„ ID
        query = "SELECT telegram_id FROM members WHERE backup_account = ?"
        c.execute(query, (target_id_str,))
        row = c.fetchone()
        
        # å¦‚æœIDæ²¡æŸ¥åˆ°ï¼Œå†å°è¯•æŸ¥ç”¨æˆ·å
        if not row and clean_username:
            c.execute(
                'SELECT telegram_id FROM members WHERE backup_account = ? OR backup_account = ?',
                (clean_username, f"@{clean_username}")
            )
            row = c.fetchone()
            
        # æ¡æ¼è´¦å·é€»è¾‘
        if not row:
            c.execute(
                'SELECT main_account_id FROM fallback_accounts '
                'WHERE telegram_id = ? AND main_account_id IS NOT NULL LIMIT 1',
                (telegram_id,)
            )
            fallback_result = c.fetchone()
            if fallback_result and fallback_result[0]:
                conn.close()
                return fallback_result[0]
        
        conn.close()
        
        if row:
            print(f"âœ… [è´¦å·åŠ«æŒæˆåŠŸ] å¤‡ç”¨å· {target_id_str} æ­£åœ¨ç™»å½• -> åˆ‡æ¢ä¸ºä¸»è´¦å· {row[0]}")
            return row[0]
        
        return telegram_id
    except Exception as e:
        print(f"[å…³è”æŸ¥è¯¢å‡ºé”™] {e}")
        return telegram_id

def format_backup_account_display(backup_account):
    """æ ¼å¼åŒ–å¤‡ç”¨å·æ˜¾ç¤º"""
    if not backup_account:
        return "æœªè®¾ç½®"
    
    backup_account_str = str(backup_account).strip()
    
    if backup_account_str.startswith('@'):
        return backup_account_str
    if not backup_account_str.isdigit():
        return f"@{backup_account_str}"
    
    try:
        backup_id = int(backup_account_str)
        backup_member = DB.get_member(backup_id)
        if backup_member and backup_member.get('username'):
            return f"@{backup_member['username']}"
        else:
            return backup_account_str
    except (ValueError, Exception):
        return backup_account_str

def link_account(main_id, backup_id, backup_username):
    """å…³è”å¤‡ç”¨å·åˆ°ä¸»è´¦å·"""
    clean_username = (backup_username or '').strip().lstrip('@')
    
    if clean_username:
        value_to_store = f"@{clean_username}"
    elif backup_id:
        value_to_store = str(backup_id)
    else:
        return False, "âŒ æ— æ•ˆçš„å¤‡ç”¨è´¦å·ä¿¡æ¯"
        
    if str(main_id) == str(backup_id) or value_to_store == str(main_id):
        return False, "âŒ ä¸èƒ½å°†è‡ªå·±è®¾ç½®ä¸ºå¤‡ç”¨å·"

    try:
        if backup_id:
            existing_member = DB.get_member(backup_id)
            if existing_member and str(backup_id) != str(main_id):
                return False, "âŒ è¯¥è´¦å·å·²æ³¨å†Œï¼Œä¸èƒ½è®¾ç½®ä¸ºå¤‡ç”¨å·"
    except Exception as e:
        print(f"[æ£€æŸ¥å¤‡ç”¨å·æ˜¯å¦å·²æ³¨å†Œå¤±è´¥] {e}")

    conn = get_db_conn()
    c = conn.cursor()
    try:
        c.execute('SELECT telegram_id FROM members WHERE backup_account = ?', (str(backup_id),))
        existing_by_id = c.fetchone()
        
        c.execute(
            'SELECT telegram_id FROM members WHERE backup_account = ? OR backup_account = ?',
            (clean_username, f"@{clean_username}")
        )
        existing_by_name = c.fetchone()
        
        existing = existing_by_id or existing_by_name
        
        if existing and str(existing[0]) != str(main_id):
            conn.close()
            return False, "âŒ è¯¥è´¦å·å·²ç»æ˜¯å…¶ä»–äººçš„å¤‡ç”¨å·äº†ï¼Œæ— æ³•é‡å¤ç»‘å®š"

        c.execute('UPDATE members SET backup_account = ? WHERE telegram_id = ?', (value_to_store, main_id))
        conn.commit()
        conn.close()
        return True, f"âœ… å¤‡ç”¨è´¦å·å…³è”æˆåŠŸï¼\nç»‘å®šå€¼: {value_to_store}\n\nè¯·ä½¿ç”¨å¤‡ç”¨å·å‘é€ /start æµ‹è¯•ã€‚"
        
    except Exception as e:
        try:
            conn.close()
        except:
            pass
        return False, f"å…³è”å¤±è´¥: {str(e)}"

def get_fallback_resource(resource_type='group'):
    """è·å–æ¡æ¼è´¦å·èµ„æº"""
    try:
        conn = get_db_conn()
        c = conn.cursor()
        if resource_type == 'group':
            # è¿”å›åŒ…å«ç¾¤ç»„åç§°å’Œé“¾æ¥çš„åˆ—è¡¨
            c.execute("SELECT username, group_link FROM fallback_accounts WHERE is_active = 1 AND group_link IS NOT NULL AND group_link != '' ORDER BY id ASC")
            results = c.fetchall()
            conn.close()
            if results:
                groups = []
                seen = set()
                for username, group_link in results:
                    if not group_link:
                        continue
                    g_links = group_link.split('\n')
                    for link in g_links:
                        link = link.strip()
                        if link and link not in seen:
                            # é»˜è®¤ä½¿ç”¨ç”¨æˆ·åï¼Œå¦‚æœæ²¡æœ‰åˆ™ä½¿ç”¨é“¾æ¥æœ€åä¸€éƒ¨åˆ†
                            default_name = username or link.split('/')[-1].replace('+', '')
                            groups.append({
                                'username': username or '',
                                'link': link,
                                'name': default_name  # é»˜è®¤åç§°ï¼Œåç»­å¯ä»¥é€šè¿‡Telegram APIè·å–å®é™…åç§°
                            })
                            seen.add(link)
                return groups if groups else None
        elif resource_type == 'account':
            c.execute("SELECT telegram_id, username FROM fallback_accounts WHERE is_active = 1 ORDER BY RANDOM() LIMIT 1")
            result = c.fetchone()
            conn.close()
            if result:
                return {'telegram_id': result[0], 'username': result[1]}
        conn.close()
    except Exception as e:
        print(f"[æ¡æ¼é”™è¯¯] {e}")
    return None

async def get_group_title(bot, group_link):
    """ä»Telegram APIè·å–ç¾¤ç»„å®é™…åç§°"""
    try:
        # æå–ç¾¤ç»„ç”¨æˆ·å
        if 't.me/' in group_link:
            group_username = group_link.split('t.me/')[-1].split('/')[0].split('?')[0]
        elif group_link.startswith('@'):
            group_username = group_link[1:]
        else:
            return None
        
        # è·³è¿‡ç§æœ‰ç¾¤é“¾æ¥
        if group_username.startswith('+'):
            return None
        
        # è·å–ç¾¤ç»„å®ä½“
        group_entity = await bot.get_entity(group_username)
        title = getattr(group_entity, 'title', None)
        return title
    except Exception as e:
        print(f"[è·å–ç¾¤ç»„åç§°å¤±è´¥] {group_link}: {e}")
    return None

def get_main_keyboard(user_id=None):
    """ä¸»èœå•é”®ç›˜"""
    keyboard = [
        [Button.text(BTN_VIP, resize=True), Button.text(BTN_VIEW_FISSION, resize=True), Button.text(BTN_MY_PROMOTE, resize=True)],
        [Button.text(BTN_RESOURCES, resize=True), Button.text(BTN_FISSION, resize=True), Button.text(BTN_PROFILE, resize=True)],
        [Button.text(BTN_SUPPORT, resize=True)]
    ]
    if user_id and user_id in ADMIN_IDS:
        keyboard[-1].append(Button.text(BTN_ADMIN, resize=True))
    return keyboard

# ==================== ã€æ ¸å¿ƒä¿®å¤ã€‘VIPå¼€é€šé€»è¾‘ ====================
# æ‰€æœ‰VIPå¼€é€šè·¯å¾„éƒ½ç»Ÿä¸€è°ƒç”¨ distribute_vip_rewardsï¼Œåˆ é™¤å†—ä½™çš„æ‰‹å†™åˆ†çº¢ä»£ç 

async def process_vip_upgrade(telegram_id, vip_price, config, deduct_balance=True):
    """
    ç»Ÿä¸€çš„VIPå¼€é€šå¤„ç†å‡½æ•°
    ã€æ ¸å¿ƒã€‘æ‰€æœ‰VIPå¼€é€šéƒ½è°ƒç”¨è¿™ä¸ªå‡½æ•°ï¼Œç¡®ä¿é€»è¾‘ä¸€è‡´
    
    Args:
        telegram_id: ç”¨æˆ·ID
        vip_price: VIPä»·æ ¼ï¼ˆç”¨äºåˆ†çº¢è®¡ç®—ï¼‰
        config: ç³»ç»Ÿé…ç½®
        deduct_balance: æ˜¯å¦æ‰£é™¤ä½™é¢ï¼ˆTrue=ç”¨æˆ·è‡ªå·±å¼€é€šï¼ŒFalse=ç®¡ç†å‘˜èµ é€ï¼‰
    """
    # 1. æ£€æŸ¥ç”¨æˆ·çŠ¶æ€
    member = DB.get_member(telegram_id)
    if not member:
        return False, "ç”¨æˆ·ä¸å­˜åœ¨"
    
    if member.get('is_vip'):
        return False, "ç”¨æˆ·å·²æ˜¯VIP"
    
    # 2. æ‰£é™¤ä½™é¢ï¼ˆå¦‚æœéœ€è¦ï¼‰
    print(f'[process_vip_upgrade] å¼€å§‹å¤„ç†: telegram_id={telegram_id}, deduct_balance={deduct_balance}, å½“å‰ä½™é¢={member["balance"]}, vip_price={vip_price}')
    if deduct_balance:
        if member['balance'] < vip_price:
            print(f'[process_vip_upgrade] ä½™é¢ä¸è¶³: éœ€è¦{vip_price}, å½“å‰{member["balance"]}')
            return False, "ä½™é¢ä¸è¶³"
        new_balance = member['balance'] - vip_price
        print(f'[process_vip_upgrade] æ‰£è´¹: {member["balance"]} -> {new_balance}')
        DB.update_member(telegram_id, balance=new_balance, is_vip=1, vip_time=get_cn_time())
    else:
        # ç®¡ç†å‘˜èµ é€ï¼Œä¸æ‰£é™¤ä½™é¢
        new_balance = member['balance']
        print(f'[process_vip_upgrade] ç®¡ç†å‘˜èµ é€VIP: ä½™é¢ä¿æŒ{new_balance}')
        DB.update_member(telegram_id, is_vip=1, vip_time=get_cn_time())
    
    # 3. æ›´æ–°å±‚çº§è·¯å¾„
    update_level_path(telegram_id)
    
    # 4. ã€æ ¸å¿ƒã€‘è°ƒç”¨ç»Ÿä¸€åˆ†çº¢å‡½æ•°ï¼ˆæ›¿ä»£æ‰€æœ‰æ‰‹å†™å¾ªç¯ï¼‰
    stats = await distribute_vip_rewards(bot, telegram_id, vip_price, config)
    
    return True, {
        'new_balance': new_balance,
        'stats': stats
    }

# ==================== äº‹ä»¶å¤„ç†å™¨ ====================

def register_handlers(client):
    """ä¸ºå•ä¸ªå®¢æˆ·ç«¯æ³¨å†Œæ‰€æœ‰äº‹ä»¶å¤„ç†å™¨"""

    @client.on(events.NewMessage(pattern='/start'))
    async def start_handler(event):
    """å¯åŠ¨å‘½ä»¤"""
        original_sender_id = event.sender_id
        telegram_id = get_main_account_id(original_sender_id, getattr(event.sender, 'username', None))

    referrer_id = None
    if event.message.text and len(event.message.text.split()) > 1:
        try:
            referrer_id = int(event.message.text.split()[1])
            except: pass
    
    member = DB.get_member(telegram_id)
    
    if not member:
            username = event.sender.username or f'user_{telegram_id}'
            DB.create_member(telegram_id, username, referrer_id)
        member = DB.get_member(telegram_id)
        
        # é€šçŸ¥æ¨èäºº
        if referrer_id:
                try:
                    await client.send_message(referrer_id, f'ğŸ‰ æ–°æˆå‘˜åŠ å…¥! ID: {telegram_id}')
                except: pass
    
    sys_config = get_system_config()

        # æ˜¾ç¤ºå½“å‰ä½¿ç”¨çš„è´¦å·IDï¼ˆå¯èƒ½æ˜¯å¤‡ç”¨è´¦å·ï¼‰
        display_id = original_sender_id
        vip_status = "âœ… å·²å¼€é€š" if member.get('is_vip') else "âŒ æœªå¼€é€š"

        welcome_text = f'ğŸ‘‹ æ¬¢è¿ä½¿ç”¨è£‚å˜æ¨å¹¿æœºå™¨äºº!\nğŸ‘¤ å½“å‰æ˜¾ç¤ºèº«ä»½ID: `{display_id}`\nğŸ’ VIPçŠ¶æ€: {vip_status}\nğŸ’° ä½™é¢: {member["balance"]} U\n\nè¯·é€‰æ‹©åŠŸèƒ½:'
        if sys_config.get('pinned_ad'):
            welcome_text += f'\n\nğŸ“¢ {sys_config["pinned_ad"]}'
    
    await event.respond(welcome_text, buttons=get_main_keyboard(telegram_id))

    # VIPç›¸å…³äº‹ä»¶å¤„ç†å™¨
    @client.on(events.NewMessage(pattern=BTN_VIP))
    async def vip_handler(event):
        telegram_id = get_main_account_id(event.sender_id)
    member = DB.get_member(telegram_id)
    
        if not member: return
    
    if member['is_vip']:
            await event.respond(f'ğŸ’ æ‚¨å·²ç»æ˜¯VIPä¼šå‘˜!\nå¼€é€šæ—¶é—´: {member["vip_time"][:10]}')
        return
    
        config = get_system_config()
        vip_price = compute_vip_price_from_config(config)

        text = f'ğŸ’ å¼€é€šVIPä¼šå‘˜\nVIPä»·æ ¼: {vip_price} U\nå½“å‰ä½™é¢: {member["balance"]} U'
        buttons = []
        if member['balance'] >= vip_price:
            text += '\nâœ… ä½™é¢å……è¶³ï¼Œå¯ä»¥ç›´æ¥å¼€é€š'
            buttons = [[Button.inline('ğŸ’ ä½™é¢å¼€é€šVIP', b'confirm_vip')]]
        else:
            text += f'\nâŒ ä½™é¢ä¸è¶³ï¼Œè¿˜éœ€ {vip_price - member["balance"]} U'
            buttons = [[Button.inline('ğŸ’³ å……å€¼å¼€é€šVIP', b'recharge_for_vip')]]
        
        await event.respond(text, buttons=buttons)

    @client.on(events.CallbackQuery(pattern=b'confirm_vip'))
    async def cb_confirm_vip(event):
        telegram_id = get_main_account_id(event.sender_id)
    config = get_system_config()
        vip_price = compute_vip_price_from_config(config)

            success, result = await process_vip_upgrade(telegram_id, vip_price, config)
            if success:
            await event.answer("ğŸ‰ VIPå¼€é€šæˆåŠŸï¼", alert=True)
            await event.respond("ğŸ‰ æ­å–œ! æ‚¨å·²æˆä¸ºVIPä¼šå‘˜ï¼Œç°åœ¨å¯ä»¥äº«å—æ‰€æœ‰æƒç›Šï¼", buttons=[[Button.inline('ğŸ”™ è¿”å›', b'back_to_profile')]])
            else:
            await event.answer(f"âŒ å¼€é€šå¤±è´¥: {result}", alert=True)

    @client.on(events.CallbackQuery(pattern=b'recharge_for_vip'))
    async def cb_recharge_for_vip(event):
        telegram_id = get_main_account_id(event.sender_id)
    config = get_system_config()
        vip_price = compute_vip_price_from_config(config)

        # åˆ›å»ºå……å€¼è®¢å•ï¼Œé‡‘é¢ä¸ºVIPä»·æ ¼
        try:
            await create_recharge_order(client, event, vip_price, is_vip_order=True)
    except Exception as e:
            await event.answer("åˆ›å»ºå……å€¼è®¢å•å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•", alert=True)

    # ä¸ªäººä¸­å¿ƒæŒ‰é’®å¤„ç†å™¨
    @client.on(events.NewMessage(pattern=BTN_PROFILE))
    async def profile_handler(event):
        telegram_id = get_main_account_id(event.sender_id)
    member = DB.get_member(telegram_id)
    
    if not member:
            await event.respond('è¯·å…ˆå‘é€ /start æ³¨å†Œ')
        return
    
    config = get_system_config()
        vip_price = compute_vip_price_from_config(config)

        text = f'ğŸ‘¤ ä¸ªäººä¸­å¿ƒ\n\n'
        text += f'ğŸ†” ç”¨æˆ·ID: `{telegram_id}`\n'
        text += f'ğŸ’° å½“å‰ä½™é¢: {member["balance"]} U\n'
        text += f'ğŸ’ VIPçŠ¶æ€: {"âœ… å·²å¼€é€š" if member["is_vip"] else "âŒ æœªå¼€é€š"}\n'
        if member["is_vip"]:
            text += f'ğŸ“… å¼€é€šæ—¶é—´: {member["vip_time"][:10] if member["vip_time"] else "æœªçŸ¥"}\n'
        text += f'ğŸ¯ VIPä»·æ ¼: {vip_price} U\n\n'

        # æ˜¾ç¤ºå›¢é˜Ÿç»Ÿè®¡
        from core_functions import calculate_team_stats
        team_stats = calculate_team_stats(telegram_id, 10)
        text += f'ğŸ‘¥ å›¢é˜Ÿç»Ÿè®¡:\n'
        text += f'   ç›´æ¨äººæ•°: {team_stats["direct_count"]}\n'
        text += f'   å›¢é˜Ÿæ€»äººæ•°: {team_stats["team_count"]}\n'
        text += f'   VIPäººæ•°: {team_stats["vip_count"]}\n'
        text += f'ğŸ’¸ ç´¯è®¡æ”¶ç›Š: {member.get("total_earned", 0)} U\n'
        text += f'âš ï¸ ç´¯è®¡é”™è¿‡: {member.get("missed_balance", 0)} U\n'

        await event.respond(text, buttons=[[Button.text(BTN_BACK, resize=True)]])

    # åœ¨çº¿å®¢æœæŒ‰é’®å¤„ç†å™¨
    @client.on(events.NewMessage(pattern=BTN_SUPPORT))
    async def support_handler(event):
        telegram_id = get_main_account_id(event.sender_id)
    config = get_system_config()

        support_text = config.get('support_text', 'ğŸ‘©â€ğŸ’¼ åœ¨çº¿å®¢æœ\n\næš‚æ— å®¢æœä¿¡æ¯ï¼Œè¯·è”ç³»ç®¡ç†å‘˜')
        customer_services = DB.get_customer_services()

        if customer_services:
            text = 'ğŸ‘©â€ğŸ’¼ åœ¨çº¿å®¢æœ\n\n'
            for service in customer_services:
                text += f'ğŸ“ {service["name"]}\n'
                if service["link"]:
                    text += f'ğŸ”— {service["link"]}\n\n'
        else:
            text = support_text

        await event.respond(text, buttons=[[Button.text(BTN_BACK, resize=True)]])

    # ç®¡ç†åå°æŒ‰é’®å¤„ç†å™¨
    @client.on(events.NewMessage(pattern=BTN_ADMIN))
    async def admin_handler(event):
        if event.sender_id not in ADMIN_IDS:
            await event.respond('âŒ æ‚¨ä¸æ˜¯ç®¡ç†å‘˜ï¼Œæ— æ³•è®¿é—®ç®¡ç†åå°')
            return

        text = 'âš™ï¸ ç®¡ç†åå°\n\n'
        text += 'ğŸŒ è®¿é—®åœ°å€:\n'
        text += 'http://ä½ çš„æœåŠ¡å™¨IP:5051\n\n'
        text += 'ğŸ“‹ é»˜è®¤è´¦å·:\n'
        text += 'ç”¨æˆ·å: admin\n'
        text += 'å¯†ç : admin\n\n'
        text += 'âš ï¸ è¯·åŠæ—¶ä¿®æ”¹é»˜è®¤å¯†ç '

        await event.respond(text, buttons=[[Button.text(BTN_BACK, resize=True)]])

    # æˆ‘çš„æ¨å¹¿æŒ‰é’®å¤„ç†å™¨
    @client.on(events.NewMessage(pattern=BTN_MY_PROMOTE))
    async def my_promote_handler(event):
        telegram_id = get_main_account_id(event.sender_id)
        member = DB.get_member(telegram_id)

    if not member:
        await event.respond('è¯·å…ˆå‘é€ /start æ³¨å†Œ')
        return
    
    if not member['is_vip']:
            await send_vip_required_prompt(event, 'respond')
        return
    
    # ç”Ÿæˆæ¨å¹¿é“¾æ¥
        bot_username = None
        try:
            me = await client.get_me()
            bot_username = me.username
    except:
        pass

        if bot_username:
            invite_link = f'https://t.me/{bot_username}?start={telegram_id}'
            text = f'ğŸ’« æˆ‘çš„æ¨å¹¿\n\n'
            text += f'ğŸ”— æ¨å¹¿é“¾æ¥:\n{invite_link}\n\n'
            text += f'ğŸ“Š æ¨å¹¿ç»Ÿè®¡:\n'
        else:
            text = f'ğŸ’« æˆ‘çš„æ¨å¹¿\n\n'
            text += f'ğŸ”— æ¨å¹¿é“¾æ¥: t.me/ä½ çš„æœºå™¨äºº?start={telegram_id}\n\n'
            text += f'ğŸ“Š æ¨å¹¿ç»Ÿè®¡:\n'

        # è·å–å›¢é˜Ÿç»Ÿè®¡
        from core_functions import calculate_team_stats
        team_stats = calculate_team_stats(telegram_id, 10)
        text += f'ğŸ‘¥ ç›´æ¨äººæ•°: {team_stats["direct_count"]}\n'
        text += f'ğŸ‘¨â€ğŸ‘©â€ğŸ‘§â€ğŸ‘¦ å›¢é˜Ÿæ€»äººæ•°: {team_stats["team_count"]}\n'
        text += f'ğŸ’ VIPäººæ•°: {team_stats["vip_count"]}\n'
        text += f'ğŸ’° ç´¯è®¡æ”¶ç›Š: {member.get("total_earned", 0)} U\n\n'

        text += 'ğŸ“¢ é‚€è¯·å¥½å‹åŠ å…¥å³å¯è·å¾—å¥–åŠ±!'

        await event.respond(text, buttons=[[Button.text(BTN_BACK, resize=True)]])

    # ç¾¤è£‚å˜åŠ å…¥æŒ‰é’®å¤„ç†å™¨
    @client.on(events.NewMessage(pattern=BTN_FISSION))
    async def fission_handler(event):
        telegram_id = get_main_account_id(event.sender_id)
        member = DB.get_member(telegram_id)

    if not member:
        await event.respond('è¯·å…ˆå‘é€ /start æ³¨å†Œ')
        return
    
    if not member['is_vip']:
            await send_vip_required_prompt(event, 'respond')
        return
    
        text = 'ğŸ”— ç¾¤è£‚å˜åŠ å…¥\n\n'
        text += 'ğŸ“‹ åŠ å…¥ä¸Šå±‚ç¾¤ç»„å¯ä»¥è·å¾—åˆ†çº¢å¥–åŠ±\n\n'
        text += 'è¯·é€‰æ‹©æ“ä½œ:'
    
    buttons = [
            [Button.text('ğŸ“‹ æŸ¥çœ‹éœ€è¦åŠ å…¥çš„ç¾¤', resize=True)],
            [Button.text('âœ… æ£€æŸ¥åŠ å…¥çŠ¶æ€', resize=True)],
            [Button.text(BTN_BACK, resize=True)]
        ]

        await event.respond(text, buttons=buttons)

    # æˆ‘çš„è£‚å˜æŒ‰é’®å¤„ç†å™¨
    @client.on(events.NewMessage(pattern=BTN_VIEW_FISSION))
    async def view_fission_handler(event):
        telegram_id = get_main_account_id(event.sender_id)
        member = DB.get_member(telegram_id)

        if not member:
            await event.respond('è¯·å…ˆå‘é€ /start æ³¨å†Œ')
                return
            
        if not member['is_vip']:
            await send_vip_required_prompt(event, 'respond')
        return
    
        text = 'ğŸ“Š æˆ‘çš„è£‚å˜\n\n'
        text += f'ğŸ‘¤ ç¾¤ç»„çŠ¶æ€: {"âœ… å·²ç»‘å®š" if member.get("is_group_bound") else "âŒ æœªç»‘å®š"}\n'

        if member.get('group_link'):
            text += f'ğŸ”— ç¾¤é“¾æ¥: {member["group_link"]}\n'

        text += f'ğŸ¤– ç®¡ç†å‘˜æƒé™: {"âœ… å·²è®¾ç½®" if member.get("is_bot_admin") else "âŒ æœªè®¾ç½®"}\n'
        text += f'ğŸ‘¥ åŠ å…¥ä¸Šå±‚ç¾¤: {"âœ… å·²å®Œæˆ" if member.get("is_joined_upline") else "âŒ æœªå®Œæˆ"}\n\n'

        # æ˜¾ç¤ºå›¢é˜Ÿå±‚çº§ç»Ÿè®¡
        from core_functions import get_downline_tree
        downline_tree = get_downline_tree(telegram_id, 5)  # åªæ˜¾ç¤ºå‰5å±‚

        if downline_tree:
            text += 'ğŸ“ˆ å›¢é˜Ÿå±‚çº§åˆ†å¸ƒ:\n'
            for level in range(1, 6):
                if level in downline_tree:
                    members_in_level = downline_tree[level]
                    vip_count = sum(1 for m in members_in_level if m['is_vip'])
                    text += f'   ç¬¬{level}å±‚: {len(members_in_level)}äºº (VIP: {vip_count}äºº)\n'

        await event.respond(text, buttons=[[Button.text(BTN_BACK, resize=True)]])

    # è¿”å›ä¸»èœå•æŒ‰é’®å¤„ç†å™¨
    @client.on(events.NewMessage(pattern=BTN_BACK))
    async def back_handler(event):
        telegram_id = get_main_account_id(event.sender_id)
        member = DB.get_member(telegram_id)

        if member:
        config = get_system_config()
            vip_status = "âœ… å·²å¼€é€š" if member.get('is_vip') else "âŒ æœªå¼€é€š"

            welcome_text = f'ğŸ‘‹ æ¬¢è¿ä½¿ç”¨è£‚å˜æ¨å¹¿æœºå™¨äºº!\nğŸ‘¤ å½“å‰æ˜¾ç¤ºèº«ä»½ID: `{event.sender_id}`\nğŸ’ VIPçŠ¶æ€: {vip_status}\nğŸ’° ä½™é¢: {member["balance"]} U\n\nè¯·é€‰æ‹©åŠŸèƒ½:'
            if config.get('pinned_ad'):
                welcome_text += f'\n\nğŸ“¢ {config["pinned_ad"]}'

            await event.respond(welcome_text, buttons=get_main_keyboard(telegram_id))
                else:
            await event.respond('è¯·å…ˆå‘é€ /start æ³¨å†Œ', buttons=get_main_keyboard(telegram_id))

def run_bot():
    """Bot å¯åŠ¨å…¥å£"""
    print("ğŸš€ æ­£åœ¨å¯åŠ¨æ‰€æœ‰é…ç½®çš„ Telegram Bot...")

    loop = asyncio.new_event_loop()
    asyncio.set_event_loop(loop)

    # åˆå§‹åŒ–æ‰€æœ‰æœºå™¨äºº
    clients = init_bots()
    if not clients:
        print("âŒ æ²¡æœ‰å¯ç”¨çš„æœºå™¨äººï¼Œç¨‹åºé€€å‡º")
            return
        
    # å¯åŠ¨åå°ä»»åŠ¡ (ä½¿ç”¨ä¸»Botçš„loop)
    loop.create_task(_process_recharge_queue_worker())

    # ä¿æŒè¿è¡Œ
    print("âœ… æ‰€æœ‰æœºå™¨äººå·²å¯åŠ¨ï¼Œå¼€å§‹ç›‘å¬æ¶ˆæ¯...")

    try:
        # åˆ›å»ºä¸€ä¸ªä»»åŠ¡æ¥ä¿æŒäº‹ä»¶å¾ªç¯è¿è¡Œ
        async def keep_running():
    while True:
            await asyncio.sleep(1)

        loop.run_until_complete(keep_running())
    except KeyboardInterrupt:
        pass
    finally:
        for c in clients:
            if c.is_connected():
                c.disconnect()

    async def _process_recharge_queue_worker():
        while True:
            try:
            if process_recharge_queue:
                    item = process_recharge_queue.pop(0)
                await process_recharge(item['member_id'], item['amount'], item.get('is_vip_order', False))
                await asyncio.sleep(1)
            except Exception as e:
            logger.error(f"[å……å€¼é˜Ÿåˆ—] é”™è¯¯: {e}")
            await asyncio.sleep(1)

def get_main_keyboard(user_id=None):
    """ä¸»èœå•é”®ç›˜"""
    keyboard = [
        [Button.text(BTN_VIP, resize=True), Button.text(BTN_VIEW_FISSION, resize=True), Button.text(BTN_MY_PROMOTE, resize=True)],
        [Button.text(BTN_RESOURCES, resize=True), Button.text(BTN_FISSION, resize=True), Button.text(BTN_PROFILE, resize=True)],
        [Button.text(BTN_SUPPORT, resize=True)]
    ]
    if user_id and user_id in ADMIN_IDS:
        keyboard[-1].append(Button.text(BTN_ADMIN, resize=True))
    return keyboard

    bot.loop.create_task(_process_recharge_queue_worker())
    print("âœ… Web -> Bot å……å€¼é˜Ÿåˆ—å¤„ç†å™¨å·²å¯åŠ¨")
    
    print("=" * 60)
    print("âœ… æ‰€æœ‰åå°ä»»åŠ¡å·²æŒ‚è½½")
    print("âœ… Telegram Bot å·²å¯åŠ¨ï¼Œç­‰å¾…æ¶ˆæ¯...")
    print("=" * 60)
    bot.run_until_disconnected()

# å¯¼å‡ºbotå®ä¾‹ä¾›å…¶ä»–æ¨¡å—ä½¿ç”¨
__all__ = [
    'bot', 
    'process_vip_upgrade', 
    'process_recharge', 
    'admin_manual_vip_handler', 
    'get_main_account_id', 
    'run_bot', 
    'pending_broadcasts', 
    'notify_queue',
    # åå°ä»»åŠ¡ï¼ˆä¾›è°ƒè¯•ä½¿ç”¨ï¼‰
    'auto_broadcast_timer',
    'process_broadcast_queue',
    'process_broadcasts',
    'check_member_status_task',
    'process_notify_queue'
]
