--- File: ./app/bot_logic.py ---
"""
æœºå™¨äººé€»è¾‘å±‚ - ç»Ÿä¸€ç®¡ç†æ‰€æœ‰Telegramæœºå™¨äººäº¤äº’
ã€æ ¸å¿ƒä¿®å¤ã€‘æ‰€æœ‰VIPå¼€é€šè·¯å¾„éƒ½è°ƒç”¨ distribute_vip_rewardsï¼Œåˆ é™¤å†—ä½™çš„æ‰‹å†™åˆ†çº¢é€»è¾‘
"""
import asyncio
import sqlite3
import time
import os
from datetime import datetime, timedelta, timezone
from telethon import TelegramClient, events, Button
from telethon.sessions import MemorySession
from telethon.tl.types import ChannelParticipantsAdmins
from telethon.tl.functions.channels import GetParticipantRequest
import socks

from config import (
    API_ID, API_HASH, ADMIN_IDS, USE_PROXY,
    PROXY_TYPE, PROXY_HOST, PROXY_PORT
)
from database import DB, get_cn_time, get_system_config, get_db_conn
from core_functions import (
    get_upline_chain, check_user_conditions, update_level_path,
    distribute_vip_rewards, check_user_in_group, check_bot_is_admin,
    verify_group_link
)
from bot_commands_addon import (
    handle_bind_group, handle_join_upline, handle_group_link_message,
    handle_check_status, handle_my_team
)


def compute_vip_price_from_config(config):
    """Compute effective VIP price: if per-level amounts configured, sum them; else use vip_price"""
    try:
        # support config 'level_amounts' as list or JSON string
        level_count = int(config.get('level_count', 10))
        level_amounts = config.get('level_amounts')
        if level_amounts:
            import json
            if isinstance(level_amounts, str):
                try:
                    parsed = json.loads(level_amounts)
                except Exception:
                    parsed = None
            else:
                parsed = level_amounts

            if isinstance(parsed, list):
                # sum first level_count entries (pad with zeros)
                vals = [float(x) for x in parsed[:level_count]]
                if len(vals) < level_count:
                    vals += [0.0] * (level_count - len(vals))
                return sum(vals)
            elif isinstance(parsed, dict):
                total = 0.0
                for i in range(1, level_count + 1):
                    v = parsed.get(str(i)) or parsed.get(i) or 0
                    total += float(v)
                return total
    except Exception:
        pass
    # fallback to simple vip_price
    try:
        return float(config.get('vip_price', 10))
    except Exception:
        return 10.0

# æŒ‰é’®æ–‡å­—å¸¸é‡
BTN_PROFILE = 'ğŸ‘¤ ä¸ªäººä¸­å¿ƒ'
BTN_FISSION = 'ğŸ”— ç¾¤è£‚å˜åŠ å…¥'
BTN_VIEW_FISSION = 'ğŸ“Š æˆ‘çš„è£‚å˜'
BTN_RESOURCES = 'ğŸ“ è¡Œä¸šèµ„æº'
BTN_PROMOTE = 'ğŸ’° èµšé’±æ¨å¹¿'
BTN_SUPPORT = 'ğŸ‘©â€ğŸ’¼ åœ¨çº¿å®¢æœ'
BTN_BACK = 'ğŸ”™ è¿”å›ä¸»èœå•'
BTN_ADMIN = 'âš™ï¸ ç®¡ç†åå°'
BTN_VIP = 'ğŸ’ å¼€é€šä¼šå‘˜'
BTN_MY_PROMOTE = 'ğŸ’« æˆ‘çš„æ¨å¹¿'
BTN_EARNINGS = 'ğŸ“Š æ”¶ç›Šè®°å½•'


async def send_vip_required_prompt(event_or_id, reply_method='respond'):
    """ç»™æœªå¼€é€šVIPçš„ç”¨æˆ·å‘é€ç»Ÿä¸€æç¤ºæ–‡æ¡ˆï¼Œæ”¯æŒ event æˆ– telegram_id"""
    try:
        if isinstance(event_or_id, int):
            telegram_id = event_or_id
            member = DB.get_member(telegram_id)
        else:
            original = event_or_id
            try:
                original_sender_id = original.sender_id
                original.sender_id = get_main_account_id(original_sender_id, getattr(original.sender, 'username', None))
            except Exception:
                pass
            member = DB.get_member(original.sender_id)
            telegram_id = original.sender_id

        config = get_system_config()
        vip_price = config.get('vip_price', 10)
        balance = member['balance'] if member else 0

        text = "æŠ±æ­‰ æ‚¨è¿˜ä¸æ˜¯VIP\n\n"
        text += "ä¸èƒ½ä½¿ç”¨æ­¤åŠŸèƒ½ è¯·å…ˆå¼€é€šVIP\n"
        text += "ç‚¹å‡»ä¸‹æ–¹ã€Œå¼€é€šVIPã€æŒ‰é’® å¼€é€šåœ¨æ¥å“¦\n\n"
        text += f"ğŸ’° VIPä»·æ ¼: {vip_price} U\n"
        text += f"ğŸ’µ å½“å‰ä½™é¢: {balance} U\n"

        buttons = []
        # å¦‚æœä½™é¢è¶³å¤Ÿï¼Œæä¾›ä½™é¢å¼€é€šæŒ‰é’®ï¼›å¦åˆ™æä¾›å……å€¼å…¥å£
        if balance >= vip_price:
            buttons = [[Button.inline('ğŸ’ ä½™é¢å¼€é€šVIP', b'confirm_vip')]]
        else:
            buttons = [[Button.inline('ğŸ’³ å……å€¼å¼€é€šVIP', b'recharge_for_vip')], [Button.inline('ğŸ’ è´­ä¹°VIP', b'open_vip')]]

        if isinstance(event_or_id, int):
            try:
                await bot.send_message(telegram_id, text, buttons=buttons)
            except Exception:
                pass
        else:
            # event-like
            try:
                if reply_method == 'respond':
                    await event_or_id.respond(text, buttons=buttons)
                else:
                    await event_or_id.answer(text, alert=True)
            except Exception:
                try:
                    await event_or_id.answer(text, alert=True)
                except Exception:
                    pass
    except Exception as e:
        print(f"[VIPæç¤º] å‘é€å¤±è´¥: {e}")

def get_active_bot_tokens():
    """è·å–æ‰€æœ‰æ´»è·ƒçš„æœºå™¨äººtoken"""
    try:
        conn = get_db_conn()
        c = conn.cursor()
        c.execute('SELECT bot_token FROM bot_configs WHERE is_active = 1 ORDER BY id ASC')
        rows = c.fetchall()
        conn.close()
        tokens = [row[0] for row in rows if row[0]]
        print(f"[æœºå™¨äººåˆå§‹åŒ–] æ‰¾åˆ° {len(tokens)} ä¸ªæ´»è·ƒæœºå™¨äººtoken")
        return tokens
    except Exception as e:
        print(f"[æœºå™¨äººåˆå§‹åŒ–] è·å–æ´»è·ƒtokenå¤±è´¥: {e}")
        return []

def select_bot_token():
    """é€‰æ‹©ä¸€ä¸ªæœºå™¨äººtokenï¼ˆè½®æµæˆ–éšæœºé€‰æ‹©ï¼‰"""
    active_tokens = get_active_bot_tokens()
    if not active_tokens:
        print("[æœºå™¨äººåˆå§‹åŒ–] âŒ é”™è¯¯ï¼šæ²¡æœ‰æ´»è·ƒçš„æœºå™¨äººtokenï¼è¯·åœ¨åå°æœºå™¨äººè®¾ç½®ä¸­æ·»åŠ å¹¶å¯ç”¨è‡³å°‘ä¸€ä¸ªæœºå™¨äººã€‚")
        print("[æœºå™¨äººåˆå§‹åŒ–] ç¨‹åºå°†é€€å‡ºï¼Œè¯·å…ˆé…ç½®æœºå™¨äººtokenã€‚")
        exit(1)  # å¼ºåˆ¶é€€å‡ºç¨‹åº

    # ç®€å•è½®æµé€‰æ‹©ï¼ˆå¯ä»¥æ”¹ä¸ºéšæœºæˆ–æ›´å¤æ‚çš„ç­–ç•¥ï¼‰
    import time
    index = int(time.time()) % len(active_tokens)
    selected_token = active_tokens[index]
    print(f"[æœºå™¨äººåˆå§‹åŒ–] âœ… é€‰æ‹©æœºå™¨äººtoken {index + 1}/{len(active_tokens)}: {selected_token[:20]}...")
    return selected_token

# åˆå§‹åŒ–æœºå™¨äºº
selected_token = select_bot_token()
if USE_PROXY:
    if PROXY_TYPE.lower() == 'socks5':
        proxy = (socks.SOCKS5, PROXY_HOST, PROXY_PORT)
    elif PROXY_TYPE.lower() == 'socks4':
        proxy = (socks.SOCKS4, PROXY_HOST, PROXY_PORT)
    elif PROXY_TYPE.lower() == 'http':
        proxy = (socks.HTTP, PROXY_HOST, PROXY_PORT)
    else:
        proxy = (socks.SOCKS5, PROXY_HOST, PROXY_PORT)
    bot = TelegramClient('bot', API_ID, API_HASH, proxy=proxy).start(bot_token=selected_token)
else:
    bot = TelegramClient(MemorySession(), API_ID, API_HASH).start(bot_token=selected_token)

print(f"[æœºå™¨äººåˆå§‹åŒ–] æœºå™¨äººå¯åŠ¨æˆåŠŸï¼Œä½¿ç”¨token: {selected_token[:20]}...")

# å…¨å±€é˜Ÿåˆ—
pending_broadcasts = []
notify_queue = []
process_recharge_queue = []
waiting_for_group_link = {}
waiting_for_backup = {}
waiting_for_recharge_amount = {}
waiting_for_withdraw_amount = {}
waiting_for_withdraw_address = {}
withdraw_temp_data = {}
admin_waiting = {}

# å¯¼å…¥æ”¯ä»˜æ¨¡å—
from payment import create_recharge_order, PAYMENT_CONFIG, generate_payment_sign

# ==================== è´¦å·å…³è”é€»è¾‘ ====================

def get_main_account_id(telegram_id, username=None):
    """è·å–ä¸»è´¦å·IDï¼ˆç²¾å‡†IDåŒ¹é…ç‰ˆï¼‰"""
    try:
        target_id_str = str(telegram_id).strip()
        clean_username = (username or '').strip().lstrip('@')
        
        conn = get_db_conn()
        c = conn.cursor()
        
        # æ ¸å¿ƒæŸ¥è¯¢ï¼šæŸ¥æ‰¾æ˜¯å¦æœ‰äººçš„ backup_account å­—æ®µç­‰äºå½“å‰è®¿é—®è€…çš„ ID
        query = "SELECT telegram_id FROM members WHERE backup_account = ?"
        c.execute(query, (target_id_str,))
        row = c.fetchone()
        
        # å¦‚æœIDæ²¡æŸ¥åˆ°ï¼Œå†å°è¯•æŸ¥ç”¨æˆ·å
        if not row and clean_username:
            c.execute(
                'SELECT telegram_id FROM members WHERE backup_account = ? OR backup_account = ?',
                (clean_username, f"@{clean_username}")
            )
            row = c.fetchone()
            
        # æ¡æ¼è´¦å·é€»è¾‘
        if not row:
            c.execute(
                'SELECT main_account_id FROM fallback_accounts '
                'WHERE telegram_id = ? AND main_account_id IS NOT NULL LIMIT 1',
                (telegram_id,)
            )
            fallback_result = c.fetchone()
            if fallback_result and fallback_result[0]:
                conn.close()
                return fallback_result[0]
        
        conn.close()
        
        if row:
            print(f"âœ… [è´¦å·åŠ«æŒæˆåŠŸ] å¤‡ç”¨å· {target_id_str} æ­£åœ¨ç™»å½• -> åˆ‡æ¢ä¸ºä¸»è´¦å· {row[0]}")
            return row[0]
        
        return telegram_id
    except Exception as e:
        print(f"[å…³è”æŸ¥è¯¢å‡ºé”™] {e}")
        return telegram_id

def format_backup_account_display(backup_account):
    """æ ¼å¼åŒ–å¤‡ç”¨å·æ˜¾ç¤º"""
    if not backup_account:
        return "æœªè®¾ç½®"
    
    backup_account_str = str(backup_account).strip()
    
    if backup_account_str.startswith('@'):
        return backup_account_str
    if not backup_account_str.isdigit():
        return f"@{backup_account_str}"
    
    try:
        backup_id = int(backup_account_str)
        backup_member = DB.get_member(backup_id)
        if backup_member and backup_member.get('username'):
            return f"@{backup_member['username']}"
        else:
            return backup_account_str
    except (ValueError, Exception):
        return backup_account_str

def link_account(main_id, backup_id, backup_username):
    """å…³è”å¤‡ç”¨å·åˆ°ä¸»è´¦å·"""
    clean_username = (backup_username or '').strip().lstrip('@')
    
    if clean_username:
        value_to_store = f"@{clean_username}"
    elif backup_id:
        value_to_store = str(backup_id)
    else:
        return False, "âŒ æ— æ•ˆçš„å¤‡ç”¨è´¦å·ä¿¡æ¯"
        
    if str(main_id) == str(backup_id) or value_to_store == str(main_id):
        return False, "âŒ ä¸èƒ½å°†è‡ªå·±è®¾ç½®ä¸ºå¤‡ç”¨å·"

    try:
        if backup_id:
            existing_member = DB.get_member(backup_id)
            if existing_member and str(backup_id) != str(main_id):
                return False, "âŒ è¯¥è´¦å·å·²æ³¨å†Œï¼Œä¸èƒ½è®¾ç½®ä¸ºå¤‡ç”¨å·"
    except Exception as e:
        print(f"[æ£€æŸ¥å¤‡ç”¨å·æ˜¯å¦å·²æ³¨å†Œå¤±è´¥] {e}")

    conn = get_db_conn()
    c = conn.cursor()
    try:
        c.execute('SELECT telegram_id FROM members WHERE backup_account = ?', (str(backup_id),))
        existing_by_id = c.fetchone()
        
        c.execute(
            'SELECT telegram_id FROM members WHERE backup_account = ? OR backup_account = ?',
            (clean_username, f"@{clean_username}")
        )
        existing_by_name = c.fetchone()
        
        existing = existing_by_id or existing_by_name
        
        if existing and str(existing[0]) != str(main_id):
            conn.close()
            return False, "âŒ è¯¥è´¦å·å·²ç»æ˜¯å…¶ä»–äººçš„å¤‡ç”¨å·äº†ï¼Œæ— æ³•é‡å¤ç»‘å®š"

        c.execute('UPDATE members SET backup_account = ? WHERE telegram_id = ?', (value_to_store, main_id))
        conn.commit()
        conn.close()
        return True, f"âœ… å¤‡ç”¨è´¦å·å…³è”æˆåŠŸï¼\nç»‘å®šå€¼: {value_to_store}\n\nè¯·ä½¿ç”¨å¤‡ç”¨å·å‘é€ /start æµ‹è¯•ã€‚"
        
    except Exception as e:
        try:
            conn.close()
        except:
            pass
        return False, f"å…³è”å¤±è´¥: {str(e)}"

def get_fallback_resource(resource_type='group'):
    """è·å–æ¡æ¼è´¦å·èµ„æº"""
    try:
        conn = get_db_conn()
        c = conn.cursor()
        if resource_type == 'group':
            # è¿”å›åŒ…å«ç¾¤ç»„åç§°å’Œé“¾æ¥çš„åˆ—è¡¨
            c.execute("SELECT username, group_link FROM fallback_accounts WHERE is_active = 1 AND group_link IS NOT NULL AND group_link != '' ORDER BY id ASC")
            results = c.fetchall()
            conn.close()
            if results:
                groups = []
                seen = set()
                for username, group_link in results:
                    if not group_link:
                        continue
                    g_links = group_link.split('\n')
                    for link in g_links:
                        link = link.strip()
                        if link and link not in seen:
                            # é»˜è®¤ä½¿ç”¨ç”¨æˆ·åï¼Œå¦‚æœæ²¡æœ‰åˆ™ä½¿ç”¨é“¾æ¥æœ€åä¸€éƒ¨åˆ†
                            default_name = username or link.split('/')[-1].replace('+', '')
                            groups.append({
                                'username': username or '',
                                'link': link,
                                'name': default_name  # é»˜è®¤åç§°ï¼Œåç»­å¯ä»¥é€šè¿‡Telegram APIè·å–å®é™…åç§°
                            })
                            seen.add(link)
                return groups if groups else None
        elif resource_type == 'account':
            c.execute("SELECT telegram_id, username FROM fallback_accounts WHERE is_active = 1 ORDER BY RANDOM() LIMIT 1")
            result = c.fetchone()
            conn.close()
            if result:
                return {'telegram_id': result[0], 'username': result[1]}
        conn.close()
    except Exception as e:
        print(f"[æ¡æ¼é”™è¯¯] {e}")
    return None

async def get_group_title(bot, group_link):
    """ä»Telegram APIè·å–ç¾¤ç»„å®é™…åç§°"""
    try:
        # æå–ç¾¤ç»„ç”¨æˆ·å
        if 't.me/' in group_link:
            group_username = group_link.split('t.me/')[-1].split('/')[0].split('?')[0]
        elif group_link.startswith('@'):
            group_username = group_link[1:]
        else:
            return None
        
        # è·³è¿‡ç§æœ‰ç¾¤é“¾æ¥
        if group_username.startswith('+'):
            return None
        
        # è·å–ç¾¤ç»„å®ä½“
        group_entity = await bot.get_entity(group_username)
        title = getattr(group_entity, 'title', None)
        return title
    except Exception as e:
        print(f"[è·å–ç¾¤ç»„åç§°å¤±è´¥] {group_link}: {e}")
    return None

def get_main_keyboard(user_id=None):
    """ä¸»èœå•é”®ç›˜"""
    keyboard = [
        [Button.text(BTN_VIP, resize=True), Button.text(BTN_VIEW_FISSION, resize=True), Button.text(BTN_MY_PROMOTE, resize=True)],
        [Button.text(BTN_RESOURCES, resize=True), Button.text(BTN_FISSION, resize=True), Button.text(BTN_PROFILE, resize=True)],
        [Button.text(BTN_SUPPORT, resize=True)]
    ]
    if user_id and user_id in ADMIN_IDS:
        keyboard[-1].append(Button.text(BTN_ADMIN, resize=True))
    return keyboard

# ==================== ã€æ ¸å¿ƒä¿®å¤ã€‘VIPå¼€é€šé€»è¾‘ ====================
# æ‰€æœ‰VIPå¼€é€šè·¯å¾„éƒ½ç»Ÿä¸€è°ƒç”¨ distribute_vip_rewardsï¼Œåˆ é™¤å†—ä½™çš„æ‰‹å†™åˆ†çº¢ä»£ç 

async def process_vip_upgrade(telegram_id, vip_price, config, deduct_balance=True):
    """
    ç»Ÿä¸€çš„VIPå¼€é€šå¤„ç†å‡½æ•°
    ã€æ ¸å¿ƒã€‘æ‰€æœ‰VIPå¼€é€šéƒ½è°ƒç”¨è¿™ä¸ªå‡½æ•°ï¼Œç¡®ä¿é€»è¾‘ä¸€è‡´
    
    Args:
        telegram_id: ç”¨æˆ·ID
        vip_price: VIPä»·æ ¼ï¼ˆç”¨äºåˆ†çº¢è®¡ç®—ï¼‰
        config: ç³»ç»Ÿé…ç½®
        deduct_balance: æ˜¯å¦æ‰£é™¤ä½™é¢ï¼ˆTrue=ç”¨æˆ·è‡ªå·±å¼€é€šï¼ŒFalse=ç®¡ç†å‘˜èµ é€ï¼‰
    """
    # 1. æ£€æŸ¥ç”¨æˆ·çŠ¶æ€
    member = DB.get_member(telegram_id)
    if not member:
        return False, "ç”¨æˆ·ä¸å­˜åœ¨"
    
    if member.get('is_vip'):
        return False, "ç”¨æˆ·å·²æ˜¯VIP"
    
    # 2. æ‰£é™¤ä½™é¢ï¼ˆå¦‚æœéœ€è¦ï¼‰
    print(f'[process_vip_upgrade] å¼€å§‹å¤„ç†: telegram_id={telegram_id}, deduct_balance={deduct_balance}, å½“å‰ä½™é¢={member["balance"]}, vip_price={vip_price}')
    if deduct_balance:
        if member['balance'] < vip_price:
            print(f'[process_vip_upgrade] ä½™é¢ä¸è¶³: éœ€è¦{vip_price}, å½“å‰{member["balance"]}')
            return False, "ä½™é¢ä¸è¶³"
        new_balance = member['balance'] - vip_price
        print(f'[process_vip_upgrade] æ‰£è´¹: {member["balance"]} -> {new_balance}')
        DB.update_member(telegram_id, balance=new_balance, is_vip=1, vip_time=get_cn_time())
    else:
        # ç®¡ç†å‘˜èµ é€ï¼Œä¸æ‰£é™¤ä½™é¢
        new_balance = member['balance']
        print(f'[process_vip_upgrade] ç®¡ç†å‘˜èµ é€VIP: ä½™é¢ä¿æŒ{new_balance}')
        DB.update_member(telegram_id, is_vip=1, vip_time=get_cn_time())
    
    # 3. æ›´æ–°å±‚çº§è·¯å¾„
    update_level_path(telegram_id)
    
    # 4. ã€æ ¸å¿ƒã€‘è°ƒç”¨ç»Ÿä¸€åˆ†çº¢å‡½æ•°ï¼ˆæ›¿ä»£æ‰€æœ‰æ‰‹å†™å¾ªç¯ï¼‰
    stats = await distribute_vip_rewards(bot, telegram_id, vip_price, config)
    
    return True, {
        'new_balance': new_balance,
        'stats': stats
    }

# ==================== äº‹ä»¶å¤„ç†å™¨ ====================

@bot.on(events.NewMessage(pattern='/start'))
async def start_handler(event):
    """å¯åŠ¨å‘½ä»¤"""
    original_id = event.sender_id
    original_username = getattr(event.sender, 'username', None)
    telegram_id = get_main_account_id(original_id, original_username)
    
    username = event.sender.username or f'user_{original_id}'
    
    if original_id != telegram_id:
        print(f"âš ï¸ [Startå‘½ä»¤] æ£€æµ‹åˆ°å¤‡ç”¨å·ç™»å½•: {original_id} -> åˆ‡æ¢è‡³ä¸»è´¦å· {telegram_id}")
    
    # è§£ææ¨èäººID
    referrer_id = None
    if event.message.text and len(event.message.text.split()) > 1:
        try:
            referrer_id = int(event.message.text.split()[1])
        except:
            pass
    
    member = DB.get_member(telegram_id)
    
    if not member:
        created = DB.create_member(telegram_id, username, referrer_id)
        member = DB.get_member(telegram_id)
        if not created and not member:
            await event.respond('âŒ è´¦å·ä¿¡æ¯åˆ›å»ºå¤±è´¥ï¼Œè¯·ç¨åå†è¯•')
            return
        
        # é€šçŸ¥æ¨èäºº
        if referrer_id:
            referrer = DB.get_member(referrer_id)
            if referrer:
                try:
                    user_full_name = event.sender.first_name or f'user_{telegram_id}'
                    await bot.send_message(
                        referrer_id,
                        f'ğŸ‰ æ–°æˆå‘˜åŠ å…¥!\nç”¨æˆ·: [{user_full_name}](tg://user?id={telegram_id})\né€šè¿‡æ‚¨çš„æ¨å¹¿é“¾æ¥åŠ å…¥äº†æœºå™¨äºº',
                        parse_mode='markdown'
                    )
                except:
                    pass
    
    sys_config = get_system_config()
    pinned_ad = sys_config.get('pinned_ad', '')
    
    welcome_text = (
        f'ğŸ‘‹ æ¬¢è¿ä½¿ç”¨è£‚å˜æ¨å¹¿æœºå™¨äºº!\n\n'
        f'ğŸ‘¤ å½“å‰æ˜¾ç¤ºèº«ä»½ID: `{telegram_id}`\n'
        f'ğŸ’ VIPçŠ¶æ€: {"âœ… å·²å¼€é€š" if member["is_vip"] else "âŒ æœªå¼€é€š"}\n'
        f'ğŸ’° ä½™é¢: {member["balance"]} U\n\n'
        f'è¯·é€‰æ‹©åŠŸèƒ½:'
    )
    
    if pinned_ad:
        welcome_text += f'\n\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\nğŸ“¢ {pinned_ad}'
    
    await event.respond(welcome_text, buttons=get_main_keyboard(telegram_id))
    # é˜»æ­¢äº‹ä»¶ç»§ç»­ä¼ æ’­
    event.stop_propagation()

@bot.on(events.CallbackQuery(data=b'open_vip_balance'))
async def open_vip_balance_callback(event):
    """ã€å·²ä¿®å¤ã€‘ä½¿ç”¨ä½™é¢å¼€é€šVIP - ç»Ÿä¸€è°ƒç”¨ distribute_vip_rewards"""
    try:
        original_sender_id = event.sender_id
        event.sender_id = get_main_account_id(original_sender_id, getattr(event.sender, 'username', None))
    except:
        pass
    
    telegram_id = event.sender_id
    member = DB.get_member(telegram_id)
    
    if not member:
        await event.answer("âŒ ç”¨æˆ·ä¿¡æ¯ä¸å­˜åœ¨", alert=True)
        return
    
    if member.get('is_vip'):
        await event.answer("âœ… æ‚¨å·²ç»æ˜¯VIPä¼šå‘˜", alert=True)
        return
    
    config = get_system_config()
    vip_price = compute_vip_price_from_config(config)
    user_balance = member.get('balance', 0)
    
    if user_balance < vip_price:
        await event.answer(f"âŒ ä½™é¢ä¸è¶³\nå½“å‰ä½™é¢: {user_balance} U\nVIPä»·æ ¼: {vip_price} U", alert=True)
        return
    
    # ã€æ ¸å¿ƒä¿®å¤ã€‘è°ƒç”¨ç»Ÿä¸€å¤„ç†å‡½æ•°
    success, result = await process_vip_upgrade(telegram_id, vip_price, config)
    
    if not success:
        await event.answer(f"âŒ {result}", alert=True)
        return
    
    stats = result['stats']
    new_balance = result['new_balance']
    
    text = f"""ğŸ‰ æ­å–œ! VIPå¼€é€šæˆåŠŸ!

âœ… æ‚¨å·²æˆä¸ºVIPä¼šå‘˜
ğŸ’° æ¶ˆè´¹é‡‘é¢: {vip_price} U
ğŸ’µ å‰©ä½™ä½™é¢: {new_balance} U

ğŸ ä¸Šçº§è·å¾— {stats["real"]} æ¬¡å¥–åŠ±
ğŸ’ æ¨èè´¦å·è·å¾— {stats["fallback"]} æ¬¡å¥–åŠ±"""
    
    # ä»¥æ¶ˆæ¯å½¢å¼å‘é€å¼€é€šæˆåŠŸé€šçŸ¥ï¼ˆé¿å…å¼¹çª— alertï¼‰ï¼Œå¹¶å°è¯•åˆ é™¤ä¹‹å‰çš„äº¤äº’æ¶ˆæ¯
    try:
        await event.respond(text)
    except:
        await event.answer(text, alert=True)
    try:
        await event.delete()
    except:
        pass

@bot.on(events.CallbackQuery(pattern=b'confirm_vip'))
async def confirm_vip_callback(event):
    """ã€å·²ä¿®å¤ã€‘ç¡®è®¤å¼€é€šVIP - ç»Ÿä¸€è°ƒç”¨ distribute_vip_rewards"""
    config = get_system_config()
    try:
        original_sender_id = event.sender_id
        event.sender_id = get_main_account_id(original_sender_id, getattr(event.sender, 'username', None))
    except:
        pass
    
    member = DB.get_member(event.sender_id)
    if not member:
        await event.answer('è¯·å…ˆå‘é€ /start æ³¨å†Œ')
        return
    
    if member['is_vip']:
        await event.answer('æ‚¨å·²ç»æ˜¯VIPäº†!')
        return
    
    vip_price = compute_vip_price_from_config(config)
    if member['balance'] < vip_price:
        await event.answer(f'ä½™é¢ä¸è¶³! è¿˜éœ€ {vip_price - member["balance"]} U', alert=True)
        return
    
    # ã€æ ¸å¿ƒä¿®å¤ã€‘è°ƒç”¨ç»Ÿä¸€å¤„ç†å‡½æ•°
    success, result = await process_vip_upgrade(event.sender_id, vip_price, config)
    
    if not success:
        await event.answer(f"âŒ {result}", alert=True)
        return
    
    stats = result['stats']
    
    await event.respond(
        f'ğŸ‰ æ­å–œ! VIPå¼€é€šæˆåŠŸ!\n\n'
        f'æ‚¨ç°åœ¨å¯ä»¥:\n'
        f'âœ… æŸ¥çœ‹è£‚å˜æ•°æ®\n'
        f'âœ… è·å¾—ä¸‹çº§å¼€é€šVIPçš„å¥–åŠ±\n'
        f'âœ… åŠ å…¥ä¸Šçº§ç¾¤ç»„\n'
        f'âœ… æ¨å¹¿èµšé’±',
        buttons=[[Button.inline('ğŸ”™ è¿”å›ä¸»èœå•', b'back_to_profile')]]
    )
    await event.answer()

# ==================== å……å€¼å¤„ç† ====================

async def send_recharge_notification(telegram_id, amount):
    """å‘é€å……å€¼æˆåŠŸé€šçŸ¥"""
    try:
        message = f"""âœ… å……å€¼æˆåŠŸ

ğŸ’° å……å€¼é‡‘é¢: {amount} USDT
ğŸ“ è®¢å•çŠ¶æ€: å·²å®Œæˆ
â° åˆ°è´¦æ—¶é—´: {get_cn_time()}

æ‚¨çš„ä½™é¢å·²è‡ªåŠ¨å¢åŠ ï¼Œå¯ä»¥åœ¨ä¸ªäººä¸­å¿ƒæŸ¥çœ‹ã€‚"""
        
        await bot.send_message(telegram_id, message)
        print(f'[å……å€¼é€šçŸ¥] å·²å‘é€é€šçŸ¥ç»™ç”¨æˆ· {telegram_id}')
    except Exception as e:
        print(f'[å……å€¼é€šçŸ¥] å‘é€å¤±è´¥: {e}')

async def process_recharge(telegram_id, amount, is_vip_order=False):
    """å¤„ç†å……å€¼åç»­é€»è¾‘ï¼ˆå¼€é€šVIPã€åˆ†çº¢ã€é€šçŸ¥ï¼‰"""
    try:
        config = get_system_config()
        member = DB.get_member(telegram_id)
        if not member:
            return False
            
        # Webç«¯å·²ç»å¢åŠ äº†ä½™é¢ï¼Œè¿™é‡Œç›´æ¥è·å–æœ€æ–°ä½™é¢
        current_balance = member.get('balance', 0)
        vip_price = compute_vip_price_from_config(config)

        # è‹¥ä¸ºVIPè®¢å•ä¸”ç”¨æˆ·å°šæœªVIPä¸”ä½™é¢è¶³å¤Ÿï¼šæ‰£è´¹ã€å¼€é€šã€åˆ†çº¢ã€é€šçŸ¥
        if is_vip_order and not member.get('is_vip', False) and current_balance >= vip_price:
            print(f'[å……å€¼å¤„ç†] å¼€å§‹VIPè‡ªåŠ¨å¼€é€š: telegram_id={telegram_id}, ä½™é¢={current_balance}')
            new_balance = current_balance - vip_price
            DB.update_member(telegram_id, balance=new_balance, is_vip=1, vip_time=get_cn_time())
            update_level_path(telegram_id)
            from core_functions import distribute_vip_rewards, generate_vip_success_message
            try:
                await distribute_vip_rewards(bot, telegram_id, vip_price, config)
            except Exception as e:
                print(f"[å……å€¼å¤„ç†] åˆ†å‘å¥–åŠ±å‡ºé”™: {e}")
            msg = generate_vip_success_message(telegram_id, amount, vip_price, new_balance)
            try:
                await bot.send_message(telegram_id, msg, parse_mode='markdown')
            except Exception as e:
                print(f"[å……å€¼å¤„ç†] å‘é€é€šçŸ¥å¤±è´¥: {e}")

            # æ™®é€šå……å€¼æˆ–ä½™é¢ä¸è¶³ï¼šå¦‚æœä¸æ˜¯VIPè®¢å•ï¼Œå‘é€æ™®é€šåˆ°è´¦é€šçŸ¥
            if not is_vip_order:
                try:
                    await bot.send_message(
                        telegram_id,
                        f'âœ… å……å€¼åˆ°è´¦é€šçŸ¥\\n\\nğŸ’° é‡‘é¢: {amount} U\\nğŸ’µ å½“å‰ä½™é¢: {current_balance} U'
                    )
                except Exception as e:
                    print(f"[å……å€¼å¤„ç†] å‘é€æ™®é€šé€šçŸ¥å¤±è´¥: {e}")
                    return True
    except Exception as e:
        print(f"[å……å€¼å¤„ç†å¼‚å¸¸] {e}")
        import traceback
        traceback.print_exc()
        return False

# ==================== ç®¡ç†å‘˜æ‰‹åŠ¨å¼€é€šVIP ====================

async def admin_manual_vip_handler(telegram_id, config):
    """
    ã€å·²ä¿®å¤ã€‘ç®¡ç†å‘˜æ‰‹åŠ¨å¼€é€šVIP
    ç»Ÿä¸€è°ƒç”¨ distribute_vip_rewardsï¼Œåˆ é™¤æ‰€æœ‰æ‰‹å†™åˆ†çº¢é€»è¾‘
    """
    member = DB.get_member(telegram_id)
    if not member:
        return False, "ç”¨æˆ·ä¸å­˜åœ¨"
    
    if member.get('is_vip'):
        return False, "ç”¨æˆ·å·²æ˜¯VIP"
    
    # ã€æ ¸å¿ƒä¿®å¤ã€‘è°ƒç”¨ç»Ÿä¸€å¤„ç†å‡½æ•°ï¼ˆä¸æ‰£é™¤ä½™é¢ï¼Œå› ä¸ºæ˜¯ç®¡ç†å‘˜èµ é€ï¼‰
    vip_price = compute_vip_price_from_config(config)
    success, result = await process_vip_upgrade(telegram_id, vip_price, config, deduct_balance=False)
    
    if not success:
        return False, result
    
    stats = result['stats']
    
    # é€šçŸ¥ç”¨æˆ·
    try:
        await bot.send_message(
            telegram_id,
            f'ğŸ‰ æ­å–œ! ç®¡ç†å‘˜å·²ä¸ºæ‚¨å¼€é€šVIP!\n\n'
            f'æ‚¨ç°åœ¨å¯ä»¥:\n'
            f'âœ… æŸ¥çœ‹è£‚å˜æ•°æ®\n'
            f'âœ… è·å¾—ä¸‹çº§å¼€é€šVIPçš„å¥–åŠ±\n'
            f'âœ… åŠ å…¥ä¸Šçº§ç¾¤ç»„\n'
            f'âœ… æ¨å¹¿èµšé’±\n\n'
            f'æ„Ÿè°¢æ‚¨çš„æ”¯æŒ!'
        )
    except Exception as e:
        print(f"é€šçŸ¥ç”¨æˆ·å¤±è´¥: {e}")
    
    return True, {
        'stats': stats,
        'username': member.get('username', '')
    }

# ==================== ç¾¤è£‚å˜åŠ å…¥ï¼ˆä¿®å¤ç‰ˆï¼‰====================

@bot.on(events.NewMessage(pattern=BTN_FISSION))
async def fission_handler(event):
    """ç¾¤è£‚å˜åŠ å…¥ï¼ˆä¿®å¤ç‰ˆ - ä½¿ç”¨ get_upline_chainï¼‰"""
    telegram_id = get_main_account_id(event.sender_id, getattr(event.sender, 'username', None))
    member = DB.get_member(telegram_id)
    
    if not member:
        await event.respond("âŒ è¯·å…ˆä½¿ç”¨ /start å¼€å§‹")
        return
    
    config = get_system_config()
    
    # æ£€æŸ¥VIP
    if not member.get('is_vip'):
        vip_price = config.get('vip_price', 10)
        user_balance = member.get('balance', 0)
        need_recharge = vip_price - user_balance
        
        text = f"""âŒ æ‚¨è¿˜æœªå¼€é€šVIP

å¼€é€šVIPåå¯è·å¾—ä»¥ä¸‹æƒç›Š:
âœ… æŸ¥çœ‹è£‚å˜æ•°æ®
âœ… è·å¾—ä¸‹çº§å¼€é€šVIPçš„å¥–åŠ±
âœ… åŠ å…¥ä¸Šçº§ç¾¤ç»„

ğŸ’° VIPä»·æ ¼: {vip_price} U
ğŸ’µ æ‚¨çš„ä½™é¢: {user_balance} U"""
        
        if user_balance >= vip_price:
            buttons = [[Button.inline('ğŸ’ ä½™é¢å¼€é€šVIP', b'open_vip_balance')]]
        else:
            text += f"\n\nâŒ ä½™é¢ä¸è¶³ï¼Œè¯·å…ˆå……å€¼"
            buttons = [[Button.inline(f'ğŸ’° å……å€¼{need_recharge}Uå¼€é€šVIP', b'recharge_for_vip')]]
        
        await event.respond(text, buttons=buttons)
        return
    
    # å·²å¼€é€šVIPï¼Œç»Ÿä¸€æ˜¾ç¤ºæ‰€æœ‰éœ€è¦åŠ å…¥çš„ç¾¤ç»„ï¼ˆ1-10å±‚ï¼‰
    text = "ğŸ”— **ç¾¤è£‚å˜åŠ å…¥åˆ—è¡¨**\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n"
    
    # è·å–ç³»ç»Ÿé…ç½®
    level_count = min(config.get('level_count', 10), 10)
    
    # ä½¿ç”¨ get_upline_chain è·å–å®Œæ•´çš„10å±‚å…³ç³»
    chain = get_upline_chain(telegram_id, level_count)
    
    # è·å–æ‰€æœ‰æ¡æ¼ç¾¤ç»„
    fb_groups = get_fallback_resource('group')
    # Debug: æ‰“å°æ¡æ¼ç¾¤ç»„åŸå§‹è¿”å›ï¼Œä¾¿äºè¯Šæ–­ä¸ºä½•ä¸ºç©ºæˆ–ä¸åŒ…å«é“¾æ¥
    print(f"[fission debug] get_fallback_resource('group') returned: {fb_groups}")
    try:
        conn_dbg = get_db_conn()
        c_dbg = conn_dbg.cursor()
        c_dbg.execute("SELECT id, telegram_id, username, group_link, is_active FROM fallback_accounts ORDER BY id ASC")
        fb_rows = c_dbg.fetchall()
        print(f"[fission debug] fallback_accounts count: {len(fb_rows)}")
        for r in fb_rows:
            print(f"[fission debug] fallback_accounts row: id={r[0]}, telegram_id={r[1]}, username={r[2]}, is_active={r[4]}, group_link={r[3]}")
        conn_dbg.close()
    except Exception as dbg_e:
        print(f"[fission debug] error reading fallback_accounts: {dbg_e}")

    if not fb_groups:
        await event.respond("âŒ ç³»ç»Ÿé”™è¯¯ï¼šæ¡æ¼ç¾¤ç»„æœªé…ç½®ï¼Œè¯·è”ç³»ç®¡ç†å‘˜")
        return
    
    # æ„å»ºå±‚çº§æ˜ å°„ï¼šlevel -> ä¸Šçº§ä¿¡æ¯ï¼ˆå¦‚æœå­˜åœ¨ä¸”å®Œæˆä»»åŠ¡ï¼‰
    upline_map = {}
    for item in chain:
        if item.get('is_fallback'):
            continue
        level = item['level']
        upline_id = item['id']
        up_member = DB.get_member(upline_id)
        if up_member and up_member.get('group_link'):
            # æ£€æŸ¥ä¸Šçº§æ˜¯å¦å®Œæˆä»»åŠ¡
            try:
                conds = await check_user_conditions(bot, upline_id)
                if conds and conds['all_conditions_met']:
                    group_links = up_member['group_link'].split('\n')
                    for link in group_links:
                        if link.strip():
                            upline_map[level] = {
                                'link': link.strip(),
                                'upline_id': upline_id
                            }
                            break
            except Exception as e:
                print(f"[ç¾¤è£‚å˜åˆ—è¡¨] æ£€æŸ¥ç¬¬{level}å±‚ä¸Šçº§æ¡ä»¶å¤±è´¥: {e}")
    
    # æ„å»ºæœ€ç»ˆæ˜¾ç¤ºçš„ç¾¤ç»„åˆ—è¡¨ï¼ˆæŒ‰æ˜¾ç¤ºé¡ºåºå¡«å……ï¼šç¬¬1..ç¬¬Nï¼‰
    # è§„åˆ™è°ƒæ•´ï¼šå¦‚æœä¸Šçº§å­˜åœ¨å¹¶å®Œæˆä»»åŠ¡ï¼Œåº”è¯¥æ›¿æ¢æ˜¾ç¤ºåˆ—è¡¨çš„ä»åå‘å‰ä½ç½®ï¼š
    #   ä¸Š1çº§ (level=1) -> æ›¿æ¢æ˜¾ç¤ºç¬¬ N é¡¹ï¼ˆæœ€åä¸€é¡¹ï¼‰
    #   ä¸Š2çº§ (level=2) -> æ›¿æ¢æ˜¾ç¤ºç¬¬ N-1 é¡¹ï¼Œä¾æ­¤ç±»æ¨
    groups_to_show = [None] * level_count  # 0-based positions

    # å…ˆæŠŠä¸Šçº§ç¾¤æ”¾åˆ°å¯¹åº”æ˜¾ç¤ºä½ç½®
    for item in chain:
        if item.get('is_fallback'):
            continue
        level = item['level']
        upline_id = item['id']
        up_member = DB.get_member(upline_id)
        if up_member and up_member.get('group_link'):
            try:
                conds = await check_user_conditions(bot, upline_id)
                if conds and conds['all_conditions_met']:
                    group_link = up_member['group_link'].split('\n')[0].strip()
                    # è®¡ç®—æ˜¾ç¤ºä½ç½®ï¼ˆä»åå‘å‰ï¼‰
                    pos = level_count - level  # 0-based index
                    if pos < 0 or pos >= level_count:
                        continue
                    group_name = f"ç¬¬{level}å±‚ä¸Šçº§"
                    # å°è¯•è·å–ç¾¤åç§°ï¼ˆä¼˜å…ˆä½¿ç”¨å®é™…ç¾¤æ ‡é¢˜ï¼‰
                    try:
                        if 't.me/' in group_link:
                            group_username = group_link.split('t.me/')[-1].split('/')[0].split('?')[0]
                        elif group_link.startswith('@'):
                            group_username = group_link[1:]
                        else:
                            group_username = group_link

                        if not group_username.startswith('+'):
                            try:
                                group_entity = await bot.get_entity(group_username)
                                title = getattr(group_entity, 'title', None)
                                if title:
                                    group_name = title
                            except Exception:
                                # è·å–å®ä½“æˆ–æ ‡é¢˜å¤±è´¥ï¼Œä½¿ç”¨é»˜è®¤ group_name
                                pass
                    except Exception:
                        # group_link è§£æå¼‚å¸¸ï¼Œç»§ç»­ä½¿ç”¨é»˜è®¤ group_name
                        pass

                    # å¡«å……æ˜¾ç¤ºæ•°ç»„
                    groups_to_show[pos] = {
                        'level': level,
                        'link': group_link,
                        'name': group_name,
                        'type': 'upline'
                    }
            except Exception as e:
                print(f"[ç¾¤è£‚å˜åˆ—è¡¨] æ£€æŸ¥ç¬¬{level}å±‚ä¸Šçº§æ¡ä»¶å¤±è´¥: {e}")

    # ç”¨æ¡æ¼ç¾¤è¡¥å…¨å‰©ä½™ä½ç½®ï¼ˆæŒ‰ä»å‰åˆ°åæ˜ å°„çº§åˆ«ï¼‰
    for display_idx in range(level_count):
        if groups_to_show[display_idx] is None:
            # è¦è®¡ç®—è¯¥æ˜¾ç¤ºä½å¯¹åº”çš„å±‚çº§ï¼ˆåå‘ï¼‰ï¼š display_idx = level_count - level
            level_for_slot = level_count - display_idx
            fb_index = (level_for_slot - 1) % len(fb_groups)
            fb_group = fb_groups[fb_index]
            group_link = (fb_group.get('link') or '').strip()
            group_name = fb_group.get('name') or fb_group.get('username') or f'æ¨èç¾¤ç»„ {level_for_slot}'
            try:
                if group_link:
                    actual_title = await get_group_title(bot, group_link)
                    if actual_title:
                        group_name = actual_title
            except:
                pass
            # Always fill the slot; if link missing, leave empty string and display as plain text
            groups_to_show[display_idx] = {
                'level': level_for_slot,
                'link': group_link,
                'name': group_name,
                'type': 'fallback'
            }
    
    # ç»Ÿä¸€æ˜¾ç¤ºåœ¨"æ¨èåŠ å…¥çš„ç¾¤ç»„"ä¸­
    if groups_to_show:
        text += "ğŸ”¥ **æ¨èåŠ å…¥çš„ç¾¤ç»„ï¼š**\n"
        for idx, group_info in enumerate(groups_to_show, 1):
            # æ˜¾ç¤ºç¼–å·ä¸ºä»åå‘å‰ï¼ˆä¾‹å¦‚ level_count=10 åˆ™é¦–é¡¹æ˜¾ç¤ºä¸º 10ï¼‰
            display_num = level_count - (idx - 1)
            if not group_info:
                text += f"{display_num}. æœªé…ç½®\n"
                continue
            name = group_info.get('name') or f'æ¨èç¾¤ç»„ {display_num}'
            link = group_info.get('link') or ''
            if link:
                text += f"{display_num}. [{name}]({link})\n"
            else:
                text += f"{display_num}. {name}\n"
    else:
        await event.respond("âŒ æš‚æ— å¯ç”¨ç¾¤ç»„ï¼Œè¯·è”ç³»ç®¡ç†å‘˜é…ç½®æ¡æ¼è´¦å·ç¾¤é“¾æ¥ã€‚")
        return
        
    buttons = [[Button.inline('ğŸ” éªŒè¯å·²åŠ ç¾¤', f'verify_groups_{telegram_id}'.encode())]]
    await event.respond(text, buttons=buttons, parse_mode='markdown')

# ==================== æ³¨å†Œå…¶ä»–å‘½ä»¤å¤„ç†å™¨ ====================

@bot.on(events.NewMessage(pattern=BTN_PROFILE))
async def profile_handler(event):
    """ä¸ªäººä¸­å¿ƒ"""
    try:
        original_id = event.sender_id
        event.sender_id = get_main_account_id(original_id, getattr(event.sender, 'username', None))
    except:
        pass
    
    member = DB.get_member(event.sender_id)
    if not member:
        await event.respond('è¯·å…ˆå‘é€ /start æ³¨å†Œ')
        return
    
    buttons = [
        [Button.inline('ğŸ”— è®¾ç½®ç¾¤é“¾æ¥', b'set_group'), Button.inline('âœï¸ è®¾ç½®å¤‡ç”¨å·', b'set_backup')],
        [Button.inline('ğŸ’³ æç°', b'withdraw'), Button.inline('ğŸ’° å……å€¼', b'do_recharge'), Button.inline('ğŸ’ å¼€é€šVIP', b'open_vip')],
        [Button.inline('ğŸ“Š æ”¶ç›Šè®°å½•', b'earnings_history')],
    ]
    
    backup_display = format_backup_account_display(member.get("backup_account"))
    
    # è·å–æ¨èäººä¿¡æ¯
    referrer_info = ""
    if member.get("referrer_id"):
        referrer = DB.get_member(member["referrer_id"])
        if referrer:
            referrer_username = referrer.get("username", "")
            referrer_info = f'ğŸ‘¥ æ¨èäºº: @{referrer_username} ({member["referrer_id"]})' if referrer_username else f'ğŸ‘¥ æ¨èäººID: {member["referrer_id"]}'
        else:
            referrer_info = f'ğŸ‘¥ æ¨èäººID: {member["referrer_id"]}'
    
    text = f'ğŸ‘¤ ä¸ªäººä¸­å¿ƒ (å·²åŒæ­¥ä¸»è´¦å·)\n\n'
    text += f'ğŸ†” ä¸»è´¦å·ID: `{member["telegram_id"]}`\n'
    text += f'ğŸ‘¤ ä¸»è´¦å·å: @{member["username"]}\n'
    if referrer_info:
        text += f'{referrer_info}\n'
    text += f'ğŸ’ VIPçŠ¶æ€: {"âœ… å·²å¼€é€š" if member["is_vip"] else "âŒ æœªå¼€é€š"}\n'
    text += f'ğŸ’° ä½™é¢: {member["balance"]} U\n'
    text += f'ğŸ“‰ é”™è¿‡ä½™é¢: {member["missed_balance"]} U\n'
    text += f'ğŸ”— ç¾¤é“¾æ¥: {member["group_link"] or "æœªè®¾ç½®"}\n'
    text += f'ğŸ“± ç»‘å®šå¤‡ç”¨å·: {backup_display}\n'
    text += f'\nğŸ“… æ³¨å†Œæ—¶é—´: {member["register_time"][:10] if member["register_time"] else "æœªçŸ¥"}'
    
    await event.respond(text, buttons=buttons)

# ==================== ä¸ªäººä¸­å¿ƒæŒ‰é’®å›è°ƒå¤„ç† ====================

@bot.on(events.CallbackQuery(pattern=b'set_group'))
async def set_group_callback(event):
    """è®¾ç½®ç¾¤é“¾æ¥å›è°ƒ"""
    # è´¦å·å…³è”å¤„ç†ï¼ˆå¤‡ç”¨å·->ä¸»è´¦å·ï¼‰
    try:
        original_sender_id = event.sender_id
        event.sender_id = get_main_account_id(original_sender_id, getattr(event.sender, 'username', None))
    except:
        pass
    member = DB.get_member(event.sender_id)
    if not member:
        await event.answer('è¯·å…ˆå‘é€ /start æ³¨å†Œ')
        return

    # VIP check
    if not member.get('is_vip'):
        await send_vip_required_prompt(event)
        return
    
    # åˆ‡æ¢åˆ°ç¾¤é“¾æ¥è¾“å…¥æ—¶ï¼Œæ¸…ç†å¤‡ç”¨å·ç­‰å¾…çŠ¶æ€
    waiting_for_backup.pop(event.sender_id, None)
    waiting_for_group_link[event.sender_id] = True
    await event.respond(
        'ğŸ”— è®¾ç½®ç¾¤é“¾æ¥\n\n'
        'è¯·å‘é€æ‚¨çš„ç¾¤é“¾æ¥ (æ ¼å¼: http://t.me/ç¾¤ç”¨æˆ·å æˆ– https://t.me/ç¾¤ç”¨æˆ·å)\n\n'
        'å‘é€ /cancel å–æ¶ˆæ“ä½œ'
    )
    await event.answer()

@bot.on(events.CallbackQuery(pattern=b'set_backup'))
async def set_backup_callback(event):
    """è®¾ç½®å¤‡ç”¨å·å›è°ƒ"""
    # è´¦å·å…³è”å¤„ç†ï¼ˆå¤‡ç”¨å·->ä¸»è´¦å·ï¼‰
    try:
        original_sender_id = event.sender_id
        event.sender_id = get_main_account_id(original_sender_id, getattr(event.sender, 'username', None))
    except:
        pass
    member = DB.get_member(event.sender_id)
    if not member:
        await event.answer('è¯·å…ˆå‘é€ /start æ³¨å†Œ')
        return

    # VIP check
    if not member.get('is_vip'):
        await send_vip_required_prompt(event)
        return
    
    # åˆ‡æ¢åˆ°å¤‡ç”¨å·è¾“å…¥æ—¶ï¼Œæ¸…ç†ç¾¤é“¾æ¥ç­‰å¾…çŠ¶æ€
    waiting_for_group_link.pop(event.sender_id, None)
    waiting_for_backup[event.sender_id] = True
    await event.respond(
        'âœï¸ è®¾ç½®å¤‡ç”¨å·\n\n'
        'è¯·å‘é€æ‚¨çš„å¤‡ç”¨é£æœºå· (ä¸å¸¦@çš„ç”¨æˆ·åæˆ–ID)\n\n'
        'å‘é€ /cancel å–æ¶ˆæ“ä½œ'
    )
    await event.answer()

@bot.on(events.CallbackQuery(pattern=b'earnings_history'))
async def earnings_history_callback(event):
    """æŸ¥çœ‹ä¸ªäººæ”¶ç›Šè®°å½•"""
    # è´¦å·å…³è”å¤„ç†ï¼ˆå¤‡ç”¨å·->ä¸»è´¦å·ï¼‰
    try:
        original_sender_id = event.sender_id
        event.sender_id = get_main_account_id(original_sender_id, getattr(event.sender, 'username', None))
    except:
        pass
    member = DB.get_member(event.sender_id)
    
    if not member:
        await event.answer("âŒ ç”¨æˆ·ä¿¡æ¯ä¸å­˜åœ¨", alert=True)
        return

    # VIP check
    if not member.get('is_vip'):
        await send_vip_required_prompt(event)
        return
    
    conn = DB.get_conn()
    c = conn.cursor()
    # æ–°è¡¨ç»“æ„ï¼šè®°å½• upgraded_user (è°è§¦å‘å‡çº§), earning_user (è°è·å¾—æ”¶ç›Š), amount, description, create_time
    c.execute('''
        SELECT upgraded_user, amount, description, create_time
        FROM earnings_records
        WHERE earning_user = ?
        ORDER BY create_time DESC
        LIMIT 50
    ''', (member["telegram_id"],))
    records = c.fetchall()
    conn.close()
    
    if not records:
        text = "ğŸ“Š æ”¶ç›Šè®°å½•\n\næš‚æ— æ”¶ç›Šè®°å½•"
        buttons = [[Button.inline('ğŸ”™ è¿”å›', b'back_to_profile')]]
    else:
        total = sum(r[1] for r in records)
        text = f"ğŸ“Š æ”¶ç›Šè®°å½•\n\n"
        text += f"ğŸ’° ç´¯è®¡æ”¶ç›Š: {total} U\n"
        text += f"ğŸ“ è®°å½•æ•°: {len(records)} æ¡\n\n"
        text += "æœ€è¿‘æ”¶ç›Šè®°å½•:\n"
        text += "â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
        
        for i, (upgraded_user, amount, desc, create_time) in enumerate(records[:20], 1):
            # å°è¯•è·å–å‡çº§è€…ç”¨æˆ·å
            try:
                upm = DB.get_member(upgraded_user) if upgraded_user else None
                up_name = f"@{upm['username']}" if upm and upm.get('username') else str(upgraded_user)
            except:
                up_name = str(upgraded_user)
            time_str = create_time[:16] if create_time else "æœªçŸ¥"
            text += f"{i}. +{amount} U â€” å‡çº§ç”¨æˆ·: {up_name}\n"
            text += f"   {desc or ''}\n"
            text += f"   {time_str}\n\n"
        
        if len(records) > 20:
            text += f"... è¿˜æœ‰ {len(records) - 20} æ¡è®°å½•\n"
        
        buttons = [[Button.inline('ğŸ”™ è¿”å›', b'back_to_profile')]]
    
    try:
        await event.edit(text, buttons=buttons)
    except:
        await event.respond(text, buttons=buttons)
    await event.answer()

@bot.on(events.CallbackQuery(pattern=b'withdraw'))
async def withdraw_callback(event):
    """æç°å›è°ƒ"""
    config = get_system_config()
    member = DB.get_member(event.sender_id)
    if not member:
        await event.answer('è¯·å…ˆå‘é€ /start æ³¨å†Œ')
        return

    if member['balance'] < config['withdraw_threshold']:
        await event.respond(
            'ğŸ’³ æç°\n\n'
            f'âŒ ä½™é¢æœªè¾¾åˆ°æç°é—¨æ§›\n\n'
            f'å½“å‰ä½™é¢: {member["balance"]} U\n'
            f'æç°é—¨æ§›: {config["withdraw_threshold"]} U\n'
            f'è¿˜éœ€: {config["withdraw_threshold"] - member["balance"]} U'
        )
    else:
        waiting_for_withdraw_amount[event.sender_id] = True
        await event.respond(
            f'ğŸ’³ æç°ç”³è¯·\n\n'
            f'å½“å‰ä½™é¢: {member["balance"]} U\n'
            f'æç°é—¨æ§›: {config["withdraw_threshold"]} U\n\n'
            f'è¯·è¾“å…¥æç°é‡‘é¢ï¼š'
        )
    await event.answer()

@bot.on(events.CallbackQuery(pattern=b'do_recharge'))
async def do_recharge_callback(event):
    """å……å€¼å›è°ƒ"""
    # è´¦å·å…³è”å¤„ç†ï¼ˆå¤‡ç”¨å·->ä¸»è´¦å·ï¼‰
    try:
        original_sender_id = event.sender_id
        event.sender_id = get_main_account_id(original_sender_id, getattr(event.sender, 'username', None))
    except:
        pass
    telegram_id = event.sender_id
    member = DB.get_member(telegram_id)
    
    if not member:
        await event.answer("âŒ ç”¨æˆ·ä¿¡æ¯ä¸å­˜åœ¨", alert=True)
        return
    
    waiting_for_recharge_amount[telegram_id] = True
    
    text = """ğŸ’° å……å€¼ä½™é¢

è¯·è¾“å…¥æ‚¨è¦å……å€¼çš„é‡‘é¢ï¼ˆUSDTï¼‰

ä¾‹å¦‚: 200

âš ï¸ æ³¨æ„:
â€¢ ä»…æ”¯æŒTRC-20ç½‘ç»œUSDT
â€¢ æœ€ä½å……å€¼é‡‘é¢: 10 USDT
â€¢ å……å€¼åè‡ªåŠ¨åˆ°è´¦"""
    
    try:
        await event.edit(text)
    except:
        await event.respond(text)
    await event.answer()

@bot.on(events.CallbackQuery(pattern=b'open_vip'))
async def open_vip_callback(event):
    """å¼€é€šVIP"""
    # è´¦å·å…³è”å¤„ç†ï¼ˆå¤‡ç”¨å·->ä¸»è´¦å·ï¼‰
    try:
        original_sender_id = event.sender_id
        event.sender_id = get_main_account_id(original_sender_id, getattr(event.sender, 'username', None))
    except:
        pass
    telegram_id = event.sender_id
    member = DB.get_member(telegram_id)
    
    if not member:
        await event.answer("âŒ ç”¨æˆ·ä¿¡æ¯ä¸å­˜åœ¨", alert=True)
        return
    
    if member.get('is_vip'):
        await event.answer("âœ… æ‚¨å·²ç»æ˜¯VIPä¼šå‘˜", alert=True)
        return
    
    config = get_system_config()
    vip_price = config.get('vip_price', 10)
    user_balance = member.get('balance', 0)
    need_recharge = vip_price - user_balance
    
    text = f"""ğŸ’ å¼€é€šVIPä¼šå‘˜

VIPä»·æ ¼: {vip_price} U
å½“å‰ä½™é¢: {user_balance} U
è¿˜éœ€å……å€¼: {need_recharge} U

å¼€é€šVIPåæ‚¨å°†è·å¾—:
âœ… æŸ¥çœ‹è£‚å˜æ•°æ®
âœ… è·å¾—ä¸‹çº§å¼€é€šVIPçš„å¥–åŠ±
âœ… åŠ å…¥ä¸Šçº§ç¾¤ç»„
âœ… æ¨å¹¿èµšé’±åŠŸèƒ½"""
    
    if user_balance >= vip_price:
        # ä½™é¢è¶³å¤Ÿï¼Œç›´æ¥å°è¯•å¼€é€šï¼ˆè·³è¿‡é¢å¤–ç¡®è®¤ï¼‰
        try:
            success, result = await process_vip_upgrade(telegram_id, vip_price, config)
            if success:
                # æ˜¾ç¤ºæˆåŠŸæç¤º
                stats = result.get('stats', {})
                new_balance = result.get('new_balance', 0)
                text = f'ğŸ‰ æ­å–œ! VIPå¼€é€šæˆåŠŸ!\n\næ‚¨ç°åœ¨å¯ä»¥ä½¿ç”¨æ‰€æœ‰VIPåŠŸèƒ½ã€‚\n\næ¶ˆè´¹: {vip_price} U\nå‰©ä½™ä½™é¢: {new_balance} U'
                try:
                    await event.edit(text)
                except:
                    await event.respond(text)
                await event.answer()
                return
            else:
                # å¦‚æœå¤„ç†å¤±è´¥ï¼Œå›é€€åˆ°å±•ç¤ºå……å€¼/ç¡®è®¤ç•Œé¢
                text += f"\n\nâŒ å¼€é€šå¤±è´¥: {result}\n"
                buttons = [[Button.inline(f'ğŸ’° å……å€¼{need_recharge}Uå¼€é€šVIP', b'recharge_for_vip')]]
        except Exception as e:
            print(f"[open_vip] ç›´æ¥å¼€é€šå¤±è´¥: {e}")
            text += f"\n\nâŒ å¼€é€šå¤±è´¥ï¼Œè¯·ç¨åé‡è¯•"
            buttons = [[Button.inline(f'ğŸ’° å……å€¼{need_recharge}Uå¼€é€šVIP', b'recharge_for_vip')]]
    else:
        # ä½™é¢ä¸è¶³ï¼Œæ˜¾ç¤ºå……å€¼æŒ‰é’®
        text += f"\n\nâŒ ä½™é¢ä¸è¶³ï¼Œè¯·å…ˆå……å€¼"
        buttons = [[Button.inline(f'ğŸ’° å……å€¼{need_recharge}Uå¼€é€šVIP', b'recharge_for_vip')]]
    
    try:
        await event.edit(text, buttons=buttons)
    except:
        await event.respond(text, buttons=buttons)
    await event.answer()

# è¿”å›ä¸ªäººä¸­å¿ƒ
@bot.on(events.CallbackQuery(pattern=b'back_to_profile'))
async def back_to_profile_callback(event):
    """è¿”å›ä¸ªäººä¸­å¿ƒ"""
    # è´¦å·å…³è”å¤„ç†ï¼ˆå¤‡ç”¨å·->ä¸»è´¦å·ï¼‰
    try:
        original_sender_id = event.sender_id
        event.sender_id = get_main_account_id(original_sender_id, getattr(event.sender, 'username', None))
    except:
        pass
    member = DB.get_member(event.sender_id)
    if not member:
        await event.answer("âŒ ç”¨æˆ·ä¿¡æ¯ä¸å­˜åœ¨", alert=True)
        return
    
    buttons = [
        [Button.inline('ğŸ”— è®¾ç½®ç¾¤é“¾æ¥', b'set_group'), Button.inline('âœï¸ è®¾ç½®å¤‡ç”¨å·', b'set_backup')],
        [Button.inline('ğŸ“Š æ”¶ç›Šè®°å½•', b'earnings_history')],
        [Button.inline('ğŸ’³ æç°', b'withdraw'), Button.inline('ğŸ’° å……å€¼', b'do_recharge'), Button.inline('ğŸ’ å¼€é€šVIP', b'open_vip')],
    ]
    
    # æ ¼å¼åŒ–å¤‡ç”¨å·æ˜¾ç¤ºï¼ˆæ˜¾ç¤ºç”¨æˆ·åè€Œä¸æ˜¯IDï¼‰
    backup_display = format_backup_account_display(member.get("backup_account"))
    
    text = (
        f'ğŸ‘¤ ä¸ªäººä¸­å¿ƒ\n\n'
        f'ğŸ†” ID: {member["telegram_id"]}\n'
        f'ğŸ‘¤ ç”¨æˆ·å: @{member["username"]}\n'
        f'ğŸ’ VIPçŠ¶æ€: {"âœ… å·²å¼€é€š" if member["is_vip"] else "âŒ æœªå¼€é€š"}\n'
        f'ğŸ’° ä½™é¢: {member["balance"]} U\n'
        f'ğŸ“‰ é”™è¿‡ä½™é¢: {member["missed_balance"]} U\n'
        f'ğŸ’µ ç´¯è®¡æ”¶ç›Š: {member.get("total_earned", 0)} U\n'
        f'ğŸ”— ç¾¤é“¾æ¥: {member["group_link"] or "æœªè®¾ç½®"}\n'
        f'ğŸ“± å¤‡ç”¨å·: {backup_display}\n'
        f'ğŸ“… æ³¨å†Œæ—¶é—´: {member["register_time"][:10] if member["register_time"] else "æœªçŸ¥"}'
    )
    
    try:
        await event.edit(text, buttons=buttons)
    except:
        await event.respond(text, buttons=buttons)
    await event.answer()

@bot.on(events.CallbackQuery(data=b'recharge_for_vip'))
async def recharge_for_vip_callback(event):
    """å……å€¼å¼€é€šVIP - è°ƒç”¨å……å€¼è¾“å…¥é‡‘é¢åŠŸèƒ½"""
    # è´¦å·å…³è”å¤„ç†ï¼ˆå¤‡ç”¨å·->ä¸»è´¦å·ï¼‰
    try:
        original_sender_id = event.sender_id
        event.sender_id = get_main_account_id(original_sender_id, getattr(event.sender, 'username', None))
    except:
        pass
    telegram_id = event.sender_id
    member = DB.get_member(telegram_id)
    
    if not member:
        await event.answer("âŒ ç”¨æˆ·ä¿¡æ¯ä¸å­˜åœ¨", alert=True)
        return
    
    # è·å–VIPä»·æ ¼ï¼Œè®¡ç®—éœ€è¦å……å€¼çš„é‡‘é¢
    config = get_system_config()
    vip_price = config.get('vip_price', 10)
    user_balance = member.get('balance', 0)
    need_recharge = vip_price - user_balance
    
    if need_recharge <= 0:
        await event.answer("âœ… ä½™é¢å……è¶³ï¼Œå¯ä»¥ç›´æ¥å¼€é€šVIP", alert=True)
        return
    
    # è°ƒç”¨å……å€¼è®¢å•åˆ›å»ºå‡½æ•°ï¼ˆä¼ å…¥botå‚æ•°ï¼‰
    try:
        from payment import create_recharge_order
        await create_recharge_order(bot, event, need_recharge, is_vip_order=True)
    except Exception as e:
        print(f"[å……å€¼VIPè®¢å•åˆ›å»ºå¤±è´¥] {e}")
        import traceback
        traceback.print_exc()
        await event.respond("âŒ åˆ›å»ºå……å€¼è®¢å•å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•")
    await event.answer()

@bot.on(events.CallbackQuery(pattern=rb'verify_groups_.*'))
async def verify_groups_callback(event):
    """éªŒè¯ç”¨æˆ·æ˜¯å¦åŠ å…¥æ‰€æœ‰éœ€è¦åŠ å…¥çš„ç¾¤ç»„ï¼ˆä¸Šçº§ç¾¤ + æ¡æ¼ç¾¤ç»„ï¼Œå…±10ä¸ªï¼‰"""
    # è´¦å·å…³è”å¤„ç†ï¼ˆå¤‡ç”¨å·->ä¸»è´¦å·ï¼‰
    try:
        original_sender_id = event.sender_id
        event.sender_id = get_main_account_id(original_sender_id, getattr(event.sender, 'username', None))
    except:
        pass
    
    telegram_id = event.sender_id
    member = DB.get_member(telegram_id)
    
    if not member:
        await event.answer("âŒ ç”¨æˆ·ä¿¡æ¯ä¸å­˜åœ¨", alert=True)
        return
    
    # ã€æ ¸å¿ƒä¿®å¤ã€‘å¦‚æœè¯¥ç”¨æˆ·å·²ç»å®Œæˆè¿‡"åŠ ç¾¤ä»»åŠ¡"ï¼Œåˆ™æ°¸ä¹…é”æ­»ï¼Œä¸å†é‡æ–°æ£€æµ‹
    if member.get('is_joined_upline'):
        await event.answer("âœ… åŠ ç¾¤ä»»åŠ¡å·²å®Œæˆï¼ˆæ°¸ä¹…é”å®šï¼‰", alert=False)
        try:
            await event.edit("âœ… **åŠ ç¾¤ä»»åŠ¡å·²å®Œæˆ**\n\nğŸ‰ æ‚¨å·²å®ŒæˆåŠ å…¥æ‰€æœ‰éœ€è¦åŠ å…¥çš„ç¾¤ç»„ï¼\n\næ‚¨ç°åœ¨å¯ä»¥è·å¾—ä¸‹çº§å¼€é€šVIPçš„åˆ†çº¢äº†ï¼")
        except:
            pass
        return
    
    await event.answer("ğŸ” æ­£åœ¨æ£€æµ‹ç¾¤ç»„åŠ å…¥æƒ…å†µï¼Œè¯·ç¨å€™...", alert=False)
    
    # ã€æ ¸å¿ƒä¿®å¤ã€‘åŠ ç¾¤ä»»åŠ¡ = å¿…é¡»åŠ å…¥1-10å±‚çš„ç¾¤ç»„ï¼ˆæ¯å±‚ï¼šæœ‰ä¸Šçº§ä¸”å®Œæˆä»»åŠ¡ç”¨ä¸Šçº§ç¾¤ï¼Œå¦åˆ™ç”¨æ¡æ¼ç¾¤ï¼‰
    config = get_system_config()
    required_groups_count = min(config.get('level_count', 10), 10)
    
    groups_to_check = []
    
    # è·å–å®Œæ•´çš„10å±‚å…³ç³»
    from core_functions import get_upline_chain
    chain = get_upline_chain(telegram_id, required_groups_count)
    
    # è·å–æ‰€æœ‰æ¡æ¼ç¾¤ç»„
    fb_groups = get_fallback_resource('group')
    if not fb_groups:
        await event.respond("âŒ ç³»ç»Ÿé”™è¯¯ï¼šæ¡æ¼ç¾¤ç»„æœªé…ç½®ï¼Œè¯·è”ç³»ç®¡ç†å‘˜")
        return
    
    # æ„å»ºå±‚çº§æ˜ å°„ï¼šlevel -> ä¸Šçº§ä¿¡æ¯ï¼ˆå¦‚æœå­˜åœ¨ä¸”å®Œæˆä»»åŠ¡ï¼‰
    upline_map = {}
    for item in chain:
        if item.get('is_fallback'):
            continue
        level = item['level']
        upline_id = item['id']
        up_member = DB.get_member(upline_id)
        if up_member and up_member.get('group_link'):
            # æ£€æŸ¥ä¸Šçº§æ˜¯å¦å®Œæˆä»»åŠ¡
            try:
                conds = await check_user_conditions(bot, upline_id)
                if conds and conds['all_conditions_met']:
                    group_links = up_member.get('group_link', '').split('\n')
                    for link in group_links:
                        link = link.strip()
                        if link:
                            upline_map[level] = {
                                'link': link,
                                'upline_id': upline_id
                            }
                            break
            except Exception as e:
                print(f"[éªŒè¯åŠ ç¾¤] æ£€æŸ¥ç¬¬{level}å±‚ä¸Šçº§æ¡ä»¶å¤±è´¥: {e}")
    
    # æ„å»ºéœ€è¦æ£€æŸ¥çš„ç¾¤ç»„åˆ—è¡¨ï¼ˆæŒ‰æ˜¾ç¤ºé¡ºåºï¼Œé‡‡ç”¨ä¸ fission_handler ç›¸åŒçš„ä»åå‘å‰æ›¿æ¢ç­–ç•¥ï¼‰
    groups_to_check = [None] * required_groups_count

    # å…ˆæŠŠçœŸå®ä¸Šçº§æ”¾åˆ°å¯¹åº”æ˜¾ç¤ºä½ç½®ï¼ˆä¸Š1çº§ -> æœ€åä¸€ä¸ªä½ç½®ï¼‰
    for level, info in upline_map.items():
        try:
            pos = required_groups_count - level
            if pos < 0 or pos >= required_groups_count:
                continue
            groups_to_check[pos] = {
                'display_index': pos + 1,
                'link': info['link'],
                'level': level,
                'type': 'upline',
                'group_name': f"ç¬¬{level}å±‚ä¸Šçº§",
                'upline_id': info.get('upline_id')
            }
        except Exception as e:
            print(f"[éªŒè¯åŠ ç¾¤] æ„å»ºä¸Šçº§æ˜ å°„å¤±è´¥: {e}")

    # è¡¥å…¨ç©ºä½ä¸ºæ¡æ¼ç¾¤ç»„
    for display_pos in range(required_groups_count):
        if groups_to_check[display_pos] is None:
            # å¯¹åº”çš„å±‚çº§ï¼ˆåå‘æ˜ å°„ï¼‰
            level_for_slot = required_groups_count - display_pos
            fb_index = (level_for_slot - 1) % len(fb_groups)
            fb_group = fb_groups[fb_index]
            group_link = fb_group.get('link', '').strip()
            if group_link:
                groups_to_check[display_pos] = {
                    'display_index': display_pos + 1,
                    'link': group_link,
                    'level': level_for_slot,
                    'type': 'fallback',
                    'username': fb_group.get('username', ''),
                    'group_name': fb_group.get('name', '')
                }
    
    # è¿‡æ»¤ç©º
    groups_to_check = [g for g in groups_to_check if g is not None]
    if not groups_to_check:
        await event.respond("âŒ æ²¡æœ‰å¯éªŒè¯çš„ç¾¤ç»„")
        return
    
    # å»é‡ç¾¤ç»„ï¼ˆæŒ‰ link ä¿æŒé¡ºåºï¼‰ï¼Œæ£€æµ‹ç”¨æˆ·æ˜¯å¦åœ¨ç¾¤ç»„ä¸­
    seen_links = set()
    dedup_groups = []
    for g in groups_to_check:
        link = g.get('link') or ''
        if link and link not in seen_links:
            dedup_groups.append(g)
            seen_links.add(link)

    not_joined = []
    joined = []
    
    for group_info in dedup_groups:
        group_link = group_info['link']
        print(f"[verify_groups] æ£€æŸ¥ç¾¤: display_index={group_info.get('display_index')} level={group_info.get('level')} link={group_link}")
        try:
            # æå–ç¾¤ç»„ç”¨æˆ·åæˆ–ID
            if 't.me/' in group_link:
                group_username = group_link.split('t.me/')[-1].split('/')[0].split('?')[0].replace('+', '')
            elif group_link.startswith('@'):
                group_username = group_link[1:]
            else:
                group_username = group_link
                
            # è·³è¿‡ç§æœ‰ç¾¤é“¾æ¥ï¼ˆæ— æ³•é€šè¿‡ç”¨æˆ·åæ£€æŸ¥æˆå‘˜ï¼‰
            if group_username.startswith('+'):
                not_joined.append(group_info)
                continue
            
            # å°è¯•è·å–ç¾¤ç»„å®ä½“
            try:
                group_entity = await bot.get_entity(group_username)
                
                # è®°å½•æ›´å‹å¥½çš„ç¾¤åç§°ï¼Œæ–¹ä¾¿åé¢å±•ç¤ºï¼ˆä¼˜å…ˆä½¿ç”¨å®é™…ç¾¤ç»„åç§°ï¼‰
                try:
                    title = getattr(group_entity, 'title', None)
                    if title:
                        group_info['group_name'] = title
                except Exception:
                    pass
                
                # æ£€æŸ¥ç”¨æˆ·æ˜¯å¦åœ¨ç¾¤ç»„ä¸­
                try:
                    from telethon.tl.functions.channels import GetParticipantRequest
                    participant = await bot(GetParticipantRequest(
                        channel=group_entity,
                        participant=telegram_id
                    ))
                    joined.append(group_info)
                    print(f"[verify_groups] å·²æ£€æµ‹åˆ°ç”¨æˆ·åŠ å…¥: {group_username}")
                except Exception as part_err:
                    not_joined.append(group_info)
                    print(f"[verify_groups] ç”¨æˆ·æœªåŠ å…¥: {group_username} ({part_err})")
            except Exception as e:
                # æ— æ³•è·å–ç¾¤ç»„ä¿¡æ¯ï¼Œå¯èƒ½æ˜¯ç§æœ‰ç¾¤æˆ–é“¾æ¥æ— æ•ˆ
                not_joined.append(group_info)
                print(f"[verify_groups] è·å–ç¾¤ä¿¡æ¯å¤±è´¥: {group_link} ({e})")
        except Exception as e:
            not_joined.append(group_info)
            print(f"[verify_groups] å†…éƒ¨å¼‚å¸¸: {e}")
    
    # æ„å»ºç»“æœæ¶ˆæ¯
    total_groups = len(dedup_groups)
    joined_count = len(joined)
    not_joined_count = max(total_groups - joined_count, 0)
    print(f"[verify_groups] ç»Ÿè®¡: total_groups={total_groups}, joined_count={joined_count}, not_joined_count={not_joined_count}")
    
    # ã€æ ¸å¿ƒä¿®å¤ã€‘æ›´æ–°æ•°æ®åº“ä¸­çš„ is_joined_upline æ ‡å¿—ï¼ˆæ°¸ä¹…é”æ­»ï¼‰
    # å¿…é¡»å…¨éƒ¨10ä¸ªç¾¤ç»„éƒ½åŠ å…¥æ‰ç®—å®Œæˆï¼Œä¸€æ—¦å®Œæˆæ°¸ä¹…é”æ­»
    is_completed = False
    try:
        # å¿…é¡»å…¨éƒ¨åŠ å…¥æ‰ç®—å®Œæˆ
        if total_groups == required_groups_count and joined_count == total_groups and not member.get('is_joined_upline'):
            DB.update_member(telegram_id, is_joined_upline=1)
            is_completed = True
            print(f"[éªŒè¯åŠ ç¾¤] ç”¨æˆ· {telegram_id} å·²å®ŒæˆåŠ ç¾¤ä»»åŠ¡ï¼ŒçŠ¶æ€å·²æ°¸ä¹…é”å®š")
        elif member.get('is_joined_upline'):
            # å¦‚æœå·²ç»å®Œæˆè¿‡ï¼Œç›´æ¥æ ‡è®°ä¸ºå®Œæˆï¼ˆæ°¸ä¹…é”æ­»ï¼‰
            is_completed = True
    except Exception as e:
        print(f"[verify_groups] æ›´æ–° is_joined_upline å¤±è´¥: {e}")
    
    # æ„å»ºç»“æœæ¶ˆæ¯ - å§‹ç»ˆæ˜¾ç¤ºç»Ÿè®¡ä¿¡æ¯
    text = f"ğŸ” **ç¾¤ç»„åŠ å…¥éªŒè¯ç»“æœ**\n\n"
    text += f"ğŸ“Š **æ€»è®¡**: {total_groups} ä¸ªç¾¤ç»„\n"
    text += f"âœ… **å·²åŠ å…¥**: {joined_count} ä¸ª\n"
    text += f"âŒ **æœªåŠ å…¥**: {not_joined_count} ä¸ª\n\n"
    
    # å¦‚æœå·²å®Œæˆï¼Œæ˜¾ç¤ºå®Œæˆæç¤º
    if is_completed:
        text += "ğŸ‰ **æ­å–œï¼æ‚¨å·²åŠ å…¥æ‰€æœ‰éœ€è¦åŠ å…¥çš„ç¾¤ç»„ï¼**\n\n"
        text += "âœ… æ‚¨ç°åœ¨å¯ä»¥è·å¾—ä¸‹çº§å¼€é€šVIPçš„åˆ†çº¢äº†ï¼\n\n"
        if joined:
            text += "**å·²åŠ å…¥çš„ç¾¤ç»„åˆ—è¡¨ï¼š**\n"
            for g in joined:
                group_name = g.get('group_name') or (g['link'].split('t.me/')[-1].split('/')[0] if 't.me/' in g['link'] else g['link'])
                idx = g.get('display_index', g.get('level', '?'))
                text += f"  âœ… {idx}. {group_name}\n"
    else:
        # æœªå®Œæˆæ—¶ï¼Œæ˜¾ç¤ºè¯¦ç»†æ£€æµ‹ç»“æœ
        if joined:
            text += f"âœ… **å·²åŠ å…¥çš„ç¾¤ç»„** ({joined_count}ä¸ª):\n"
            for g in joined:
                group_name = g.get('group_name') or (g['link'].split('t.me/')[-1].split('/')[0] if 't.me/' in g['link'] else g['link'])
                idx = g.get('display_index', g.get('level', '?'))
                text += f"  âœ… {idx}. {group_name}\n"
            text += "\n"
        
        if not_joined:
            text += f"âŒ **æœªåŠ å…¥çš„ç¾¤ç»„** ({not_joined_count}ä¸ªï¼Œè¯·ç‚¹å‡»åŠ å…¥):\n"
            for g in not_joined:
                group_name = g.get('group_name') or (g['link'].split('t.me/')[-1].split('/')[0] if 't.me/' in g['link'] else g['link'])
                idx = g.get('display_index', g.get('level', '?'))
                link = g['link']
                # ç¡®ä¿é“¾æ¥æ ¼å¼æ­£ç¡®ï¼Œé¿å…Markdownè§£æé”™è¯¯
                if link and (link.startswith('http://') or link.startswith('https://') or link.startswith('@')):
                    # å¯¹é“¾æ¥ä¸­çš„ç‰¹æ®Šå­—ç¬¦è¿›è¡Œè½¬ä¹‰
                    safe_link = link.replace('(', '\\(').replace(')', '\\)')
                    text += f"  âŒ {idx}. [{group_name}]({safe_link})\n"
                else:
                    # å¦‚æœé“¾æ¥æ ¼å¼ä¸æ­£ç¡®ï¼Œåªæ˜¾ç¤ºåç§°ä¸åŠ é“¾æ¥
                    text += f"  âŒ {idx}. {group_name}\n"
            text += "\nâš ï¸ **é‡è¦æç¤º**ï¼šè¯·åŠ å…¥ä»¥ä¸ŠæœªåŠ å…¥çš„ç¾¤ç»„ï¼Œæ‰èƒ½è·å¾—åˆ†çº¢ï¼"
    
    try:
        await event.edit(text, parse_mode='markdown')
    except Exception as e:
        print(f"[verify_groups] editå¤±è´¥ï¼Œå°è¯•respond: {e}")
        try:
            await event.respond(text, parse_mode='markdown')
        except Exception as e2:
            print(f"[verify_groups] respondä¹Ÿå¤±è´¥: {e2}")
            # å¦‚æœMarkdownä¹Ÿå¤±è´¥ï¼Œå°è¯•ä¸ä½¿ç”¨Markdown
            try:
                plain_text = text.replace('[', '').replace(']', '').replace('(', '').replace(')', '').replace('*', '').replace('_', '')
                await event.respond(plain_text)
            except Exception as e3:
                print(f"[verify_groups] æ‰€æœ‰å‘é€æ–¹å¼éƒ½å¤±è´¥: {e3}")
                await event.answer("éªŒè¯å®Œæˆï¼Œä½†æ˜¾ç¤ºç»“æœæ—¶å‡ºç°é”™è¯¯", alert=True)

@bot.on(events.NewMessage(pattern='/bind_group'))
async def bind_group_cmd(event):
    """ç»‘å®šç¾¤ç»„å‘½ä»¤"""
    try:
        original_sender_id = event.sender_id
        event.sender_id = get_main_account_id(original_sender_id, getattr(event.sender, 'username', None))
    except:
        pass
    await handle_bind_group(event, bot, DB)

@bot.on(events.NewMessage(pattern='/join_upline'))
async def join_upline_cmd(event):
    """åŠ å…¥ä¸Šå±‚ç¾¤å‘½ä»¤"""
    try:
        original_sender_id = event.sender_id
        event.sender_id = get_main_account_id(original_sender_id, getattr(event.sender, 'username', None))
    except:
        pass
    await handle_join_upline(event, bot, DB, get_system_config)

@bot.on(events.NewMessage(pattern='/check_status'))
async def check_status_cmd(event):
    """æ£€æŸ¥çŠ¶æ€å‘½ä»¤"""
    try:
        original_sender_id = event.sender_id
        event.sender_id = get_main_account_id(original_sender_id, getattr(event.sender, 'username', None))
    except:
        pass
    await handle_check_status(event, bot, DB)

@bot.on(events.NewMessage(pattern='/my_team'))
async def my_team_cmd(event):
    """æˆ‘çš„å›¢é˜Ÿå‘½ä»¤"""
    try:
        original_sender_id = event.sender_id
        event.sender_id = get_main_account_id(original_sender_id, getattr(event.sender, 'username', None))
    except:
        pass
    await handle_my_team(event, bot, DB)

# ==================== å…¶ä»–äº‹ä»¶å¤„ç†å™¨ ====================

@bot.on(events.NewMessage(pattern=BTN_VIEW_FISSION))
async def view_fission_handler(event):
    """æŸ¥çœ‹è£‚å˜æ•°æ®"""
    try:
        original_sender_id = event.sender_id
        event.sender_id = get_main_account_id(original_sender_id, getattr(event.sender, 'username', None))
    except:
        pass
    
    config = get_system_config()
    member = DB.get_member(event.sender_id)
    if not member:
        await event.respond('è¯·å…ˆå‘é€ /start æ³¨å†Œ')
        return

    if not member['is_vip']:
        # ä½¿ç”¨ç»Ÿä¸€çš„å¡ç‰‡å¼æç¤ºï¼ˆè´´è¿‘æ‚¨æä¾›çš„å›¾ç‰‡æ–‡æ¡ˆï¼Œåšäº†è¯­è¨€é€šé¡ºä¼˜åŒ–ï¼‰
        await send_vip_required_prompt(event)
        return

    conn = get_db_conn()
    c = conn.cursor()

    text = 'ğŸ“Š æˆ‘çš„è£‚å˜æ•°æ®\n'
    text += 'â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n'

    total_members = 0
    total_vip = 0
    buttons = []

    # è·å–å„çº§ä¸‹çº§ç”¨æˆ·å¹¶ç”ŸæˆæŒ‰é’®ï¼ˆå›ºå®š10å±‚ï¼Œä»ç¬¬10å±‚åˆ°ç¬¬1å±‚ï¼‰
    level_counts = {}  # å­˜å‚¨æ¯ä¸€å±‚çš„äººæ•°

    # è®¡ç®—æ¯ä¸€å±‚çš„ä¸‹çº§äººæ•°
    current_level_users = [member['telegram_id']]  # ä»è‡ªå·±å¼€å§‹

    for level in range(1, 11):  # å›ºå®šè®¡ç®—10å±‚
        if not current_level_users:
            # å¦‚æœä¸Šä¸€å±‚æ²¡æœ‰ç”¨æˆ·ï¼Œè¿™ä¸€å±‚è‚¯å®šä¹Ÿæ˜¯0
            level_counts[level] = 0
            continue

        # æŸ¥è¯¢å½“å‰å±‚çº§çš„ä¸‹çº§ç”¨æˆ·
        placeholders = ','.join(['?' for _ in current_level_users])
        c.execute(f"""
            SELECT telegram_id FROM members WHERE referrer_id IN ({placeholders})
        """, current_level_users)

        next_level_users = [row[0] for row in c.fetchall()]
        level_count = len(next_level_users)

        level_counts[level] = level_count
        total_members += level_count

        # è®¡ç®—VIPæ•°é‡
        if next_level_users:
            placeholders = ','.join(['?' for _ in next_level_users])
            c.execute(f"""
                SELECT COUNT(*) FROM members WHERE telegram_id IN ({placeholders}) AND is_vip = 1
            """, next_level_users)
            level_vip = c.fetchone()[0]
        else:
            level_vip = 0

        total_vip += level_vip

        # ä¸ºä¸‹ä¸€å±‚å¾ªç¯å‡†å¤‡æ•°æ®
        current_level_users = next_level_users

    # ç”ŸæˆæŒ‰é’®ï¼ˆä»ç¬¬10å±‚åˆ°ç¬¬1å±‚å€’åºæ˜¾ç¤ºï¼‰
    for level in range(10, 0, -1):
        level_count = level_counts.get(level, 0)
        btn_text = f'ç¬¬{level}å±‚: {level_count}äºº'
        buttons.append([Button.inline(btn_text, f'flv_{level}_1'.encode())])

    conn.close()

    text += f'â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n'
    text += f'ğŸ“ˆ å›¢é˜Ÿæ€»è®¡ï¼š{total_members}äºº\n'
    text += f'ğŸ’ VIPä¼šå‘˜ï¼š{total_vip}äºº\n'

    buttons.append([Button.inline('ğŸ  ä¸»èœå•', b'fission_main_menu')])

    await event.respond(text, buttons=buttons)
    # é˜»æ­¢äº‹ä»¶ç»§ç»­ä¼ æ’­ï¼Œé¿å…è¢«å…¶ä»–å¤„ç†å™¨é‡å¤å¤„ç†
    event.stop_propagation()


@bot.on(events.CallbackQuery(pattern=rb'flv_(\d+)_(\d+)'))
async def flv_level_callback(event):
    """æŸ¥çœ‹æŒ‡å®šå±‚çš„ä¸‹çº§æˆå‘˜åˆ—è¡¨ï¼šflv_{level}_{page}"""
    try:
        import re
        m = re.match(rb'flv_(\d+)_(\d+)', event.data)
        if not m:
            await event.answer('å‚æ•°é”™è¯¯', alert=True)
            return
        level = int(m.group(1))
        page = int(m.group(2))
        if page < 1:
            page = 1

        telegram_id = get_main_account_id(event.sender_id, getattr(event.sender, 'username', None))
        conn = get_db_conn()
        c = conn.cursor()

        # é€å±‚æŸ¥æ‰¾ä¸‹çº§ï¼šä»å½“å‰ç”¨æˆ·å¼€å§‹ï¼Œå¾ªç¯ level æ¬¡
        current_ids = [telegram_id]
        for _ in range(level):
            if not current_ids:
                break
            placeholders = ','.join(['?'] * len(current_ids))
            c.execute(f"SELECT telegram_id FROM members WHERE referrer_id IN ({placeholders})", current_ids)
            rows = c.fetchall()
            current_ids = [r[0] for r in rows]

        members = []
        if current_ids:
            placeholders = ','.join(['?'] * len(current_ids))
            c.execute(f"SELECT telegram_id, username, is_vip FROM members WHERE telegram_id IN ({placeholders}) ORDER BY id DESC", current_ids)
            rows = c.fetchall()
            for r in rows:
                members.append({'telegram_id': r[0], 'username': r[1] or '', 'is_vip': bool(r[2])})

        conn.close()

        per_page = 15
        total = len(members)
        pages = (total + per_page - 1) // per_page if total > 0 else 1
        page = max(1, min(page, pages if pages > 0 else 1))
        start = (page - 1) * per_page
        end = start + per_page
        page_items = members[start:end]

        if not page_items:
            await event.answer(f'ç¬¬{level}å±‚æš‚æ— æˆå‘˜', alert=True)
            return

        text = f'ğŸ“‹ ç¬¬{level}å±‚æˆå‘˜ï¼ˆç¬¬{page}/{pages}é¡µï¼‰\n\n'
        for idx, m in enumerate(page_items, start + 1):
            name_display = f'@{m["username"]}' if m['username'] else str(m['telegram_id'])
            vip_tag = ' VIP' if m['is_vip'] else ''
            text += f'{idx}. {name_display} {vip_tag}\n'

        # æ„å»ºåˆ†é¡µå’Œè¿”å›æŒ‰é’®ï¼ˆä¸åœ¨ä¸‹é¢æ˜¾ç¤ºæ¯ä¸ªæˆå‘˜çš„è·³è½¬æŒ‰é’®ï¼‰
        btns = []
        nav = []
        if page > 1:
            nav.append(Button.inline('â¬…ï¸ ä¸Šé¡µ', f'flv_{level}_{page-1}'.encode()))
        if page < pages:
            nav.append(Button.inline('ä¸‹é¡µ â¡ï¸', f'flv_{level}_{page+1}'.encode()))
        if nav:
            btns.append(nav)
        btns.append([Button.inline('ğŸ”™ è¿”å›', b'fission_main_menu')])

        try:
            await event.edit(text, buttons=btns)
        except:
            await event.respond(text, buttons=btns)
    except Exception as e:
        print(f"[flv_callback] é”™è¯¯: {e}")
        await event.answer('åŠ è½½å¤±è´¥', alert=True)


@bot.on(events.CallbackQuery(pattern=b'fission_main_menu'))
async def fission_main_menu_callback(event):
    """è¿”å›ä¸»èœå•"""
    try:
        # è·å–ç”¨æˆ·ä¿¡æ¯
        telegram_id = get_main_account_id(event.sender_id, getattr(event.sender, 'username', None))
        member = DB.get_member(telegram_id)

        if not member:
            await event.answer("âŒ ç”¨æˆ·ä¿¡æ¯ä¸å­˜åœ¨", alert=True)
            return

        # ç”Ÿæˆä¸»èœå•å†…å®¹ï¼ˆä¸start_handlerç›¸åŒï¼‰
        sys_config = get_system_config()
        pinned_ad = sys_config.get('pinned_ad', '')

        welcome_text = (
            f'ğŸ‘‹ æ¬¢è¿ä½¿ç”¨è£‚å˜æ¨å¹¿æœºå™¨äºº!\n\n'
            f'ğŸ‘¤ å½“å‰æ˜¾ç¤ºèº«ä»½ID: `{telegram_id}`\n'
            f'ğŸ’ VIPçŠ¶æ€: {"âœ… å·²å¼€é€š" if member["is_vip"] else "âŒ æœªå¼€é€š"}\n'
            f'ğŸ’° ä½™é¢: {member["balance"]} U\n\n'
            f'è¯·é€‰æ‹©åŠŸèƒ½:'
        )

        if pinned_ad:
            welcome_text += f'\n\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\nğŸ“¢ {pinned_ad}'

        # ç¼–è¾‘å½“å‰æ¶ˆæ¯ä¸ºæ–°çš„ä¸»èœå•å†…å®¹
        await event.edit(welcome_text, buttons=get_main_keyboard(telegram_id))

    except Exception as e:
        print(f"[fission_main_menu] é”™è¯¯: {e}")
        await event.answer('è¿”å›å¤±è´¥', alert=True)


@bot.on(events.CallbackQuery(pattern=b'back_handler'))
async def back_handler_callback(event):
    """Callback ç‰ˆæœ¬çš„è¿”å›ä¸»èœå•"""
    await event.delete()
    # è§¦å‘ /start æ•ˆæœæˆ–å‘é€ä¸»èœå•
    await start_handler(event)


@bot.on(events.NewMessage(pattern=BTN_PROMOTE))
async def promote_handler(event):
    """èµšé’±æ¨å¹¿"""
    try:
        original_sender_id = event.sender_id
        event.sender_id = get_main_account_id(original_sender_id, getattr(event.sender, 'username', None))
    except:
        pass
    
    config = get_system_config()
    member = DB.get_member(event.sender_id)
    if not member:
        await event.respond('è¯·å…ˆå‘é€ /start æ³¨å†Œ')
        return
    
    # æœªå¼€é€š VIPï¼Œç¦æ­¢ä½¿ç”¨æ¨å¹¿åŠŸèƒ½ï¼ˆç»Ÿä¸€å¡ç‰‡æç¤ºï¼‰
    if not member['is_vip']:
        await send_vip_required_prompt(event)
        return
    
    # æœªå®Œæˆä¸Šçº§åŠ ç¾¤ä»»åŠ¡
    if not member.get('is_joined_upline', 0):
        await event.respond(
            "æŠ±æ­‰ï¼Œæ‚¨è¿˜æ²¡åŠ å…¥ä¸Šçº§ç¾¤ï¼Œä¸èƒ½ä½¿ç”¨æ­¤åŠŸèƒ½\n\n"
            "è¯·å…ˆæŒ‰ç…§è¦æ±‚åŠ å…¥ 10 çº§å…± 10 ä¸ªä¸Šçº§ç¾¤ï¼Œ\n"
            "å®Œæˆåå†å›æ¥ä½¿ç”¨æ¨å¹¿åŠŸèƒ½ã€‚",
            buttons=[[Button.inline('ğŸ” éªŒè¯æœªåŠ ç¾¤', f'verify_groups_{event.sender_id}'.encode())]]
        )
        return
    
    # æœªç»‘å®šè‡ªå·±ç¾¤
    if not member.get('group_link'):
        await event.respond(
            "æŠ±æ­‰ï¼Œæ‚¨è¿˜æ²¡æœ‰ç»‘å®šè‡ªå·±çš„ç¾¤ï¼Œä¸èƒ½ä½¿ç”¨æ­¤åŠŸèƒ½\n\n"
            "è¯·å…ˆç»‘å®šè‡ªå·±çš„ç¾¤ï¼Œå¹¶ç¡®ä¿å·²å°†æœºå™¨äººæ‹‰å…¥ç¾¤å¹¶è®¾ç½®ä¸ºç®¡ç†å‘˜ã€‚",
            buttons=[[Button.inline('ğŸ”— ç»‘å®šæˆ‘çš„ç¾¤', b'set_group')]]
        )
        return
    
    # ç”Ÿæˆæ¨å¹¿é“¾æ¥
    bot_info = await bot.get_me()
    invite_link = f'https://t.me/{bot_info.username}?start={event.sender_id}'
    
    text = f'ğŸ’° èµšé’±æ¨å¹¿\n\n'
    text += f'æ‚¨çš„ä¸“å±æ¨å¹¿é“¾æ¥:\n{invite_link}\n\n'
    text += f'ğŸ“Š æ¨å¹¿è§„åˆ™:\n'
    text += f'â€¢ æ¯æœ‰ä¸€äººé€šè¿‡æ‚¨çš„é“¾æ¥å¼€é€šVIP\n'
    text += f'â€¢ æ‚¨å°†è·å¾— {config["level_reward"]} U å¥–åŠ±\n'
    text += f'â€¢ æœ€å¤šå¯è·å¾— {config["level_count"]} å±‚ä¸‹çº§å¥–åŠ±\n\n'
    text += f'ğŸ’¡ åˆ†äº«æ­¤é“¾æ¥ç»™å¥½å‹å³å¯å¼€å§‹èµšé’±!'
    
    await event.respond(text, buttons=[[Button.inline('ğŸ“¤ åˆ†äº«æ¨å¹¿', b'share_promote')]])

@bot.on(events.NewMessage(pattern=BTN_RESOURCES))
async def resources_handler(event):
    """è¡Œä¸šèµ„æº"""
    try:
        original_sender_id = event.sender_id
        event.sender_id = get_main_account_id(original_sender_id, getattr(event.sender, 'username', None))
    except:
        pass
    await show_resource_categories(event, page=1, is_new=True)

async def show_resource_categories(event, page=1, is_new=False):
    """æ˜¾ç¤ºèµ„æºåˆ†ç±»ï¼ˆæ–‡æœ¬åˆ—è¡¨ï¼Œåˆ†é¡µï¼Œæ¯é¡µ25æ¡ï¼‰"""
    categories = DB.get_resource_categories(0)

    if not categories:
        msg = 'ğŸ“ è¡Œä¸šèµ„æº\n\næš‚æ— èµ„æºåˆ†ç±»'
        if is_new:
            await event.respond(msg)
        else:
            await event.edit(msg)
        return

    # æ–‡æœ¬åˆ—è¡¨åˆ†é¡µï¼šæ¯é¡µ25ä¸ªåˆ†ç±»ï¼ˆé€‚åˆæ˜¾ç¤ºä¸ºåˆ—è¡¨ï¼‰
    per_page = 25
    total = len(categories)
    total_pages = (total + per_page - 1) // per_page
    page = max(1, min(page, total_pages))

    start = (page - 1) * per_page
    end = start + per_page
    page_categories = categories[start:end]

    # æ„å»ºæ–‡æœ¬åˆ—è¡¨ï¼ˆç¼–å· + åç§°ï¼‰ï¼Œä¸‹æ–¹æ”¾æŒ‰é’®ï¼ˆæ¯è¡Œ3ä¸ªï¼‰ç”¨äºè¿›å…¥åˆ†ç±»èµ„æº
    text_lines = [f'ğŸ“ è¡Œä¸šèµ„æº\n\nå…± {total} ä¸ªåˆ†ç±» ï¼ˆç¬¬ {page}/{total_pages} é¡µï¼‰\n']
    buttons = []
    for idx, cat in enumerate(page_categories, start + 1):
        text_lines.append(f'{idx}. {cat["name"]}')

    # æ¯è¡Œ3ä¸ªæŒ‰é’®æ’åˆ—
    current_row = []
    for cat in page_categories:
        current_row.append(Button.inline(cat["name"], f'cat_{cat["id"]}'.encode()))
        if len(current_row) == 3:
            buttons.append(current_row)
            current_row = []
    # å¤„ç†å‰©ä½™çš„æŒ‰é’®
    if current_row:
        buttons.append(current_row)

    # åˆ†é¡µæ§åˆ¶æŒ‰é’®
    nav = []
    if page > 1:
        nav.append(Button.inline('< ä¸Šä¸€é¡µ', f'catpg_{page-1}'.encode()))
    if page < total_pages:
        nav.append(Button.inline('ä¸‹ä¸€é¡µ >', f'catpg_{page+1}'.encode()))
    if nav:
        buttons.append(nav)

    buttons.append([Button.inline('< è¿”å›', b'res_back_main')])

    text = '\n'.join(text_lines)
    try:
        if is_new:
            await event.respond(text, buttons=buttons, parse_mode='markdown')
        else:
            await event.edit(text, buttons=buttons, parse_mode='markdown')
    except:
        # fallback without buttons
        if is_new:
            await event.respond(text)
        else:
            await event.edit(text)


# ç‚¹å‡»åˆ†ç±»å›è°ƒï¼šæ˜¾ç¤ºè¯¥åˆ†ç±»ä¸‹çš„èµ„æº
@bot.on(events.CallbackQuery(pattern=rb'cat_(\d+)'))
async def category_callback(event):
    try:
        data = event.data.decode()
        cid = int(data.replace('cat_', ''))
        # ä½¿ç”¨DB.get_resourcesè¿›è¡Œåˆ†é¡µè¯»å–
        per_page = 25
        page = 1
        result = DB.get_resources(cid, page=page, per_page=per_page)

        items = result.get('items', [])
        total = result.get('total', 0)
        pages = result.get('pages', 1)

        if not items:
            await event.answer('è¯¥åˆ†ç±»æš‚æ— èµ„æº', alert=True)
            return

        def fmt_count(n):
            try:
                n = int(n)
            except:
                return str(n)
            if n >= 1000:
                v = round(n / 1000.0, 1)
                if v.is_integer():
                    return f'{int(v)}K'
                return f'{v}K'
            return str(n)

        # æ„å»ºæ–‡æœ¬åˆ—è¡¨ï¼ˆæ¯è¡ŒåŒ…å«å›¾æ ‡ã€åç§°ã€äººæ•°å’Œé“¾æ¥ï¼‰
        text_lines = [f'ğŸ“‚ èµ„æºåˆ—è¡¨ï¼ˆåˆ†ç±»ID: {cid}ï¼‰\nå…± {total} æ¡ï¼Œæ˜¾ç¤ºç¬¬ {page}/{pages} é¡µ\n']
        for it in items:
            icon = 'ğŸ‘¥' if (it.get('type') or '').lower() == 'group' else 'ğŸ“£'
            name = it.get('name') or 'æœªå‘½å'
            link = it.get('link') or ''
            count_str = fmt_count(it.get('count') or 0)
            # å®‰å…¨è½¬ä¹‰ä¸­æ‹¬å·å’Œåœ†æ‹¬å· in markdown link text
            safe_name = name.replace('[','\\[').replace(']','\\]').replace('(','\\(').replace(')','\\)')
            if link:
                text_lines.append(f'{icon} [{safe_name}]({link}) {count_str}')
            else:
                text_lines.append(f'{icon} {safe_name} {count_str}')

        text = '\n'.join(text_lines)

        # æ„å»ºåˆ†é¡µæŒ‰é’®
        btns = []
        nav = []
        if page > 1:
            nav.append(Button.inline('< ä¸Šä¸€é¡µ', f'res_page_{cid}_{page-1}'.encode()))
        if page < pages:
            nav.append(Button.inline('ä¸‹ä¸€é¡µ >', f'res_page_{cid}_{page+1}'.encode()))
        if nav:
            btns.append(nav)
        btns.append([Button.inline('ğŸ”™ è¿”å›åˆ†ç±»', b'back_to_categories')])

        try:
            await event.edit(text, buttons=btns, parse_mode='markdown')
        except:
            await event.respond(text, buttons=btns, parse_mode='markdown')
    except Exception as e:
        print(f"[category_callback] é”™è¯¯: {e}")
        await event.answer('åŠ è½½å¤±è´¥', alert=True)


@bot.on(events.CallbackQuery(pattern=rb'back_to_categories'))
async def back_to_categories_callback(event):
    """è¿”å›åˆ†ç±»åˆ—è¡¨ï¼ˆåŒ show_resource_categories ç¬¬1é¡µï¼‰"""
    try:
        await show_resource_categories(event, page=1, is_new=False)
        await event.answer()
    except Exception as e:
        print(f"[back_to_categories] é”™è¯¯: {e}")
        await event.answer('è¿”å›å¤±è´¥', alert=True)


@bot.on(events.CallbackQuery(pattern=rb'res_page_(\d+)_(\d+)'))
async def resource_page_callback(event):
    """åˆ†é¡µèµ„æºæ˜¾ç¤ºï¼šres_page_{category_id}_{page}"""
    try:
        data = event.data.decode()
        parts = data.replace('res_page_', '').split('_')
        cid = int(parts[0])
        page = int(parts[1])
        per_page = 25
        result = DB.get_resources(cid, page=page, per_page=per_page)
        items = result.get('items', [])
        total = result.get('total', 0)
        pages = result.get('pages', 1)

        if not items:
            await event.answer('è¯¥é¡µæš‚æ— èµ„æº', alert=True)
            return

        def fmt_count(n):
            try:
                n = int(n)
            except:
                return str(n)
            if n >= 1000:
                v = round(n / 1000.0, 1)
                if v.is_integer():
                    return f'{int(v)}K'
                return f'{v}K'
            return str(n)

        text_lines = [f'ğŸ“‚ èµ„æºåˆ—è¡¨ï¼ˆåˆ†ç±»ID: {cid}ï¼‰\nå…± {total} æ¡ï¼Œæ˜¾ç¤ºç¬¬ {page}/{pages} é¡µ\n']
        for it in items:
            icon = 'ğŸ‘¥' if (it.get('type') or '').lower() == 'group' else 'ğŸ“£'
            name = it.get('name') or 'æœªå‘½å'
            link = it.get('link') or ''
            count_str = fmt_count(it.get('count') or 0)
            safe_name = name.replace('[','\\[').replace(']','\\]').replace('(','\\(').replace(')','\\)')
            if link:
                text_lines.append(f'{icon} [{safe_name} ({count_str})]({link})')
            else:
                text_lines.append(f'{icon} {safe_name} ({count_str})')

        text = '\n'.join(text_lines)
        btns = []
        nav = []
        if page > 1:
            nav.append(Button.inline('< ä¸Šä¸€é¡µ', f'res_page_{cid}_{page-1}'.encode()))
        if page < pages:
            nav.append(Button.inline('ä¸‹ä¸€é¡µ >', f'res_page_{cid}_{page+1}'.encode()))
        if nav:
            btns.append(nav)
        btns.append([Button.inline('ğŸ”™ è¿”å›åˆ†ç±»', b'back_to_categories')])

        try:
            await event.edit(text, buttons=btns, parse_mode='markdown')
        except:
            await event.respond(text, buttons=btns, parse_mode='markdown')
    except Exception as e:
        print(f"[resource_page_callback] é”™è¯¯: {e}")
        await event.answer('åŠ è½½å¤±è´¥', alert=True)

@bot.on(events.NewMessage(pattern=BTN_SUPPORT))
async def support_handler(event):
    """åœ¨çº¿å®¢æœ"""
    try:
        original_sender_id = event.sender_id
        event.sender_id = get_main_account_id(original_sender_id, getattr(event.sender, 'username', None))
    except:
        pass
    
    # è·å–å®¢æœåˆ—è¡¨
    services = DB.get_customer_services()
    
    if not services:
        # å¦‚æœæ²¡æœ‰å®¢æœï¼Œæ˜¾ç¤ºåå°é…ç½®çš„æ–‡æœ¬
        config = get_system_config()
        await event.respond(config['support_text'])
        return
    
    # æ„å»ºå®¢æœåˆ—è¡¨
    text = 'ğŸ‘©â€ğŸ’¼ åœ¨çº¿å®¢æœ\n\nè¯·é€‰æ‹©å®¢æœè¿›è¡Œå’¨è¯¢:\n\n'
    buttons = []
    
    for service in services:
        text += f'â€¢ {service["name"]}\n'
        # è½¬æ¢é“¾æ¥æ ¼å¼
        link = service['link']
        if link.startswith('@'):
            link = f'https://t.me/{link[1:]}'
        elif not link.startswith('http'):
            link = f'https://t.me/{link}'
        
        buttons.append([Button.url(f'ğŸ’¬ è”ç³» {service["name"]}', link)])
    
    await event.respond(text, buttons=buttons, parse_mode='md')

@bot.on(events.NewMessage(pattern=BTN_VIP))
async def vip_handler(event):
    """å¼€é€šä¼šå‘˜"""
    try:
        original_sender_id = event.sender_id
        event.sender_id = get_main_account_id(original_sender_id, getattr(event.sender, 'username', None))
    except:
        pass
    
    member = DB.get_member(event.sender_id)
    if not member:
        await event.respond('è¯·å…ˆå‘é€ /start æ³¨å†Œ')
        return
    
    if member['is_vip']:
        await event.respond(
            'ğŸ’ æ‚¨å·²ç»æ˜¯VIPä¼šå‘˜!\n\n'
            f'å¼€é€šæ—¶é—´: {member["vip_time"][:10] if member["vip_time"] else "æœªçŸ¥"}'
        )
        return
    
    # è·å–æœ€æ–°é…ç½®
    config = get_system_config()
    
    # æ£€æŸ¥ä½™é¢æ˜¯å¦è¶³å¤Ÿ
    if member['balance'] >= config['vip_price']:
        await event.respond(
            f'ğŸ’ å¼€é€šVIPä¼šå‘˜\n\n'
            f'VIPä»·æ ¼: {config["vip_price"]} U\n'
            f'å½“å‰ä½™é¢: {member["balance"]} U\n\n'
            f'å¼€é€šVIPåæ‚¨å°†è·å¾—:\n'
            f'âœ… æŸ¥çœ‹è£‚å˜æ•°æ®\n'
            f'âœ… è·å¾—ä¸‹çº§å¼€é€šVIPçš„å¥–åŠ±\n'
            f'âœ… åŠ å…¥ä¸Šçº§ç¾¤ç»„\n'
            f'âœ… æ¨å¹¿èµšé’±åŠŸèƒ½\n\n'
            f'âœ… ä½™é¢å……è¶³ï¼Œå¯ä»¥ç›´æ¥å¼€é€š',
            buttons=[[Button.inline('ğŸ’³ ç¡®è®¤å¼€é€š', b'confirm_vip')]]
        )
    else:
        await event.respond(
            f'ğŸ’ å¼€é€šVIPä¼šå‘˜\n\n'
            f'VIPä»·æ ¼: {config["vip_price"]} U\n'
            f'å½“å‰ä½™é¢: {member["balance"]} U\n'
            f'è¿˜éœ€å……å€¼: {config["vip_price"] - member["balance"]} U\n\n'
            f'å¼€é€šVIPåæ‚¨å°†è·å¾—:\n'
            f'âœ… æŸ¥çœ‹è£‚å˜æ•°æ®\n'
            f'âœ… è·å¾—ä¸‹çº§å¼€é€šVIPçš„å¥–åŠ±\n'
            f'âœ… åŠ å…¥ä¸Šçº§ç¾¤ç»„\n'
            f'âœ… æ¨å¹¿èµšé’±åŠŸèƒ½\n\n'
            f'âŒ ä½™é¢ä¸è¶³ï¼Œè¯·å…ˆå……å€¼',
            buttons=[[Button.inline(f'ğŸ’° å……å€¼ {config["vip_price"]} U å¼€é€šVIP', b'recharge_for_vip')]]
        )

@bot.on(events.NewMessage(pattern=BTN_MY_PROMOTE))
async def my_promote_handler(event):
    """æˆ‘çš„æ¨å¹¿"""
    try:
        original_sender_id = event.sender_id
        event.sender_id = get_main_account_id(original_sender_id, getattr(event.sender, 'username', None))
    except:
        pass
    
    config = get_system_config()
    member = DB.get_member(event.sender_id)
    if not member:
        await event.respond('è¯·å…ˆå‘é€ /start æ³¨å†Œ')
        return
    
    # VIP check: å¦‚æœæœªå¼€é€šï¼Œå‘é€ç»Ÿä¸€å¡ç‰‡æç¤º
    if not member.get('is_vip'):
        await send_vip_required_prompt(event)
        return
    
    # è·å–ä¸‹çº§ç»Ÿè®¡
    counts = DB.get_downline_count(event.sender_id, config['level_count'])
    total_members = sum(c['total'] for c in counts)
    total_vip = sum(c['vip'] for c in counts)
    
    # ç”Ÿæˆæ¨å¹¿é“¾æ¥
    bot_info = await bot.get_me()
    invite_link = f'https://t.me/{bot_info.username}?start={event.sender_id}'
    
    text = f'ğŸ’« æˆ‘çš„æ¨å¹¿\n\n'
    text += f'ğŸ“Š æ¨å¹¿ç»Ÿè®¡:\n'
    text += f'â€¢ æ€»ä¸‹çº§: {total_members} äºº\n'
    text += f'â€¢ VIPä¸‹çº§: {total_vip} äºº\n'
    text += f'â€¢ ç´¯è®¡æ”¶ç›Š: {member["balance"]} U\n'
    text += f'â€¢ é”™è¿‡æ”¶ç›Š: {member["missed_balance"]} U\n\n'
    text += f'ğŸ”— æ‚¨çš„æ¨å¹¿é“¾æ¥:\n{invite_link}\n\n'
    text += f'ğŸ’¡ åˆ†äº«é“¾æ¥é‚€è¯·å¥½å‹ï¼Œå¥½å‹å¼€é€šVIPæ‚¨å³å¯è·å¾— {config["level_reward"]} U å¥–åŠ±!'
    
    buttons = [[Button.inline('ğŸ“¤ åˆ†äº«æ¨å¹¿', b'share_promote')]]
    if not member['is_vip']:
        buttons.append([Button.inline('ğŸ’ å¼€é€šVIPè§£é”å…¨éƒ¨åŠŸèƒ½', b'open_vip')])
    
    await event.respond(text, buttons=buttons, parse_mode='md')

@bot.on(events.NewMessage(pattern=BTN_BACK))
async def back_handler(event):
    """è¿”å›ä¸»èœå•"""
    try:
        original_sender_id = event.sender_id
        event.sender_id = get_main_account_id(original_sender_id, getattr(event.sender, 'username', None))
    except:
        pass
    
    member = DB.get_member(event.sender_id)
    if not member:
        await event.respond('è¯·å…ˆå‘é€ /start æ³¨å†Œ')
        return
    
    await event.respond(
        f'ğŸ¤– è£‚å˜æ¨å¹¿æœºå™¨äºº\n\n'
        f'ğŸ‘¤ ç”¨æˆ·: @{member["username"]}\n'
        f'ğŸ’ VIPçŠ¶æ€: {"âœ… å·²å¼€é€š" if member["is_vip"] else "âŒ æœªå¼€é€š"}\n'
        f'ğŸ’° ä½™é¢: {member["balance"]} U\n\n'
        f'è¯·é€‰æ‹©åŠŸèƒ½:',
        buttons=get_main_keyboard(event.sender_id)
    )

@bot.on(events.NewMessage(pattern=BTN_ADMIN))
async def admin_handler(event):
    """ç®¡ç†åå°"""
    try:
        original_sender_id = event.sender_id
        event.sender_id = get_main_account_id(original_sender_id, getattr(event.sender, 'username', None))
    except:
        pass
    
    if event.sender_id not in ADMIN_IDS:
        return
    
    # è·å–ç³»ç»Ÿé…ç½®
    config = get_system_config()
    
    text = f'âš™ï¸ ç®¡ç†åå°\n\n'
    text += f'å½“å‰è®¾ç½®:\n'
    text += f'ğŸ“Š å±‚æ•°: {config["level_count"]} å±‚\n'
    text += f'ğŸ’° æ¯å±‚è¿”åˆ©: {config["level_reward"]} U\n'
    text += f'ğŸ’ VIPä»·æ ¼: {config["vip_price"]} U\n'
    _fb_group = get_fallback_resource("group")
    if _fb_group:
        text += f"\n\nğŸ’¡ æ¨èç¾¤ç»„:\n{_fb_group}"
    text += f'ğŸ’³ æç°é—¨æ§›: {config["withdraw_threshold"]} U\n'
    text += f'ğŸ’µ USDTåœ°å€: {config["usdt_address"][:10] if config["usdt_address"] else "æœªè®¾ç½®"}...{config["usdt_address"][-10:] if config["usdt_address"] and len(config["usdt_address"]) > 20 else ""}\n\n'
    text += f'å®¢æœæ–‡æœ¬:\n{config["support_text"]}\n\n'
    from config import USE_PROXY
    web_url = 'http://154.201.68.178:5051' if not USE_PROXY else 'http://localhost:5051'
    text += f'ğŸŒ Webç®¡ç†åå°: {web_url}'
    
    buttons = [
        [Button.inline('ğŸ“Š è®¾ç½®å±‚æ•°', b'admin_set_level'), Button.inline('ğŸ’° è®¾ç½®è¿”åˆ©', b'admin_set_reward')],
        [Button.inline('ğŸ’ è®¾ç½®VIPä»·æ ¼', b'admin_set_vip_price'), Button.inline('ğŸ’³ è®¾ç½®æç°é—¨æ§›', b'admin_set_withdraw')],
        [Button.inline('ğŸ‘©â€ğŸ’¼ è®¾ç½®å®¢æœæ–‡æœ¬', b'admin_set_support'), Button.inline('ğŸ’« æŸ¥çœ‹ä¼šå‘˜ç»Ÿè®¡', b'admin_stats')],
        [Button.inline('ğŸ æ‰‹åŠ¨å……å€¼VIP', b'admin_manual_vip'), Button.inline('ğŸ“¢ ç”¨æˆ·å¹¿æ’­', b'admin_broadcast')]
    ]
    
    await event.respond(text, buttons=buttons, parse_mode='md')

# ==================== ç¾¤ç»„æ¬¢è¿å’Œè‡ªåŠ¨æ³¨å†Œ ====================

@bot.on(events.ChatAction)
async def group_welcome_handler(event):
    """æ–°æˆå‘˜åŠ å…¥ç¾¤æ—¶å‘é€æ¬¢è¿è¯­ï¼Œå¹¶è‡ªåŠ¨æ³¨å†Œä¸ºé‚€è¯·è€…ä¸‹çº§"""
    try:
        print(f'[ChatAction] æ”¶åˆ°äº‹ä»¶: {type(event.action_message.action).__name__ if event.action_message else "æ— "}')
        
        # æ£€æŸ¥æ˜¯å¦æ˜¯ç”¨æˆ·åŠ å…¥äº‹ä»¶
        if event.user_joined or event.user_added:
            sys_config = get_system_config()
            
            # è·å–æ–°æˆå‘˜ä¿¡æ¯
            user = await event.get_user()
            if not user:
                print('[ç¾¤äº‹ä»¶] æ— æ³•è·å–ç”¨æˆ·ä¿¡æ¯')
                return
            
            new_user_id = user.id
            new_username = user.username or f'user_{new_user_id}'
            user_name = user.first_name or ''
            if user.last_name:
                user_name += f' {user.last_name}'
            user_name = user_name.strip() or f'ç”¨æˆ·{new_user_id}'
            
            # è·å–ç¾¤ä¿¡æ¯
            chat = await event.get_chat()
            chat_id = chat.id if chat else None
            print(f'[ç¾¤äº‹ä»¶] ç¾¤ID={chat_id}, æ–°ç”¨æˆ·={new_user_id}({new_username})')
            
            # ===== è‡ªåŠ¨æ³¨å†ŒåŠŸèƒ½ =====
            auto_register_enabled = sys_config.get('auto_register_enabled', '0')
            print(f'[è‡ªåŠ¨æ³¨å†Œ] å¼€å…³çŠ¶æ€={auto_register_enabled}')
            
            if auto_register_enabled == '1' or auto_register_enabled == 1:
                try:
                    # è·å–é‚€è¯·è€…ID - å°è¯•å¤šç§æ–¹å¼
                    added_by = None
                    
                    # æ–¹å¼1: event.added_by
                    if hasattr(event, 'added_by') and event.added_by:
                        added_by = event.added_by
                        print(f'[è‡ªåŠ¨æ³¨å†Œ] æ–¹å¼1è·å–é‚€è¯·è€…: {added_by}')
                    
                    # æ–¹å¼2: action_message.action
                    if not added_by and hasattr(event, 'action_message') and event.action_message:
                        action = event.action_message.action
                        print(f'[è‡ªåŠ¨æ³¨å†Œ] actionç±»å‹: {type(action).__name__}')
                        if hasattr(action, 'inviter_id') and action.inviter_id:
                            added_by = action.inviter_id
                            print(f'[è‡ªåŠ¨æ³¨å†Œ] æ–¹å¼2aè·å–é‚€è¯·è€…: {added_by}')
                    
                    # æ–¹å¼3: ä»æ¶ˆæ¯å‘é€è€…è·å–
                    if not added_by and event.action_message:
                        from_id = event.action_message.from_id
                        if from_id:
                            if hasattr(from_id, 'user_id'):
                                added_by = from_id.user_id
                            elif hasattr(from_id, 'id'):
                                added_by = from_id.id
                            elif isinstance(from_id, int):
                                added_by = from_id
                            print(f'[è‡ªåŠ¨æ³¨å†Œ] æ–¹å¼3è·å–é‚€è¯·è€…: {added_by}')
                    
                    # ç¡®ä¿ added_by æ˜¯æ•´æ•°ID
                    if added_by and not isinstance(added_by, int):
                        if hasattr(added_by, 'id'):
                            added_by = added_by.id
                        elif hasattr(added_by, 'user_id'):
                            added_by = added_by.user_id
                        print(f'[è‡ªåŠ¨æ³¨å†Œ] è½¬æ¢åé‚€è¯·è€…ID: {added_by}')
                    
                    # æ–¹å¼4: å¦‚æœæ˜¯é€šè¿‡ç¾¤é“¾æ¥åŠ å…¥ï¼Œå°è¯•æ‰¾ç¾¤ä¸»
                    if not added_by and chat_id:
                        conn = get_db_conn()
                        c = conn.cursor()
                        c.execute('SELECT telegram_id FROM members WHERE group_link LIKE ?', (f'%{chat_id}%',))
                        owner = c.fetchone()
                        conn.close()
                        if owner:
                            added_by = owner[0]
                            print(f'[è‡ªåŠ¨æ³¨å†Œ] æ–¹å¼4è·å–ç¾¤ä¸»: {added_by}')
                    
                    print(f'[è‡ªåŠ¨æ³¨å†Œ] æœ€ç»ˆé‚€è¯·è€…={added_by}, æ–°ç”¨æˆ·={new_user_id}')
                    
                    if added_by and added_by != new_user_id:
                        # æ£€æŸ¥é‚€è¯·è€…æ˜¯å¦æ˜¯ä¼šå‘˜
                        inviter = DB.get_member(added_by)
                        print(f'[è‡ªåŠ¨æ³¨å†Œ] é‚€è¯·è€…æ˜¯ä¼šå‘˜: {inviter is not None}')
                        if inviter:
                            # æ£€æŸ¥æ–°ç”¨æˆ·æ˜¯å¦å·²æ³¨å†Œ
                            existing = DB.get_member(new_user_id)
                            print(f'[è‡ªåŠ¨æ³¨å†Œ] æ–°ç”¨æˆ·å·²æ³¨å†Œ: {existing is not None}')
                            if not existing:
                                # æ³¨å†Œæ–°ç”¨æˆ·ä¸ºé‚€è¯·è€…çš„ä¸‹çº§
                                DB.create_member(new_user_id, new_username, added_by)
                                print(f'âœ… è‡ªåŠ¨æ³¨å†ŒæˆåŠŸ: {new_username} æˆä¸º {inviter["username"]} çš„ä¸‹çº§')
                                
                                # é€šçŸ¥é‚€è¯·è€…
                                try:
                                    await bot.send_message(
                                        added_by,
                                        (
                                            "ğŸ“¨ é‚€è¯·æˆåŠŸé€šçŸ¥\n\n"
                                            f"ğŸ‘¥ æ‚¨çš„ä¸‹çº§æ–°æˆå‘˜åŠ å…¥ï¼š[{user_name}](tg://user?id={new_user_id})\n"
                                            "ğŸ¯ æ‚¨çš„ç›´æ¨å¥½å‹æ•°é‡ +1\n\n"
                                            "ğŸ’¡ å¿«å»å¸¦é¢†ä»–å¼€é€š VIPï¼Œå‘å±•æ›´å¤šå›¢é˜Ÿå§ï½"
                                        ),
                                        parse_mode='markdown'
                                    )
                                    print(f'âœ… å·²é€šçŸ¥é‚€è¯·è€… {added_by}')
                                except Exception as notify_err:
                                    print(f'é€šçŸ¥é‚€è¯·è€…å¤±è´¥: {notify_err}')
                            else:
                                print(f'[è‡ªåŠ¨æ³¨å†Œ] è·³è¿‡: ç”¨æˆ·å·²å­˜åœ¨')
                        else:
                            print(f'[è‡ªåŠ¨æ³¨å†Œ] è·³è¿‡: é‚€è¯·è€…ä¸æ˜¯ä¼šå‘˜')
                    else:
                        print(f'[è‡ªåŠ¨æ³¨å†Œ] è·³è¿‡: æ— æ³•è·å–é‚€è¯·è€…æˆ–æ˜¯è‡ªå·±')
                except Exception as e:
                    print(f'è‡ªåŠ¨æ³¨å†Œå¤„ç†å¤±è´¥: {e}')
                    import traceback
                    traceback.print_exc()
            
            # ===== æ¬¢è¿è¯­åŠŸèƒ½ =====
            welcome_enabled = sys_config.get('welcome_enabled', '1')
            if welcome_enabled == '1' or welcome_enabled == 1:
                welcome_message = sys_config.get('welcome_message', '')
                
                if welcome_message:
                    # æ›¿æ¢æ¬¢è¿è¯­ä¸­çš„å˜é‡
                    msg = welcome_message.replace('{name}', user_name)
                    msg = msg.replace('{username}', f'@{new_username}' if user.username else user_name)
                    msg = msg.replace('{id}', str(new_user_id))
                    
                    await event.respond(f'ğŸ‘‹ {msg}')
    except Exception as e:
        print(f'ç¾¤äº‹ä»¶å¤„ç†å¤±è´¥: {e}')

# ==================== å®Œæ•´çš„æ¶ˆæ¯å¤„ç†å™¨ ====================

@bot.on(events.NewMessage())
async def message_handler(event):
    """å®Œæ•´çš„æ¶ˆæ¯å¤„ç†å™¨ - å¤„ç†æç°ã€ç®¡ç†å‘˜è®¾ç½®ã€ç¾¤é“¾æ¥ç­‰"""
    # è´¦å·å…³è”å¤„ç†
    try:
        original_sender_id = event.sender_id
        event.sender_id = get_main_account_id(original_sender_id, getattr(event.sender, 'username', None))
    except:
        pass
    
    # å¿½ç•¥å‘½ä»¤å’ŒæŒ‰é’®æ–‡å­—
    if not event.message.text:
        return
    
    text = event.message.text.strip()
    sender_id = event.sender_id
    
    # å¤„ç†æç°é‡‘é¢è¾“å…¥
    if sender_id in waiting_for_withdraw_amount:
        del waiting_for_withdraw_amount[sender_id]
        try:
            amount = float(text)
            config = get_system_config()
            member = DB.get_member(sender_id)
            
            if amount < config['withdraw_threshold']:
                await event.respond(f'âŒ æç°é‡‘é¢ä¸èƒ½å°äº {config["withdraw_threshold"]} U')
                return
            
            if amount > member['balance']:
                await event.respond(f'âŒ ä½™é¢ä¸è¶³\n\nå½“å‰ä½™é¢: {member["balance"]} U')
                return
            
            withdraw_temp_data[sender_id] = amount
            waiting_for_withdraw_address[sender_id] = True
            await event.respond(
                f'ğŸ’³ æç°ç”³è¯·\n\n'
                f'æç°é‡‘é¢: {amount} U\n\n'
                f'è¯·è¾“å…¥æ‚¨çš„USDTæ”¶æ¬¾åœ°å€ï¼ˆTRC20ï¼‰ï¼š'
            )
        except ValueError:
            await event.respond('âŒ è¯·è¾“å…¥æœ‰æ•ˆçš„æ•°å­—é‡‘é¢')
        return
    
    # å¤„ç†æç°åœ°å€è¾“å…¥
    if sender_id in waiting_for_withdraw_address:
        del waiting_for_withdraw_address[sender_id]
        usdt_address = text.strip()
        
        if not usdt_address or len(usdt_address) < 20:
            await event.respond('âŒ è¯·è¾“å…¥æœ‰æ•ˆçš„USDTåœ°å€')
            return
        
        amount = withdraw_temp_data.get(sender_id, 0)
        if amount <= 0:
            await event.respond('âŒ æç°é‡‘é¢é”™è¯¯ï¼Œè¯·é‡æ–°ç”³è¯·')
            return
        
        del withdraw_temp_data[sender_id]
        
        try:
            import datetime
            import time
            
            # é‡è¯•æœºåˆ¶å¤„ç†æ•°æ®åº“é”
            max_retries = 3
            for retry in range(max_retries):
                try:
                    conn = get_db_conn()
                    conn.execute("PRAGMA busy_timeout = 5000")
                    c = conn.cursor()
                    
                    # æ‰£é™¤ä½™é¢
                    c.execute("UPDATE members SET balance = balance - ? WHERE telegram_id = ?", (amount, sender_id))
                    
                    # æ’å…¥æç°è®°å½•
                    now = get_cn_time()
                    
                    # æ£€æŸ¥è¡¨æ˜¯å¦æœ‰usdt_addresså­—æ®µ
                    c.execute("PRAGMA table_info(withdrawals)")
                    columns = [col[1] for col in c.fetchall()]
                    if 'usdt_address' in columns:
                        c.execute("INSERT INTO withdrawals (member_id, amount, usdt_address, status, create_time) VALUES (?, ?, ?, 'pending', ?)",
                                 (sender_id, amount, usdt_address, now))
                    else:
                        c.execute("INSERT INTO withdrawals (member_id, amount, status, create_time) VALUES (?, ?, 'pending', ?)",
                                 (sender_id, amount, now))
                    
                    conn.commit()
                    
                    # è·å–æ–°ä½™é¢
                    c.execute("SELECT balance FROM members WHERE telegram_id = ?", (sender_id,))
                    new_balance = c.fetchone()[0]
                    conn.close()
                    break
                    
                except Exception as e:
                    if 'locked' in str(e) and retry < max_retries - 1:
                        time.sleep(0.5)
                        continue
                    else:
                        raise
            
            await event.respond(
                f'âœ… æç°ç”³è¯·å·²æäº¤\n\n'
                f'æç°é‡‘é¢: {amount} U\n'
                f'æ”¶æ¬¾åœ°å€: {usdt_address}\n'
                f'å‰©ä½™ä½™é¢: {new_balance} U\n\n'
                f'â³ è¯·ç­‰å¾…ç®¡ç†å‘˜å®¡æ ¸\n'
                f'å®¡æ ¸ç»“æœå°†é€šè¿‡æœºå™¨äººé€šçŸ¥æ‚¨'
            )
        except Exception as e:
            await event.respond(f'âŒ æç°ç”³è¯·å¤±è´¥: {str(e)}')
        return
    
    # å¿½ç•¥å‘½ä»¤
    if text.startswith('/'):
        if text == '/cancel':
            waiting_for_group_link.pop(sender_id, None)
            waiting_for_backup.pop(sender_id, None)
            waiting_for_recharge_amount.pop(sender_id, None)
            admin_waiting.pop(sender_id, None)
            await event.respond('å·²å–æ¶ˆæ“ä½œ', buttons=get_main_keyboard(sender_id))
        return
    
    # å¿½ç•¥ä¸»èœå•æŒ‰é’®
    if text in [BTN_PROFILE, BTN_FISSION, BTN_VIEW_FISSION, BTN_RESOURCES, BTN_PROMOTE, BTN_SUPPORT, BTN_BACK, BTN_ADMIN, BTN_VIP, BTN_MY_PROMOTE]:
        return
    
    # ç®¡ç†å‘˜è®¾ç½®å¤„ç†
    if sender_id in admin_waiting:
        wait_type = admin_waiting[sender_id]
        config = get_system_config()
        
        if wait_type == 'level_count':
            try:
                value = int(text)
                if 1 <= value <= 20:
                    from database import update_system_config
                    update_system_config('level_count', value)
                    # åˆå§‹åŒ–æˆ–è°ƒæ•´æ¯å±‚é‡‘é¢é…ç½®ä¸ºå½“å‰æ¯å±‚è¿”åˆ©ï¼ˆæˆ–1ï¼‰* value å±‚ï¼Œä¾¿äºå‰ç«¯æ˜¾ç¤º
                    try:
                        import json
                        per_level = float(config.get('level_reward', 1))
                        amounts = [per_level for _ in range(value)]
                        update_system_config('level_amounts', json.dumps(amounts))
                    except Exception as e:
                        print(f"[admin_set_level] æ— æ³•åˆå§‹åŒ– level_amounts: {e}")
                    del admin_waiting[sender_id]
                    await event.respond(f'âœ… å±‚æ•°è®¾ç½®æˆåŠŸ!\n\nå½“å‰å±‚æ•°: {value} å±‚')
                else:
                    await event.respond('âŒ è¯·è¾“å…¥1-20ä¹‹é—´çš„æ•°å­—')
            except ValueError:
                await event.respond('âŒ è¯·è¾“å…¥æœ‰æ•ˆçš„æ•°å­—')
            return
        
        elif wait_type == 'level_reward':
            try:
                value = float(text)
                if value > 0:
                    from database import update_system_config
                    update_system_config('level_reward', value)
                    del admin_waiting[sender_id]
                    await event.respond(f'âœ… è¿”åˆ©è®¾ç½®æˆåŠŸ!\n\næ¯å±‚è¿”åˆ©: {value} U')
                else:
                    await event.respond('âŒ è¯·è¾“å…¥å¤§äº0çš„æ•°å­—')
            except ValueError:
                await event.respond('âŒ è¯·è¾“å…¥æœ‰æ•ˆçš„æ•°å­—')
            return
        
        elif wait_type == 'vip_price':
            try:
                value = float(text)
                if value > 0:
                    from database import update_system_config
                    update_system_config('vip_price', value)
                    del admin_waiting[sender_id]
                    await event.respond(f'âœ… VIPä»·æ ¼è®¾ç½®æˆåŠŸ!\n\nå½“å‰ä»·æ ¼: {value} U')
                else:
                    await event.respond('âŒ è¯·è¾“å…¥å¤§äº0çš„æ•°å­—')
            except ValueError:
                await event.respond('âŒ è¯·è¾“å…¥æœ‰æ•ˆçš„æ•°å­—')
            return
        
        elif wait_type == 'withdraw_threshold':
            try:
                value = float(text)
                if value >= 0:
                    from database import update_system_config
                    update_system_config('withdraw_threshold', value)
                    del admin_waiting[sender_id]
                    await event.respond(f'âœ… æç°é—¨æ§›è®¾ç½®æˆåŠŸ!\n\nå½“å‰é—¨æ§›: {value} U')
                else:
                    await event.respond('âŒ è¯·è¾“å…¥å¤§äºç­‰äº0çš„æ•°å­—')
            except ValueError:
                await event.respond('âŒ è¯·è¾“å…¥æœ‰æ•ˆçš„æ•°å­—')
            return
        
        elif wait_type == 'support_text':
            from database import update_system_config
            update_system_config('support_text', text)
            del admin_waiting[sender_id]
            await event.respond(f'âœ… å®¢æœæ–‡æœ¬è®¾ç½®æˆåŠŸ!\n\nå½“å‰æ–‡æœ¬:\n{text}')
            return
        
        elif wait_type == 'manual_vip':
            # æ‰‹åŠ¨å……å€¼VIP - è°ƒç”¨ç»Ÿä¸€å¤„ç†å‡½æ•°
            target_user = None
            
            # å°è¯•æŒ‰ç”¨æˆ·IDæŸ¥æ‰¾
            try:
                user_id = int(text.strip())
                target_user = DB.get_member(user_id)
                if not target_user:
                    await event.respond(f'âŒ æœªæ‰¾åˆ°ç”¨æˆ·ID: {user_id}\n\nè¯¥ç”¨æˆ·å¯èƒ½æœªä½¿ç”¨è¿‡æœºå™¨äºº')
                    return
            except ValueError:
                # æŒ‰ç”¨æˆ·åæŸ¥æ‰¾
                username = text.strip().lstrip('@')
                conn = get_db_conn()
                c = conn.cursor()
                c.execute('SELECT * FROM members WHERE username = ?', (username,))
                row = c.fetchone()
                conn.close()
                
                if row:
                    target_user = {
                        'id': row[0], 'telegram_id': row[1], 'username': row[2],
                        'backup_account': row[3], 'referrer_id': row[4], 'balance': row[5],
                        'missed_balance': row[6], 'group_link': row[7], 'is_vip': row[8],
                        'register_time': row[9], 'vip_time': row[10]
                    }
                else:
                    await event.respond(f'âŒ æœªæ‰¾åˆ°ç”¨æˆ·å: @{username}\n\nè¯¥ç”¨æˆ·å¯èƒ½æœªä½¿ç”¨è¿‡æœºå™¨äºº')
                    return
            
            # æ£€æŸ¥æ˜¯å¦å·²ç»æ˜¯VIP
            if target_user['is_vip']:
                await event.respond(
                    f'âš ï¸ ç”¨æˆ·å·²æ˜¯VIP\n\n'
                    f'ç”¨æˆ·ID: {target_user["telegram_id"]}\n'
                    f'ç”¨æˆ·å: @{target_user["username"]}\n'
                    f'VIPå¼€é€šæ—¶é—´: {target_user["vip_time"][:10] if target_user["vip_time"] else "æœªçŸ¥"}'
                )
                del admin_waiting[sender_id]
                return
            
            # ã€æ ¸å¿ƒä¿®å¤ã€‘è°ƒç”¨ç»Ÿä¸€å¤„ç†å‡½æ•°
            success, result = await admin_manual_vip_handler(target_user['telegram_id'], config)
            
            if success:
                stats = result['stats']
                await event.respond(
                    f'âœ… VIPå……å€¼æˆåŠŸ!\n\n'
                    f'ç”¨æˆ·ID: {target_user["telegram_id"]}\n'
                    f'ç”¨æˆ·å: @{target_user["username"]}\n'
                    f'ç”¨æˆ·å·²æ”¶åˆ°å¼€é€šé€šçŸ¥'
                )
            else:
                await event.respond(f'âŒ {result}')
            
            del admin_waiting[sender_id]
            return
        
        elif wait_type == 'broadcast':
            # ç”¨æˆ·å¹¿æ’­
            broadcast_message = text
            
            # è·å–æ‰€æœ‰ç”¨æˆ·
            conn = get_db_conn()
            c = conn.cursor()
            c.execute('SELECT telegram_id, username FROM members')
            all_users = c.fetchall()
            conn.close()
            
            if not all_users:
                await event.respond('âŒ æš‚æ— ç”¨æˆ·')
                del admin_waiting[sender_id]
                return
            
            # å‘é€ç¡®è®¤æ¶ˆæ¯
            await event.respond(
                f'ğŸ“¢ å¼€å§‹å¹¿æ’­...\n\n'
                f'ç›®æ ‡ç”¨æˆ·æ•°: {len(all_users)} äºº\n'
                f'é¢„è®¡è€—æ—¶: {len(all_users) * 0.05:.1f} ç§’\n\n'
                f'å¹¿æ’­å†…å®¹:\n'
                f'---\n{broadcast_message}\n---\n\n'
                f'æ­£åœ¨å‘é€ä¸­ï¼Œè¯·ç¨å€™...'
            )
            
            # å‘é€å¹¿æ’­
            success_count = 0
            failed_count = 0
            
            for user_id, username in all_users:
                try:
                    await bot.send_message(
                        user_id,
                        f'ğŸ“¢ ç³»ç»Ÿå¹¿æ’­\n\n{broadcast_message}',
                        parse_mode='markdown'
                    )
                    success_count += 1
                    await asyncio.sleep(0.05)
                except Exception as e:
                    failed_count += 1
                    print(f"å‘é€å¹¿æ’­ç»™ç”¨æˆ· {user_id} (@{username}) å¤±è´¥: {e}")
            
            # å‘é€ç»Ÿè®¡ç»“æœ
            await event.respond(
                f'âœ… å¹¿æ’­å‘é€å®Œæˆ!\n\n'
                f'ğŸ“Š å‘é€ç»Ÿè®¡:\n'
                f'â€¢ æ€»ç”¨æˆ·æ•°: {len(all_users)} äºº\n'
                f'â€¢ å‘é€æˆåŠŸ: {success_count} äºº\n'
                f'â€¢ å‘é€å¤±è´¥: {failed_count} äºº\n'
                f'â€¢ æˆåŠŸç‡: {success_count / len(all_users) * 100:.1f}%\n\n'
                f'ğŸ’¡ å¤±è´¥åŸå› å¯èƒ½:\n'
                f'â€¢ ç”¨æˆ·å·²åˆ é™¤æˆ–æ‹‰é»‘æœºå™¨äºº\n'
                f'â€¢ ç”¨æˆ·è´¦å·è¢«å°ç¦\n'
                f'â€¢ ç”¨æˆ·éšç§è®¾ç½®é™åˆ¶'
            )
            
            del admin_waiting[sender_id]
            return
    
    # å¤„ç†å……å€¼é‡‘é¢è¾“å…¥
    if sender_id in waiting_for_recharge_amount and waiting_for_recharge_amount[sender_id]:
        try:
            amount = float(text)
            if amount <= 0:
                await event.respond('âŒ é‡‘é¢å¿…é¡»å¤§äº0')
                return
            if amount > 99999:
                await event.respond('âŒ å•æ¬¡å……å€¼é‡‘é¢ä¸èƒ½è¶…è¿‡99999 U')
                return
            
            del waiting_for_recharge_amount[sender_id]
            await create_recharge_order(bot, event, amount)
        except ValueError:
            await event.respond('âŒ è¯·è¾“å…¥æœ‰æ•ˆçš„æ•°å­—')
        return
    
    # è®¾ç½®å¤‡ç”¨å·
    if sender_id in waiting_for_backup and waiting_for_backup[sender_id]:
        backup_raw = text.strip().lstrip('@')
        backup_id = None
        backup_username = None
        
        # å°è¯•è§£ææ•°å­—ID
        if backup_raw.isdigit():
            backup_id = int(backup_raw)
        
        # æ— è®ºæ˜¯IDè¿˜æ˜¯ç”¨æˆ·åï¼Œéƒ½å°è¯•é€šè¿‡ Telegram è·å–å®ä½“
        try:
            entity_query = backup_id if backup_id is not None else backup_raw
            entity = await bot.get_entity(entity_query)
            if getattr(entity, 'id', None):
                backup_id = entity.id
                backup_username = getattr(entity, 'username', None)
        except Exception as e:
            print(f"[å¤‡ç”¨å·è§£æå¤±è´¥] {e}")
        
        if not backup_id:
            await event.respond('âŒ æœªæ‰¾åˆ°è¯¥å¤‡ç”¨å·ï¼Œè¯·å‘é€æ­£ç¡®çš„ç”¨æˆ·åæˆ–ID')
            return
        
        success, message = link_account(sender_id, backup_id, backup_username)
        del waiting_for_backup[sender_id]
        await event.respond(message)
        return
    
    # è®¾ç½®ç¾¤é“¾æ¥
    if sender_id in waiting_for_group_link and waiting_for_group_link[sender_id]:
        link = text
        # åªå…è®¸ http(s)://t.me/ å¼€å¤´çš„é“¾æ¥
        if link.startswith('http://t.me/') or link.startswith('https://t.me/'):
            # éªŒè¯ç¾¤é“¾æ¥
            verification_result = await verify_group_link(bot, link)
            
            if verification_result['success']:
                # æ ¹æ®æ˜¯å¦æˆåŠŸæ£€æµ‹ç®¡ç†å‘˜æ¥è®¾ç½® is_bot_admin
                is_admin_flag = 1 if verification_result.get('admin_checked') else 0
                
                DB.update_member(sender_id, group_link=link, is_group_bound=1, is_bot_admin=is_admin_flag)
                try:
                    sender_username = getattr(event.sender, 'username', None) if hasattr(event, 'sender') else None
                    from database import upsert_member_group
                    upsert_member_group(sender_id, link, sender_username, is_bot_admin=is_admin_flag)
                except Exception as sync_err:
                    print(f'[ç»‘å®šç¾¤å†™å…¥member_groupså¤±è´¥] {sync_err}')
                del waiting_for_group_link[sender_id]
                
                # æ„é€ æç¤ºæ–‡æ¡ˆ
                if verification_result.get('admin_checked'):
                    await event.respond(
                        f'âœ… ç¾¤é“¾æ¥è®¾ç½®æˆåŠŸ!\n\n'
                        f'é“¾æ¥: {link}\n'
                        f'âœ… æœºå™¨äººå·²åœ¨ç¾¤å†…\n'
                        f'âœ… æœºå™¨äººå…·æœ‰ç®¡ç†å‘˜æƒé™'
                    )
                else:
                    await event.respond(
                        f'âœ… ç¾¤ç»„é“¾æ¥å·²è®°å½•\n\n'
                        f'é“¾æ¥: {link}\n\n'
                        f'â„¹ï¸ ç”±äºæ˜¯ç§æœ‰é‚€è¯·é“¾æ¥ï¼ŒTelegram é™åˆ¶æ— æ³•è‡ªåŠ¨æ£€æµ‹æ˜¯å¦åŠ ç¾¤ / æ˜¯å¦è®¾ç½®ç¾¤ç®¡ã€‚\n'
                        f'ğŸ‘‰ å»ºè®®ä¸ºè¯¥ç¾¤è®¾ç½®ä¸€ä¸ªå…¬å¼€ç”¨æˆ·åï¼Œå¹¶å‘é€å…¬å¼€ç¾¤é“¾æ¥ï¼ˆä¾‹å¦‚ https://t.me/ç¾¤ç”¨æˆ·åï¼‰ï¼Œ\n'
                        f'è¿™æ ·ç³»ç»Ÿæ‰èƒ½è‡ªåŠ¨æ£€æµ‹æ‚¨æ˜¯å¦å·²åŠ ç¾¤å¹¶ä¸”æœºå™¨äººæ˜¯å¦ä¸ºç¾¤ç®¡ã€‚'
                    )
            else:
                reason = verification_result.get("message", "æœªçŸ¥é”™è¯¯")
                await event.respond(
                    f'âŒ ç¾¤é“¾æ¥éªŒè¯å¤±è´¥\n\n'
                    f'åŸå› : {reason}\n\n'
                    f'è¯·ç¡®ä¿:\n'
                    f'1. æœºå™¨äººå·²è¢«æ·»åŠ åˆ°ç¾¤å†…\n'
                    f'2. æœºå™¨äººå…·æœ‰ç®¡ç†å‘˜æƒé™\n\n'
                    f'3. ä½¿ç”¨ http://t.me/ç¾¤ç”¨æˆ·å æˆ– https://t.me/ç¾¤ç”¨æˆ·å çš„å…¬å¼€ç¾¤é“¾æ¥\n\n'
                    f'å®Œæˆåè¯·é‡æ–°å‘é€ç¾¤é“¾æ¥'
                )
        else:
            await event.respond('âŒ é“¾æ¥æ ¼å¼ä¸æ­£ç¡®ï¼Œè¯·å‘é€æ­£ç¡®çš„Telegramç¾¤é“¾æ¥\nä¾‹å¦‚: http://t.me/ç¾¤ç”¨æˆ·å æˆ– https://t.me/ç¾¤ç”¨æˆ·å')
        return

# ==================== é€šçŸ¥é˜Ÿåˆ—å¤„ç† ====================

async def process_notify_queue():
    """å¤„ç†é€šçŸ¥é˜Ÿåˆ—"""
    while True:
        try:
            await asyncio.sleep(1)
            while notify_queue:
                item = notify_queue.pop(0)
                try:
                    await bot.send_message(item['member_id'], item['message'])
                    print(f"âœ… é€šçŸ¥å·²å‘é€: ç”¨æˆ·{item['member_id']}")
                except Exception as e:
                    print(f"å‘é€é€šçŸ¥å¤±è´¥: {e}")
        except Exception as e:
            print(f"[é€šçŸ¥é˜Ÿåˆ—] é”™è¯¯: {e}")
            await asyncio.sleep(5)

# ==================== åå°å®šæ—¶ä»»åŠ¡ ====================

async def auto_broadcast_timer():
    """å®šæ—¶è‡ªåŠ¨ç¾¤å‘ - æ ¹æ® assignment ä¸­æ¯æ¡æ¶ˆæ¯çš„ broadcast_interval å’Œ last_sent_time è°ƒåº¦å‘é€"""
    import json
    from datetime import datetime

    check_interval_seconds = 10  # æ¯10ç§’æ‰«æä¸€æ¬¡
    
    while True:
        try:
            await asyncio.sleep(check_interval_seconds)
            now_ts = time.time()
            print("[å®šæ—¶ç¾¤å‘] æ‰«æåˆ†é…ä»»åŠ¡...", flush=True)
            
            conn = get_db_conn()
            c = conn.cursor()
            
            # å…¨å±€å¼€å…³ï¼šå…è®¸ç®¡ç†å‘˜å…³é—­å®šæ—¶åˆ†å‘
            c.execute("SELECT value FROM system_config WHERE key = 'broadcast_enabled'")
            row = c.fetchone()
            broadcast_enabled = row[0] == '1' if row else True
            if not broadcast_enabled:
                conn.close()
                continue
            
            # æŸ¥è¯¢æ‰€æœ‰å¯ç”¨åˆ†é…ï¼šå…³è” member_groupsã€broadcast_assignmentsã€broadcast_messages
            c.execute("""
                SELECT ba.id, ba.group_id, ba.message_id, ba.last_sent_time,
                       mg.group_link, mg.group_name,
                       bm.content, bm.image_url, bm.video_url, bm.buttons, bm.buttons_per_row, bm.broadcast_interval, bm.create_time
                FROM broadcast_assignments ba
                JOIN broadcast_messages bm ON ba.message_id = bm.id
                JOIN member_groups mg ON ba.group_id = mg.id
                WHERE ba.is_active = 1 AND bm.is_active = 1 AND mg.schedule_broadcast = 1
                ORDER BY bm.create_time ASC, bm.id ASC
            """)
            rows = c.fetchall()

            if not rows:
                conn.close()
                continue
            
            to_enqueue = []
            for r in rows:
                assign_id, group_id, message_id, last_sent_time, group_link, group_name, content, image_url, video_url, buttons_json, buttons_per_row, b_interval, bm_create = r
                try:
                    interval_minutes = int(b_interval) if b_interval else 120
                except:
                    interval_minutes = 120
                interval_seconds = interval_minutes * 60

                # parse last_sent_time (ISO) to timestamp
                last_ts = 0
                if last_sent_time:
                    try:
                        # handle timezone-aware ISO strings
                        dt = datetime.fromisoformat(last_sent_time)
                        last_ts = dt.timestamp()
                    except Exception:
                        try:
                            last_ts = float(last_sent_time)
                        except:
                            last_ts = 0

                # if never sent or interval elapsed, enqueue
                if now_ts - last_ts >= interval_seconds:
                    # prepare message content (simple: content only; buttons/media handled by process_broadcast_queue)
                    to_enqueue.append({
                        'assign_id': assign_id,
                        'group_id': group_id,
                        'group_link': group_link,
                        'group_name': group_name,
                        'message_id': message_id,
                        'content': content or '',
                        'image_url': image_url or '',
                        'video_url': video_url or '',
                        'buttons': buttons_json or '',
                        'buttons_per_row': buttons_per_row or 2
                    })

            # æ’å…¥åˆ° broadcast_queue å¹¶æ›´æ–° last_sent_time
            if to_enqueue:
                now_iso = get_cn_time()
                for item in to_enqueue:
                    try:
                        # insert queue entry (store JSON if item contains media)
                        import json as _json
                        msg_payload = _json.dumps({
                            'content': item.get('content') or '',
                            'image_url': item.get('image_url') or '',
                            'video_url': item.get('video_url') or '',
                            'buttons': item.get('buttons') or '',
                            'buttons_per_row': item.get('buttons_per_row') or 2
                        }, ensure_ascii=False)
                        c.execute('INSERT INTO broadcast_queue (group_link, group_name, message, status, create_time) VALUES (?, ?, ?, ?, ?)',
                                  (item['group_link'], item['group_name'], msg_payload, 'pending', now_iso))
                        # update last_sent_time for assignment
                        c.execute('UPDATE broadcast_assignments SET last_sent_time = ? WHERE id = ?', (now_iso, item['assign_id']))
                    except Exception as e:
                        print(f"[å®šæ—¶ç¾¤å‘] å…¥é˜Ÿå¤±è´¥ assign_id={item.get('assign_id')}: {e}")
                conn.commit()
                print(f"[å®šæ—¶ç¾¤å‘] å·²å…¥é˜Ÿ {len(to_enqueue)} æ¡æ¶ˆæ¯")
            
            conn.close()
        except Exception as e:
            print(f"[å®šæ—¶ç¾¤å‘] é”™è¯¯: {e}")
            await asyncio.sleep(30)

async def process_broadcast_queue():
    """å¤„ç†ç¾¤å‘é˜Ÿåˆ—ï¼ˆæ•°æ®åº“é˜Ÿåˆ—ï¼‰"""
    while True:
        try:
            await asyncio.sleep(5)  # æ¯5ç§’æ£€æŸ¥ä¸€æ¬¡
            conn = get_db_conn()
            c = conn.cursor()
            
            # è·å–å¾…å‘é€çš„ä»»åŠ¡
            c.execute("SELECT id, group_link, group_name, message FROM broadcast_queue WHERE status = 'pending' LIMIT 10")
            tasks = c.fetchall()
            
            for task in tasks:
                task_id, group_link, group_name, message = task
                try:
                    if group_link and 't.me/' in group_link:
                        chat_username = group_link.split('t.me/')[-1].split('/')[0].split('?')[0]
                        if not chat_username.startswith('+'):
                            # æ”¯æŒ message å­˜å‚¨ä¸ºçº¯æ–‡æœ¬æˆ– JSON å­—ç¬¦ä¸²ï¼ˆåŒ…å« content/image_url/video_url/buttonsï¼‰
                            send_text = None
                            send_image = None
                            send_video = None
                            send_buttons = None
                            try:
                                import json as _json
                                parsed = _json.loads(message)
                                if isinstance(parsed, dict):
                                    send_text = parsed.get('content') or ''
                                    send_image = parsed.get('image_url') or ''
                                    send_video = parsed.get('video_url') or ''
                                    send_buttons = parsed.get('buttons') or ''
                                else:
                                    send_text = str(parsed)
                            except Exception:
                                send_text = message

                            # send file if image or video present
                            if send_image:
                                file_path = send_image
                                if send_image.startswith('/static/uploads/'):
                                    # prefer local file path using UPLOAD_DIR from config
                                    try:
                                        from config import UPLOAD_DIR
                                        filename = os.path.basename(send_image)
                                        local_path = os.path.join(UPLOAD_DIR, filename)
                                    except Exception:
                                        local_path = os.path.join(os.path.dirname(os.path.dirname(__file__)), send_image.lstrip('/'))

                                    if os.path.exists(local_path):
                                        await bot.send_file(f'@{chat_username}', local_path, caption=send_text)
                                    else:
                                        # fallback to sending as URL and log error
                                        print(f"[ç¾¤å‘é”™è¯¯] æ‰¾ä¸åˆ°æœ¬åœ°å›¾ç‰‡æ–‡ä»¶: {local_path}")
                                        await bot.send_message(f'@{chat_username}', send_text + '\n' + send_image)
                                else:
                                    await bot.send_message(f'@{chat_username}', send_text + '\n' + send_image)
                            elif send_video:
                                file_path = send_video
                                if send_video.startswith('/static/uploads/'):
                                    try:
                                        from config import UPLOAD_DIR
                                        filename = os.path.basename(send_video)
                                        local_path = os.path.join(UPLOAD_DIR, filename)
                                    except Exception:
                                        local_path = os.path.join(os.path.dirname(os.path.dirname(__file__)), send_video.lstrip('/'))

                                    if os.path.exists(local_path):
                                        await bot.send_file(f'@{chat_username}', local_path, caption=send_text)
                                    else:
                                        print(f"[ç¾¤å‘é”™è¯¯] æ‰¾ä¸åˆ°æœ¬åœ°è§†é¢‘æ–‡ä»¶: {local_path}")
                                        await bot.send_message(f'@{chat_username}', send_text + '\n' + send_video)
                                else:
                                    await bot.send_message(f'@{chat_username}', send_text + '\n' + send_video)
                            else:
                                # try to build buttons if any
                                buttons_obj = None
                                if send_buttons:
                                    try:
                                        import json as _json2
                                        btns = _json2.loads(send_buttons)
                                        per_row = 2
                                        # if buttons_per_row present in parsed, use it
                                        if isinstance(parsed, dict) and parsed.get('buttons_per_row'):
                                            per_row = int(parsed.get('buttons_per_row') or per_row)
                                        rows = []
                                        row_buf = []
                                        for b in btns:
                                            if b.get('name') and b.get('url'):
                                                row_buf.append(Button.url(b['name'], b['url']))
                                                if len(row_buf) >= per_row:
                                                    rows.append(row_buf)
                                                    row_buf = []
                                        if row_buf:
                                            rows.append(row_buf)
                                        if rows:
                                            buttons_obj = rows
                                    except Exception:
                                        buttons_obj = None

                                if buttons_obj:
                                    await bot.send_message(f'@{chat_username}', send_text, buttons=buttons_obj)
                                else:
                                    await bot.send_message(f'@{chat_username}', send_text)

                            c.execute("UPDATE broadcast_queue SET status = 'sent', result = 'å‘é€æˆåŠŸ' WHERE id = ?", (task_id,))
                            print(f"[ç¾¤å‘é˜Ÿåˆ—] å·²å‘é€åˆ° {group_name}")
                        else:
                            c.execute("UPDATE broadcast_queue SET status = 'failed', result = 'ç§æœ‰ç¾¤é“¾æ¥' WHERE id = ?", (task_id,))
                    else:
                        c.execute("UPDATE broadcast_queue SET status = 'failed', result = 'æ— æ•ˆé“¾æ¥' WHERE id = ?", (task_id,))
                except Exception as e:
                    c.execute("UPDATE broadcast_queue SET status = 'failed', result = ? WHERE id = ?", (str(e)[:200], task_id))
                    print(f"[ç¾¤å‘é˜Ÿåˆ—] å‘é€åˆ° {group_name} å¤±è´¥: {e}")
                
                conn.commit()
                await asyncio.sleep(1)  # æ¯æ¡æ¶ˆæ¯é—´éš”1ç§’ï¼Œé¿å…é¢‘ç‡é™åˆ¶
            
            conn.close()
        except Exception as e:
            print(f"[ç¾¤å‘é˜Ÿåˆ—] å¤„ç†é”™è¯¯: {e}")
            await asyncio.sleep(10)

async def process_broadcasts():
    """å®šæœŸæ£€æŸ¥å¹¶å¤„ç†å¾…å‘é€çš„ç¾¤å‘ä»»åŠ¡ï¼ˆå†…å­˜é˜Ÿåˆ—ï¼‰"""
    while True:
        try:
            if pending_broadcasts:
                task = pending_broadcasts.pop(0)
                task_type = task.get('type', 'broadcast')
                
                # å¤„ç†ç½®é¡¶å¹¿å‘Šä»»åŠ¡
                if task_type == 'pinned_ad':
                    content = task['content']
                    groups = task['groups']  # [(telegram_id, group_link), ...]
                    
                    print(f'å¼€å§‹å‘å¸ƒç½®é¡¶å¹¿å‘Šåˆ° {len(groups)} ä¸ªç¾¤')
                    success_count = 0
                    fail_count = 0
                    
                    for telegram_id, group_link in groups:
                        try:
                            if not group_link:
                                continue
                            # ä»ç¾¤é“¾æ¥æå–ç¾¤IDæˆ–ç”¨æˆ·å
                            if group_link.startswith('https://t.me/'):
                                group_username = group_link.replace('https://t.me/', '')
                            elif group_link.startswith('@'):
                                group_username = group_link
                            else:
                                group_username = group_link
                            
                            # å‘é€å¹¿å‘Šæ¶ˆæ¯
                            msg = await bot.send_message(group_username, f'ğŸ“¢ å…¬å‘Š\n\n{content}')
                            
                            # å°è¯•ç½®é¡¶æ¶ˆæ¯ï¼ˆéœ€è¦ç®¡ç†å‘˜æƒé™ï¼‰
                            try:
                                await bot.pin_message(group_username, msg.id, notify=False)
                            except Exception as pin_err:
                                print(f'ç½®é¡¶å¤±è´¥(å¯èƒ½æ— æƒé™): {pin_err}')
                            
                            success_count += 1
                            await asyncio.sleep(0.5)
                        except Exception as e:
                            fail_count += 1
                            print(f'å‘é€åˆ°ç¾¤ç»„å¤±è´¥ {group_link}: {e}')
                    
                    print(f'ç½®é¡¶å¹¿å‘Šå‘å¸ƒå®Œæˆ: æˆåŠŸ{success_count}ä¸ªç¾¤ï¼Œå¤±è´¥{fail_count}ä¸ª')
                
                # å¤„ç†æ™®é€šç¾¤å‘ä»»åŠ¡
                else:
                    log_id = task.get('log_id')
                    message_content = task.get('message_content', '')
                    group_links = task.get('group_links', [])
                    
                    print(f'å¼€å§‹ç¾¤å‘åˆ°ç¾¤ç»„: {len(group_links)}ä¸ªç¾¤')
                    success_count = 0
                    fail_count = 0
                    
                    for group_link in group_links:
                        try:
                            # ä»ç¾¤é“¾æ¥æå–ç¾¤IDæˆ–ç”¨æˆ·å
                            if group_link.startswith('https://t.me/'):
                                group_username = group_link.replace('https://t.me/', '')
                            elif group_link.startswith('@'):
                                group_username = group_link
                            else:
                                group_username = '@' + group_link
                            
                            await bot.send_message(group_username, message_content)
                            success_count += 1
                            await asyncio.sleep(0.5)
                        except Exception as e:
                            fail_count += 1
                            print(f'å‘é€åˆ°ç¾¤ç»„å¤±è´¥ {group_link}: {e}')
                    
                    # æ›´æ–°æ—¥å¿—çŠ¶æ€
                    if log_id:
                        conn = get_db_conn()
                        c = conn.cursor()
                        c.execute('''
                            UPDATE broadcast_logs 
                            SET status = 'completed', 
                                sent_count = ?, 
                                failed_count = ?
                            WHERE id = ?
                        ''', (success_count, fail_count, log_id))
                        conn.commit()
                        conn.close()
                    
                    print(f'ç¾¤ç»„ç¾¤å‘å®Œæˆ: æˆåŠŸå‘é€åˆ°{success_count}ä¸ªç¾¤ï¼Œå¤±è´¥{fail_count}ä¸ª')
            
            await asyncio.sleep(1)  # æ¯ç§’æ£€æŸ¥ä¸€æ¬¡
        except Exception as e:
            print(f'ç¾¤å‘ä»»åŠ¡å¤„ç†å¼‚å¸¸: {e}')
            await asyncio.sleep(5)

async def check_member_status_task():
    """å®šæœŸæ£€æŸ¥ä¼šå‘˜çŠ¶æ€ï¼ˆæ‹‰ç¾¤ã€ç¾¤ç®¡ã€åŠ ç¾¤ï¼‰"""
    while True:
        try:
            await asyncio.sleep(60)  # æ¯1åˆ†é’Ÿæ£€æŸ¥ä¸€æ¬¡
            print("[çŠ¶æ€æ£€æµ‹] å¼€å§‹æ£€æŸ¥ä¼šå‘˜çŠ¶æ€...")
            
            conn = get_db_conn()
            c = conn.cursor()
            
            # è·å–ç³»ç»Ÿé…ç½®
            config = get_system_config()
            level_count = int(config.get('level_count', 10))
            
            # è·å–æ‰€æœ‰æœ‰ç¾¤é“¾æ¥çš„ä¼šå‘˜
            c.execute("""
                SELECT telegram_id, group_link 
                FROM members 
                WHERE group_link IS NOT NULL AND group_link != ''
            """)
            members = c.fetchall()
            
            for telegram_id, group_link in members:
                try:
                    # ã€æ ¸å¿ƒä¿®å¤ã€‘å…ˆæŸ¥è¯¢å½“å‰çŠ¶æ€ï¼Œå¦‚æœ is_joined_upline å·²ç»æ˜¯ 1ï¼Œåˆ™æ°¸ä¹…è·³è¿‡æ£€æµ‹
                    c.execute("SELECT is_joined_upline FROM members WHERE telegram_id = ?", (telegram_id,))
                    current_status = c.fetchone()
                    current_is_joined_upline = current_status[0] if current_status else 0
                    
                    # ã€æ ¸å¿ƒä¿®å¤ã€‘å¦‚æœå·²ç»å®ŒæˆåŠ ç¾¤ä»»åŠ¡ï¼Œæ°¸ä¹…è·³è¿‡æ£€æµ‹ï¼ˆæ°¸ä¹…é”æ­»ï¼‰
                    if current_is_joined_upline == 1:
                        print(f"[çŠ¶æ€æ£€æµ‹] ä¼šå‘˜ {telegram_id} å·²å®ŒæˆåŠ ç¾¤ä»»åŠ¡ï¼ˆæ°¸ä¹…é”å®šï¼‰ï¼Œè·³è¿‡æ£€æµ‹")
                        continue
                    
                    # æå–ç¾¤ç»„ç”¨æˆ·åæˆ–ID
                    if group_link.startswith('https://t.me/'):
                        group_username = group_link.replace('https://t.me/', '').split('/')[0].split('?')[0]
                    elif group_link.startswith('@'):
                        group_username = group_link[1:]
                    else:
                        group_username = group_link
                    
                    # è·³è¿‡ç§æœ‰ç¾¤é“¾æ¥
                    if group_username.startswith('+'):
                        continue
                    
                    # æ£€æŸ¥1ï¼šæ˜¯å¦å·²æ‹‰ç¾¤ï¼ˆç¾¤é“¾æ¥æ˜¯å¦æœ‰æ•ˆï¼‰
                    is_group_bound = 0
                    is_bot_admin = 0
                    is_joined_upline = 0
                    
                    try:
                        # è·å–ç¾¤ç»„ä¿¡æ¯
                        chat = await bot.get_entity(group_username)
                        is_group_bound = 1  # ç¾¤é“¾æ¥æœ‰æ•ˆ
                        
                        # æ£€æŸ¥2ï¼šæœºå™¨äººæ˜¯å¦æ˜¯ç¾¤ç®¡ç†å‘˜
                        try:
                            me = await bot.get_me()
                            participants = await bot.get_participants(chat, filter=ChannelParticipantsAdmins())
                            admin_ids = [p.id for p in participants]
                            if me.id in admin_ids:
                                is_bot_admin = 1
                        except Exception as admin_err:
                            print(f"[çŠ¶æ€æ£€æµ‹] æ£€æŸ¥ç¾¤ç®¡å¤±è´¥ {group_username}: {admin_err}")
                        
                        # ã€æ ¸å¿ƒä¿®å¤ã€‘æ£€æŸ¥3ï¼šç”¨æˆ·æ˜¯å¦åŠ å…¥äº†æ‰€æœ‰10å±‚ä¸Šçº§çš„ç¾¤ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
                        # ä½¿ç”¨ get_upline_chain è·å–å®Œæ•´çš„10å±‚ä¸Šçº§é“¾
                        from core_functions import get_upline_chain
                        upline_chain = get_upline_chain(telegram_id, level_count)
                        
                        # æ”¶é›†æ‰€æœ‰æœ‰ç¾¤é“¾æ¥çš„ä¸Šçº§ç¾¤ï¼ˆæ’é™¤æ¡æ¼è´¦å·ï¼‰
                        upline_groups_to_check = []
                        for item in upline_chain:
                            if item.get('is_fallback'):
                                continue  # è·³è¿‡æ¡æ¼è´¦å·
                            
                            upline_id = item['id']
                            c.execute("SELECT group_link FROM members WHERE telegram_id = ?", (upline_id,))
                            upline_row = c.fetchone()
                            if upline_row and upline_row[0]:
                                upline_group_link = upline_row[0]
                                # æå–ç¾¤ç”¨æˆ·å
                                if upline_group_link.startswith('https://t.me/'):
                                    upline_group_username = upline_group_link.replace('https://t.me/', '').split('/')[0].split('?')[0]
                                elif upline_group_link.startswith('@'):
                                    upline_group_username = upline_group_link[1:]
                                else:
                                    upline_group_username = upline_group_link
                                
                                # è·³è¿‡ç§æœ‰ç¾¤é“¾æ¥
                                if not upline_group_username.startswith('+'):
                                    upline_groups_to_check.append({
                                        'level': item['level'],
                                        'username': upline_group_username,
                                        'upline_id': upline_id
                                    })
                        
                        # åªæœ‰å½“æ‰€æœ‰ä¸Šçº§ç¾¤éƒ½æ£€æŸ¥é€šè¿‡æ—¶ï¼Œæ‰æ ‡è®°ä¸ºå®Œæˆ
                        if upline_groups_to_check:
                            all_joined = True
                            for group_info in upline_groups_to_check:
                                try:
                                    upline_chat = await bot.get_entity(group_info['username'])
                                    participants = await bot.get_participants(upline_chat, limit=1000)
                                    member_ids = [p.id for p in participants]
                                    if telegram_id not in member_ids:
                                        all_joined = False
                                        print(f"[çŠ¶æ€æ£€æµ‹] ä¼šå‘˜ {telegram_id} æœªåŠ å…¥ç¬¬{group_info['level']}å±‚ä¸Šçº§ç¾¤ ({group_info['username']})")
                                        break
                                except Exception as upline_err:
                                    print(f"[çŠ¶æ€æ£€æµ‹] æ£€æŸ¥ç¬¬{group_info['level']}å±‚ä¸Šçº§ç¾¤å¤±è´¥ {group_info['username']}: {upline_err}")
                                    all_joined = False
                                    break
                            
                            if all_joined:
                                is_joined_upline = 1
                                print(f"[çŠ¶æ€æ£€æµ‹] ä¼šå‘˜ {telegram_id} å·²åŠ å…¥æ‰€æœ‰ {len(upline_groups_to_check)} ä¸ªä¸Šçº§ç¾¤")
                        else:
                            # å¦‚æœæ²¡æœ‰éœ€è¦æ£€æŸ¥çš„ä¸Šçº§ç¾¤ï¼Œé»˜è®¤æ ‡è®°ä¸ºå®Œæˆï¼ˆå¯èƒ½æ˜¯é¡¶å±‚ç”¨æˆ·ï¼‰
                            is_joined_upline = 1
                            print(f"[çŠ¶æ€æ£€æµ‹] ä¼šå‘˜ {telegram_id} æ²¡æœ‰éœ€è¦åŠ å…¥çš„ä¸Šçº§ç¾¤")
                    
                    except Exception as e:
                        print(f"[çŠ¶æ€æ£€æµ‹] æ£€æŸ¥ç¾¤ç»„å¤±è´¥ {group_username}: {e}")
                    
                    # æ›´æ–°æ•°æ®åº“ï¼ˆis_joined_upline ä¿æŒåŸå€¼å¦‚æœå·²ç»æ˜¯1ï¼‰
                    # å¦‚æœæ£€æµ‹åˆ°å·²å®Œæˆï¼Œæ›´æ–°ä¸º1ï¼›å¦‚æœæ£€æµ‹å¤±è´¥ä½†åŸå€¼æ˜¯1ï¼Œä¿æŒ1ä¸å˜
                    final_is_joined_upline = max(is_joined_upline, current_is_joined_upline)
                    
                    c.execute("""
                        UPDATE members 
                        SET is_group_bound = ?, is_bot_admin = ?, is_joined_upline = ?
                        WHERE telegram_id = ?
                    """, (is_group_bound, is_bot_admin, final_is_joined_upline, telegram_id))
                    
                    await asyncio.sleep(1)  # é¿å…é¢‘ç‡é™åˆ¶
                    
                except Exception as member_err:
                    print(f"[çŠ¶æ€æ£€æµ‹] å¤„ç†ä¼šå‘˜ {telegram_id} å¤±è´¥: {member_err}")
                    continue
            
            conn.commit()
            conn.close()
            print(f"[çŠ¶æ€æ£€æµ‹] å®Œæˆæ£€æŸ¥ {len(members)} ä¸ªä¼šå‘˜")
            
        except Exception as e:
            print(f"[çŠ¶æ€æ£€æµ‹] ä»»åŠ¡é”™è¯¯: {e}")
            await asyncio.sleep(60)

def run_bot():
    """Bot å¯åŠ¨å…¥å£"""
    print("ğŸš€ Telegram Bot å¯åŠ¨ä¸­...")
    
    # 1. å¯åŠ¨é€šçŸ¥é˜Ÿåˆ—å¤„ç†ï¼ˆæç°/å……å€¼é€šçŸ¥ï¼‰
    bot.loop.create_task(process_notify_queue())
    print("âœ… é€šçŸ¥é˜Ÿåˆ—å¤„ç†å™¨å·²å¯åŠ¨")
    
    # 2. å¯åŠ¨å®šæ—¶ç¾¤å‘ï¼ˆä»åŸæœ‰ main.py è¿ç§»ï¼‰
    bot.loop.create_task(auto_broadcast_timer())
    print("âœ… å®šæ—¶è‡ªåŠ¨ç¾¤å‘å·²å¯åŠ¨")
    
    # 3. å¯åŠ¨ä¼šå‘˜çŠ¶æ€æ£€æµ‹ï¼ˆä»åŸæœ‰ main.py è¿ç§»ï¼‰
    bot.loop.create_task(check_member_status_task())
    print("âœ… ä¼šå‘˜çŠ¶æ€æ£€æµ‹å·²å¯åŠ¨")
    
    # 4. å¯åŠ¨ç¾¤å‘é˜Ÿåˆ—å¤„ç†ï¼ˆæ•°æ®åº“é˜Ÿåˆ—ï¼‰
    bot.loop.create_task(process_broadcast_queue())
    print("âœ… ç¾¤å‘é˜Ÿåˆ—å¤„ç†å™¨å·²å¯åŠ¨")
    
    # 5. å¯åŠ¨å†…å­˜ç¾¤å‘é˜Ÿåˆ—å¤„ç†ï¼ˆWebåå°ç¾¤å‘ï¼‰
    bot.loop.create_task(process_broadcasts())
    print("âœ… å†…å­˜ç¾¤å‘é˜Ÿåˆ—å¤„ç†å™¨å·²å¯åŠ¨")

    # 6. å¯åŠ¨æ¥è‡ª Web çš„å……å€¼å¤„ç†é˜Ÿåˆ—ï¼ˆçº¿ç¨‹å®‰å…¨é˜Ÿåˆ—ï¼Œç”± Web å°†é¡¹ push åˆ°æ­¤åˆ—è¡¨ï¼‰
    async def _process_recharge_queue_worker():
        while True:
            try:
                # Debug: current queue length
                try:
                    qlen = len(process_recharge_queue)
                except Exception:
                    qlen = 0
                if qlen:
                    print(f"[process_recharge_queue] é˜Ÿåˆ—é•¿åº¦: {qlen}")
                    item = process_recharge_queue.pop(0)
                    try:
                        member_id = item.get('member_id')
                        amount = item.get('amount', 0)
                        is_vip_order = item.get('is_vip_order', False)
                        print(f"[process_recharge_queue] å¼€å§‹å¤„ç†: member_id={member_id}, amount={amount}, is_vip_order={is_vip_order}")
                        await process_recharge(member_id, amount, is_vip_order=is_vip_order)
                        print(f"[process_recharge_queue] å¤„ç†å®Œæˆ: member_id={member_id}, amount={amount}, is_vip_order={is_vip_order}")
                    except Exception as e:
                        import traceback
                        print(f"[process_recharge_queue] å¤„ç†å¤±è´¥: {e}")
                        traceback.print_exc()
                await asyncio.sleep(1)
            except Exception as e:
                import traceback
                print(f"[process_recharge_queue] é”™è¯¯: {e}")
                traceback.print_exc()
                await asyncio.sleep(5)

    bot.loop.create_task(_process_recharge_queue_worker())
    print("âœ… Web -> Bot å……å€¼é˜Ÿåˆ—å¤„ç†å™¨å·²å¯åŠ¨")
    
    print("=" * 60)
    print("âœ… æ‰€æœ‰åå°ä»»åŠ¡å·²æŒ‚è½½")
    print("âœ… Telegram Bot å·²å¯åŠ¨ï¼Œç­‰å¾…æ¶ˆæ¯...")
    print("=" * 60)
    bot.run_until_disconnected()

# å¯¼å‡ºbotå®ä¾‹ä¾›å…¶ä»–æ¨¡å—ä½¿ç”¨
__all__ = [
    'bot', 
    'process_vip_upgrade', 
    'process_recharge', 
    'admin_manual_vip_handler', 
    'get_main_account_id', 
    'run_bot', 
    'pending_broadcasts', 
    'notify_queue',
    # åå°ä»»åŠ¡ï¼ˆä¾›è°ƒè¯•ä½¿ç”¨ï¼‰
    'auto_broadcast_timer',
    'process_broadcast_queue',
    'process_broadcasts',
    'check_member_status_task',
    'process_notify_queue'
]

-e 

--- File: ./app/run.py ---
"""
å¯åŠ¨å…¥å£ - ç»Ÿä¸€å¯åŠ¨Botå’ŒWebåå°
"""
import threading
from database import init_db, sync_member_groups_from_members
from bot_logic import run_bot

def main():
    print("=" * 60)
    print("ğŸ¤– è£‚å˜æ¨å¹¿æœºå™¨äººç³»ç»Ÿå¯åŠ¨ä¸­...")
    print("=" * 60)
    print()
    
    # 1. åˆå§‹åŒ–æ•°æ®åº“
    print("ğŸ“Š åˆå§‹åŒ–æ•°æ®åº“...")
    init_db()
    print("âœ… æ•°æ®åº“åˆå§‹åŒ–å®Œæˆ")
    
    # åŒæ­¥å·²æœ‰ä¼šå‘˜ç¾¤é“¾æ¥åˆ° member_groups
    print("ğŸ”„ åŒæ­¥ä¼šå‘˜ç¾¤ç»„æ•°æ®...")
    try:
        sync_member_groups_from_members()
        print("âœ… ä¼šå‘˜ç¾¤ç»„æ•°æ®åŒæ­¥å®Œæˆ")
    except Exception as e:
        print(f"âš ï¸ ä¼šå‘˜ç¾¤ç»„æ•°æ®åŒæ­¥å¤±è´¥: {e}")
    print()
    
    # 2. å¯åŠ¨ Web åå° (åœ¨ç‹¬ç«‹çº¿ç¨‹ä¸­)
    print("ğŸŒ å¯åŠ¨Webç®¡ç†åå°...")
    try:
        from web_app import run_web
        web_thread = threading.Thread(target=run_web, daemon=True)
        web_thread.start()
        print("âœ… Webç®¡ç†åå°å·²å¯åŠ¨ (ç«¯å£: 5051)")
    except Exception as e:
        print(f"âš ï¸ Webåå°å¯åŠ¨å¤±è´¥: {e}")
        print("ç»§ç»­å¯åŠ¨Bot...")
    print()
    
    # 3. å¯åŠ¨ Bot (ä¸»çº¿ç¨‹)
    print("ğŸš€ Telegramæœºå™¨äººå¯åŠ¨ä¸­...")
    print()
    print("=" * 60)
    print("ğŸ“± è®¿é—®åœ°å€ï¼š")
    print("   Webåå°: http://localhost:5051")
    print("=" * 60)
    print()
    print("ğŸ’¡ æç¤ºï¼š")
    print("   - æ‰€æœ‰æœåŠ¡æ­£åœ¨è¿è¡Œä¸­...")
    print("   - æŒ‰ Ctrl+C åœæ­¢æ‰€æœ‰æœåŠ¡")
    print("=" * 60)
    print()
    
    try:
        run_bot()
    except KeyboardInterrupt:
        print("\nåœæ­¢æœåŠ¡...")
    except Exception as e:
        print(f"âŒ å¯åŠ¨å¤±è´¥: {e}")
        import traceback
        traceback.print_exc()

if __name__ == '__main__':
    main()

-e 

--- File: ./app/web_app.py ---
"""
Webåå°å±‚ - ç»Ÿä¸€ç®¡ç†æ‰€æœ‰Flaskè·¯ç”±
æ‰€æœ‰è·¯ç”±éƒ½åœ¨æ­¤æ–‡ä»¶ä¸­ç›´æ¥å®šä¹‰ï¼Œä¸å†ä¾èµ–å¤–éƒ¨è·¯ç”±æ–‡ä»¶
"""
import os
import uuid
from datetime import datetime, timedelta
from flask import Flask, render_template, jsonify, request, redirect, url_for
from flask_login import LoginManager, login_required, logout_user, current_user
from werkzeug.security import generate_password_hash, check_password_hash

from database import DB, WebDB, AdminUser, get_system_config, get_db_conn, get_cn_time
from config import UPLOAD_DIR, BASE_DIR

# å»¶è¿Ÿå¯¼å…¥botï¼Œé¿å…å¾ªç¯ä¾èµ–
try:
    from bot_logic import bot, process_recharge, admin_manual_vip_handler, notify_queue, pending_broadcasts
except ImportError:
    # å¦‚æœå¯¼å…¥å¤±è´¥ï¼Œè®¾ç½®ä¸ºNoneï¼Œåç»­ä½¿ç”¨æ—¶å†å¯¼å…¥
    bot = None
    process_recharge = None
    admin_manual_vip_handler = None
    notify_queue = []
    # æ³¨æ„ï¼šè¿™é‡Œä¸åº”è¯¥é‡æ–°èµ‹å€¼pending_broadcastsï¼Œå¦åˆ™ä¼šè¦†ç›–å¯¼å…¥çš„å˜é‡
    if 'pending_broadcasts' not in globals():
        pending_broadcasts = []

# åˆå§‹åŒ–Flask
template_dir = os.path.join(os.path.dirname(os.path.dirname(__file__)), 'templates')
static_dir = os.path.join(os.path.dirname(os.path.dirname(__file__)), 'static')
app = Flask(__name__, template_folder=template_dir, static_folder=static_dir)
app.secret_key = 'fission-bot-secret-key-2025'
app.config['REMEMBER_COOKIE_DURATION'] = timedelta(days=90)
app.config['TEMPLATES_AUTO_RELOAD'] = True
app.jinja_env.auto_reload = True

login_manager = LoginManager()
login_manager.init_app(app)
login_manager.login_view = 'login'

@login_manager.user_loader
def load_user(user_id):
    return WebDB.get_user_by_id(int(user_id))

# For API routes, return JSON 401 instead of redirecting to login page (prevents HTML responses on fetch)
@app.before_request
def api_require_login_for_api():
    try:
        # ã€æ ¸å¿ƒä¿®å¤ã€‘å®šä¹‰ç™½åå•ï¼Œå…è®¸æ”¯ä»˜å›è°ƒä¸ç™»å½•ä¹Ÿèƒ½è®¿é—®
        whitelist = [
            '/api/payment/notify',     # æ”¯ä»˜å›è°ƒ
            '/api/payment/test',       # æµ‹è¯•æ¥å£
            '/login'                   # ç™»å½•æ¥å£
        ]

        # å¦‚æœè¯·æ±‚è·¯å¾„å®Œå…¨åŒ¹é…ç™½åå•ï¼Œç›´æ¥æ”¾è¡Œ
        if request.path in whitelist:
            return None

        # å¦‚æœæ˜¯APIè¯·æ±‚ä¸”ä¸åœ¨ç™½åå•å†…ï¼Œæ‰æ£€æŸ¥ç™»å½•çŠ¶æ€
        if request.path.startswith('/api/') and not current_user.is_authenticated:
            return jsonify({'success': False, 'message': 'æœªç™»å½•'}), 401
    except Exception:
        pass

# ==================== æ”¯ä»˜ç³»ç»Ÿé…ç½® ====================
PAYMENT_CONFIG = {
    'api_url': 'https://usdt.qxzy7888.org/pay/',
    'partner_id': '15',
    'key': '5c9dd0b054b184f964',
    'notify_url': 'http://154.201.68.178:5051/api/payment/notify',
    'return_url': 'http://154.201.68.178:5051/payment/success',
    'pay_type': 'trc20',
    'version': '1.0'
}

# æ·»åŠ ä¸€ä¸ªç®€å•çš„æµ‹è¯•ç«¯ç‚¹æ¥éªŒè¯å›è°ƒURLæ˜¯å¦å¯è®¿é—®
@app.route('/api/payment/test', methods=['GET'])
def test_payment_callback():
    """æµ‹è¯•æ”¯ä»˜å›è°ƒURLæ˜¯å¦å¯è®¿é—®"""
    return jsonify({
        'status': 'ok',
        'message': 'æ”¯ä»˜å›è°ƒURLå¯æ­£å¸¸è®¿é—®',
        'timestamp': get_cn_time(),
        'config': {
            'notify_url': PAYMENT_CONFIG.get('notify_url'),
            'has_key': bool(PAYMENT_CONFIG.get('key'))
        }
    })

import hashlib
import requests as req

def process_vip_upgrade_sync(telegram_id, vip_price, config, deduct_balance=True):
    """åŒæ­¥ç‰ˆæœ¬çš„VIPå¼€é€šå¤„ç†ï¼ˆç”¨äºæ”¯ä»˜å›è°ƒï¼‰"""
    try:
        from bot_logic import DB, distribute_vip_rewards, get_system_config

        member = DB.get_member(telegram_id)
        if not member:
            print(f"[VIPå¼€é€šåŒæ­¥] ç”¨æˆ·ä¸å­˜åœ¨: {telegram_id}")
            return False, "ç”¨æˆ·ä¸å­˜åœ¨"

        if member.get('is_vip'):
            print(f"[VIPå¼€é€šåŒæ­¥] ç”¨æˆ·å·²æ˜¯VIP: {telegram_id}")
            return False, "ç”¨æˆ·å·²æ˜¯VIP"

        print(f"[VIPå¼€é€šåŒæ­¥] ç”¨æˆ·ä¿¡æ¯: telegram_id={telegram_id}, å½“å‰ä½™é¢={member.get('balance', 0)}, VIPä»·æ ¼={vip_price}, éœ€è¦æ‰£è´¹={deduct_balance}")

        # æ£€æŸ¥ä½™é¢ï¼ˆå¦‚æœéœ€è¦æ‰£è´¹ï¼‰
        if deduct_balance:
            if member.get('balance', 0) < vip_price:
                print(f"[VIPå¼€é€šåŒæ­¥] ä½™é¢ä¸è¶³: éœ€è¦{vip_price}, å½“å‰{member.get('balance', 0)}")
                return False, "ä½™é¢ä¸è¶³"
            # æ‰£é™¤VIPè´¹ç”¨
            new_balance = member['balance'] - vip_price
            print(f"[VIPå¼€é€šåŒæ­¥] æ‰£è´¹å‰ä½™é¢: {member['balance']}, æ‰£è´¹åä½™é¢: {new_balance}")
            DB.update_member(telegram_id, balance=new_balance, is_vip=1, vip_time=get_cn_time())
            print(f"[VIPå¼€é€šåŒæ­¥] æ•°æ®åº“æ›´æ–°å®Œæˆ: balance={new_balance}, is_vip=1")
        else:
            # ä¸æ‰£è´¹ï¼Œç›´æ¥å¼€é€š
            DB.update_member(telegram_id, is_vip=1, vip_time=get_cn_time())
            print(f"[VIPå¼€é€šåŒæ­¥] ä¸æ‰£è´¹å¼€é€šVIPå®Œæˆ")

        # åˆ†å‘VIPå¥–åŠ±
        print(f"[VIPå¼€é€šåŒæ­¥] å¼€å§‹åˆ†å‘å¥–åŠ±")
        distribute_vip_rewards(telegram_id, vip_price)
        print(f"[VIPå¼€é€šåŒæ­¥] å¥–åŠ±åˆ†å‘å®Œæˆ")

        return True, {'new_balance': member.get('balance', 0) if not deduct_balance else new_balance}
    except Exception as e:
        print(f"[VIPå¼€é€šåŒæ­¥] é”™è¯¯: {e}")
        import traceback
        traceback.print_exc()
        return False, str(e)

def generate_payment_sign(params, key):
    """ç”Ÿæˆæ”¯ä»˜ç­¾å"""
    sorted_params = sorted([(k, v) for k, v in params.items() if v is not None and v != ''])
    sign_str = '&'.join([f'{k}={v}' for k, v in sorted_params])
    sign_str += f'&key={key}'
    return hashlib.md5(sign_str.encode()).hexdigest().upper()

# ==================== ç™»å½•è®¤è¯ ====================

@app.route('/login', methods=['GET', 'POST'])
def login():
    if request.method == 'POST':
        data = request.json
        username = data.get('username')
        password = data.get('password')
        remember = data.get('remember', False)
        
        user = WebDB.get_user_by_username(username)
        if user and check_password_hash(user.password_hash, password):
            from flask_login import login_user
            login_user(user, remember=remember)
            return jsonify({'success': True, 'message': 'ç™»å½•æˆåŠŸ'})
        
        return jsonify({'success': False, 'message': 'ç”¨æˆ·åæˆ–å¯†ç é”™è¯¯'}), 401
        
    if current_user.is_authenticated:
        return redirect(url_for('index'))
    return render_template('login.html')

@app.route('/logout')
@login_required
def logout():
    logout_user()
    return redirect(url_for('login'))

@app.route('/api/change_password', methods=['POST'])
@login_required
def api_change_password():
    data = request.json
    old_password = data.get('old_password')
    new_password = data.get('new_password')
    
    user = WebDB.get_user_by_id(current_user.id)
    
    if not check_password_hash(user.password_hash, old_password):
        return jsonify({'success': False, 'message': 'æ—§å¯†ç é”™è¯¯'}), 400
        
    WebDB.update_password(user.id, new_password)
    return jsonify({'success': True, 'message': 'å¯†ç ä¿®æ”¹æˆåŠŸ'})

# ==================== åŸºç¡€é¡µé¢è·¯ç”± ====================

@app.route('/')
@login_required
def index():
    """ä¸»é¡µ - æ•°æ®ç»Ÿè®¡"""
    return render_template('dashboard.html', active_page='dashboard')

@app.route('/members')
@login_required
def members_page():
    """ä¼šå‘˜ç®¡ç†é¡µé¢"""
    return render_template('members.html', active_page='members')

@app.route('/settings')
@login_required
def settings_page():
    """è®¾ç½®é¡µé¢"""
    return render_template('settings.html', active_page='settings')

@app.route('/statistics')
@login_required
def statistics_page():
    """ç»Ÿè®¡æŠ¥è¡¨é¡µé¢"""
    return render_template('statistics.html', active_page='statistics')

@app.route('/withdrawals')
@login_required
def withdrawals_page():
    """æç°ç®¡ç†é¡µé¢"""
    return render_template('withdrawals.html', active_page='withdrawals')

@app.route('/recharges')
@login_required
def recharges():
    """å……å€¼è®¢å•ç®¡ç†é¡µé¢"""
    return render_template('recharges.html')

@app.route('/earnings')
@login_required
def earnings_page():
    """æ”¶ç›Šè®°å½•ç®¡ç†é¡µé¢"""
    return render_template('earnings.html', active_page='earnings')

@app.route('/resources')
@login_required
def resources_page():
    """è¡Œä¸šèµ„æºç®¡ç†é¡µé¢"""
    return render_template('resources.html', active_page='resources')

@app.route('/customer-service')
@login_required
def customer_service_page():
    """å®¢æœç®¡ç†é¡µé¢"""
    return render_template('customer_service.html', active_page='customer_service')

@app.route('/broadcast')
@login_required
def broadcast_page():
    """ç¾¤å‘ç®¡ç†é¡µé¢"""
    return render_template('broadcast.html', active_page='broadcast')

@app.route('/bot-settings')
@login_required
def bot_settings_page():
    """æœºå™¨äººè®¾ç½®é¡µé¢"""
    return render_template('bot_settings.html', active_page='bot_settings')

@app.route('/level-settings')
@login_required
def level_settings_page():
    """å±‚çº§è®¾ç½®é¡µé¢"""
    return render_template('level_settings.html', active_page='level_settings')

@app.route('/member-groups')
@login_required
def member_groups_page():
    """ä¼šå‘˜ç¾¤ç®¡ç†é¡µé¢"""
    return render_template('member_groups.html', active_page='member_groups')

@app.route('/fallback-accounts')
@login_required
def fallback_accounts_page():
    """æ¡æ¼è´¦å·ç®¡ç†é¡µé¢"""
    return render_template('fallback_accounts.html', active_page='fallback_accounts')

@app.route('/team-graph')
@login_required
def team_graph_index():
    """å›¢é˜Ÿå›¾è°±å…¥å£é¡µ"""
    return render_template('team_graph_all.html', active_page='team_graph')

@app.route('/team-graph/<int:telegram_id>')
@login_required
def team_graph_page(telegram_id):
    """å›¢é˜Ÿå›¾è°±è¯¦æƒ…é¡µé¢"""
    return render_template('team_graph.html', telegram_id=telegram_id, active_page='team_graph')

# ==================== æ”¯ä»˜å›è°ƒ ====================

@app.route('/api/payment/notify', methods=['POST'])
def payment_notify():
    global notify_queue
    try:
        # 1. è·å–å’Œè§£ææ•°æ®
        raw_data = request.form.to_dict()
        if not raw_data:
            raw_data = request.get_json() or {}

        print(f'[æ”¯ä»˜å›è°ƒ] æ”¶åˆ°æ•°æ®: {raw_data}')

        # 2. ç­¾åéªŒè¯ (æ’é™¤ sign, remark, ç©ºå€¼)
        sign_received = ''
        filtered_params = {}
        for k, v in raw_data.items():
            val_str = str(v)
            if k.lower() == 'sign':
                sign_received = val_str
                continue
            if k.lower() == 'remark':
                continue
            if val_str == '':
                continue
            filtered_params[k] = val_str

        my_key = PAYMENT_CONFIG.get('key', '')
        sorted_keys = sorted(filtered_params.keys())
        sign_str = '&'.join([f'{k}={filtered_params[k]}' for k in sorted_keys])
        sign_str_with_key = f"{sign_str}&key={my_key}"
        calc_sign = hashlib.md5(sign_str_with_key.encode('utf-8')).hexdigest().upper()

        if sign_received.upper() != calc_sign:
            print('[æ”¯ä»˜å›è°ƒ] ç­¾åéªŒè¯å¤±è´¥')
            return 'fail'
        
        # 3. ä¸šåŠ¡å¤„ç†
        status = str(raw_data.get('status'))
        out_trade_no = raw_data.get('out_trade_no')
        amount = float(raw_data.get('amount', 0))

        # status=4 ä»£è¡¨æˆåŠŸ
        if status == '4':
            conn = get_db_conn()
            c = conn.cursor()

            # è§£æç”¨æˆ·ID
            telegram_id = 0
            if out_trade_no and out_trade_no.startswith('RCH_'):
                parts = out_trade_no.split('_')
                if len(parts) >= 2:
                    telegram_id = int(parts[1])

            # æŸ¥é‡
            c.execute('SELECT status, remark FROM recharge_records WHERE order_id = ?', (out_trade_no,))
            existing = c.fetchone()

            if existing and existing[0] != 'completed':
                # A. æ ‡è®°è®¢å•å®Œæˆ
                c.execute('UPDATE recharge_records SET status = ? WHERE order_id = ?', ('completed', out_trade_no))

                # B. å¢åŠ ç”¨æˆ·ä½™é¢ (åªåŠ ä½™é¢ï¼Œåƒä¸‡åˆ«åœ¨è¿™é‡Œæ‰£è´¹å¼€VIPï¼)
                c.execute('UPDATE members SET balance = balance + ? WHERE telegram_id = ?', (amount, telegram_id))
                conn.commit()

                # C. åˆ¤æ–­æ˜¯å¦ä¸º VIP è®¢å•
                # é€»è¾‘ï¼šå¤‡æ³¨æ˜¯"å¼€é€š"ï¼Œæˆ–è€…å……å€¼é‡‘é¢ >= VIPä»·æ ¼
                is_vip_order = False
                if existing[1] == 'å¼€é€š':
                    is_vip_order = True
                else:
                    # è¡¥å……æ£€æµ‹ï¼šå¦‚æœæ²¡å¤‡æ³¨ï¼Œä½†é‡‘é¢è¶³å¤Ÿï¼Œä¹Ÿè§†ä¸ºVIPæ„å‘(å¯é€‰ï¼Œæ ¹æ®æ‚¨çš„éœ€æ±‚)
                    config = get_system_config()
                    vip_price = float(config.get('vip_price', 10))
                    if amount >= vip_price:
                        is_vip_order = True

                print(f"[æ”¯ä»˜å›è°ƒ] è®¢å• {out_trade_no} å¤„ç†å®Œæ¯•ï¼Œä½™é¢å·²åŠ ã€‚VIPè®¢å•æ ‡è®°: {is_vip_order}")

                # D. ã€å…³é”®ã€‘æ¨å…¥é˜Ÿåˆ—ï¼Œè®© Bot çº¿ç¨‹å»å¤„ç†æ‰£è´¹ã€å¼€é€šå’Œåˆ†çº¢
                # è¿™æ ·å¯ä»¥é¿å… Web çº¿ç¨‹å’Œ Bot çº¿ç¨‹çš„çŠ¶æ€å†²çª
                try:
                    import bot_logic
                    if hasattr(bot_logic, 'process_recharge_queue'):
                        bot_logic.process_recharge_queue.append({
                            'member_id': telegram_id,
                            'amount': amount,
                            'is_vip_order': is_vip_order
                        })
                        print(f"[æ”¯ä»˜å›è°ƒ] å·²å°†ä»»åŠ¡æ¨å…¥ Bot é˜Ÿåˆ—ï¼Œç­‰å¾… Bot å¤„ç† VIP é€»è¾‘")
                except Exception as q_err:
                    print(f"[æ”¯ä»˜å›è°ƒ] æ¨é€é˜Ÿåˆ—å¤±è´¥: {q_err}")

                conn.close()
                return 'success'
        
        return 'success'
    except Exception as e:
        print(f'[æ”¯ä»˜å›è°ƒ] å¼‚å¸¸: {e}')
        import traceback
        traceback.print_exc()
        return 'fail'

@app.route('/payment/success')
def payment_success():
    return '<html><head><meta charset=utf-8><title>æ”¯ä»˜æˆåŠŸ</title></head><body style=text-align:center;padding:50px><h1>æ”¯ä»˜æˆåŠŸ</h1><p>å……å€¼è®¢å•å·²æäº¤</p></body></html>'

# ==================== å†…éƒ¨API ====================

@app.route('/internal/notify', methods=['POST'])
def internal_notify():
    """å†…éƒ¨APIï¼šå‘é€é€šçŸ¥ç»™ç”¨æˆ·"""
    try:
        data = request.json
        member_id = data['member_id']
        message = data['message']
        notify_queue.append({'member_id': member_id, 'message': message})
        print(f"âœ… é€šçŸ¥å·²åŠ å…¥é˜Ÿåˆ—: ç”¨æˆ·{member_id}")
        return jsonify({'success': True})
    except Exception as e:
        print(f"å†…éƒ¨APIå¤±è´¥: {e}")
        return jsonify({'success': False, 'error': str(e)})

# ==================== å…³é”®APIè·¯ç”± =====================

@app.route('/api/members')
@login_required
def api_members():
    """è·å–ä¼šå‘˜åˆ—è¡¨API"""
    page = request.args.get('page', 1, type=int)
    per_page = request.args.get('per_page', 20, type=int)
    search = request.args.get('search', '', type=str)
    filter_type = request.args.get('filter', 'all', type=str)
    
    # ä½¿ç”¨WebDBçš„å®Œæ•´æ–¹æ³•ï¼ˆéœ€è¦ä»main.pyè¿ç§»å®Œæ•´å®ç°ï¼‰
    # è¿™é‡Œç®€åŒ–å¤„ç†ï¼Œå®é™…åº”è¯¥è°ƒç”¨å®Œæ•´çš„ get_all_members
    data = WebDB.get_all_members(page, per_page, search, filter_type)
    return jsonify(data)

@app.route('/api/member/<int:telegram_id>')
@login_required
def api_member_detail(telegram_id):
    """è·å–ä¼šå‘˜è¯¦æƒ…API"""
    member = WebDB.get_member_detail(telegram_id)
    if member:
        # è¿”å›ä¸å‰ç«¯æœŸæœ›ä¸€è‡´çš„çº¯ member å¯¹è±¡ï¼ˆå…¼å®¹æ—§å‰ç«¯ï¼‰
        return jsonify(member)
    return jsonify({'error': 'ä¼šå‘˜ä¸å­˜åœ¨'}), 404

@app.route('/api/member/<int:telegram_id>', methods=['PUT'])
@login_required
def api_update_member(telegram_id):
    """æ›´æ–°ä¼šå‘˜ä¿¡æ¯API"""
    data = request.json
    WebDB.update_member(telegram_id, data)
    return jsonify({'success': True, 'message': 'æ›´æ–°æˆåŠŸ'})

@app.route('/api/member/<int:telegram_id>', methods=['DELETE'])
@login_required
def api_delete_member(telegram_id):
    """åˆ é™¤ä¼šå‘˜API"""
    WebDB.delete_member(telegram_id)
    return jsonify({'success': True, 'message': 'åˆ é™¤æˆåŠŸ'})

@app.route('/api/member/add', methods=['POST'])
@login_required
def api_add_member():
    """æ·»åŠ ä¼šå‘˜API"""
    try:
        data = request.json
        telegram_id = data.get('telegram_id')
        username = data.get('username', '')
        referrer_id = data.get('referrer_id')
        
        if not telegram_id:
            return jsonify({'success': False, 'message': 'telegram_idä¸èƒ½ä¸ºç©º'}), 400
        
        # æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨
        existing = DB.get_member(telegram_id)
        if existing:
            return jsonify({'success': False, 'message': 'ä¼šå‘˜å·²å­˜åœ¨'}), 400
        
        # åˆ›å»ºä¼šå‘˜
        DB.create_member(telegram_id, username, referrer_id)
        return jsonify({'success': True, 'message': 'æ·»åŠ æˆåŠŸ'})
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500

@app.route('/api/member-groups/<int:group_id>/broadcasts', methods=['GET'])
@login_required
def api_get_group_broadcasts(group_id):
    """è·å–æŸä¸ªç¾¤å¯ç”¨çš„ç¾¤å‘åˆ—è¡¨ä»¥åŠè¯¥ç¾¤å·²åˆ†é…çš„æ¡ç›®çŠ¶æ€"""
    try:
        conn = get_db_conn()
        c = conn.cursor()
        # è·å–æ‰€æœ‰ç¾¤å‘æ¶ˆæ¯
        c.execute("""SELECT id, title, content, image_url, video_url, buttons, buttons_per_row, broadcast_interval, is_active, create_time
                     FROM broadcast_messages WHERE is_active = 1 ORDER BY id ASC""")
        msgs = c.fetchall()

        # è·å–è¯¥ç¾¤çš„åˆ†é…è®°å½•
        c.execute("SELECT message_id, is_active, last_sent_time FROM broadcast_assignments WHERE group_id = ?", (group_id,))
        assigns = {r[0]: {'is_active': r[1], 'last_sent_time': r[2]} for r in c.fetchall()}
        conn.close()

        messages = []
        for row in msgs:
            mid = row[0]
            messages.append({
                'id': mid,
                'title': row[1],
                'content': row[2],
                'image_url': row[3] or '',
                'video_url': row[4] or '',
                'buttons': row[5] or '[]',
                'buttons_per_row': row[6] or 2,
                'broadcast_interval': row[7] or 120,
                'is_active': row[8],
                'create_time': row[9] or '',
                'assigned': mid in assigns,
                'assignment': assigns.get(mid)
            })

        return jsonify({'success': True, 'messages': messages})
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500


@app.route('/api/member-groups/<int:group_id>/broadcasts', methods=['POST'])
@login_required
def api_assign_broadcast_to_group(group_id):
    """ä¸ºæŸä¸ªç¾¤åˆ†é…ä¸€æ¡ç¾¤å‘æ¶ˆæ¯ï¼ˆæˆ–æ›´æ–°æ¿€æ´»çŠ¶æ€ï¼‰"""
    try:
        data = request.get_json() or {}
        message_id = int(data.get('message_id') or 0)
        is_active = 1 if data.get('is_active') else 0
        if not message_id:
            return jsonify({'success': False, 'message': 'message_id å¿…å¡«'}), 400

        conn = get_db_conn()
        c = conn.cursor()
        # æ£€æŸ¥ç¾¤æ˜¯å¦å­˜åœ¨
        c.execute('SELECT id, group_link FROM member_groups WHERE id = ?', (group_id,))
        g = c.fetchone()
        if not g:
            conn.close()
            return jsonify({'success': False, 'message': 'ç¾¤ç»„ä¸å­˜åœ¨'}), 404

        # æ’å…¥æˆ–æ›´æ–° assignment
        c.execute('SELECT id FROM broadcast_assignments WHERE group_id = ? AND message_id = ?', (group_id, message_id))
        row = c.fetchone()
        now = get_cn_time()
        if row:
            c.execute('UPDATE broadcast_assignments SET is_active = ?, create_time = ? WHERE id = ?', (is_active, now, row[0]))
        else:
            c.execute('INSERT INTO broadcast_assignments (group_id, message_id, is_active, create_time) VALUES (?, ?, ?, ?)',
                      (group_id, message_id, is_active, now))
        conn.commit()
        conn.close()
        return jsonify({'success': True, 'message': 'åˆ†é…å·²ä¿å­˜'})
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500


@app.route('/api/member-groups/<int:group_id>/broadcasts/<int:message_id>', methods=['DELETE'])
@login_required
def api_unassign_broadcast_from_group(group_id, message_id):
    """å–æ¶ˆæŸæ¡æ¶ˆæ¯å¯¹æŸç¾¤çš„åˆ†é…"""
    try:
        conn = get_db_conn()
        c = conn.cursor()
        c.execute('DELETE FROM broadcast_assignments WHERE group_id = ? AND message_id = ?', (group_id, message_id))
        conn.commit()
        conn.close()
        return jsonify({'success': True, 'message': 'å·²å–æ¶ˆåˆ†é…'})
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500


@app.route('/api/member-groups/<int:group_id>/broadcast/send', methods=['POST'])
@login_required
def api_group_send_broadcasts(group_id):
    """ç«‹å³å‘æŸä¸ªç¾¤å‘é€é€‰ä¸­çš„ç¾¤å‘å†…å®¹ï¼›å¦‚æœæœªæŒ‡å®š message_idsï¼Œåˆ™å‘é€è¯¥ç¾¤å·²åˆ†é…ä¸”å¯ç”¨çš„æ‰€æœ‰æ¶ˆæ¯"""
    try:
        data = request.get_json() or {}
        message_ids = data.get('message_ids') or []

        conn = get_db_conn()
        c = conn.cursor()
        c.execute('SELECT group_link, group_name FROM member_groups WHERE id = ?', (group_id,))
        g = c.fetchone()
        if not g:
            conn.close()
            return jsonify({'success': False, 'message': 'ç¾¤ç»„ä¸å­˜åœ¨'}), 404
        group_link, group_name = g[0], g[1]

        if not message_ids:
            # å–è¯¥ç¾¤å·²åˆ†é…ä¸”å¯ç”¨çš„æ¶ˆæ¯
            c.execute('SELECT message_id FROM broadcast_assignments WHERE group_id = ? AND is_active = 1 ORDER BY id ASC', (group_id,))
            message_ids = [r[0] for r in c.fetchall()]

        if not message_ids:
            conn.close()
            return jsonify({'success': False, 'message': 'æ²¡æœ‰å¯å‘é€çš„ç¾¤å‘å†…å®¹'}), 400

        # è·å–å¾…å‘é€æ¶ˆæ¯å†…å®¹å¹¶å†™å…¥ broadcast_queue
        placeholders = ','.join(['?' for _ in message_ids])
        c.execute(f'SELECT id, title, content, image_url, video_url, buttons FROM broadcast_messages WHERE id IN ({placeholders}) ORDER BY id ASC', message_ids)
        rows = c.fetchall()
        now = get_cn_time()
        for row in rows:
            # build a JSON payload containing content and media
            msg_obj = {
                'content': row[2] or '',
                'image_url': row[3] or '',
                'video_url': row[4] or '',
                'buttons': row[5] or '',
            }
            import json
            msg_json = json.dumps(msg_obj, ensure_ascii=False)
            # å†™å…¥é˜Ÿåˆ—ï¼›Bot çº¿ç¨‹ä¼šè§£æ JSON å¹¶å‘é€åª’ä½“/æŒ‰é’®ç­‰
            c.execute('INSERT INTO broadcast_queue (group_link, group_name, message, status, create_time) VALUES (?, ?, ?, ?, ?)',
                      (group_link, group_name, msg_json, 'pending', now))

        conn.commit()
        conn.close()
        return jsonify({'success': True, 'message': f'å·²å°† {len(rows)} æ¡æ¶ˆæ¯åŠ å…¥ç¾¤ {group_name} çš„å‘é€é˜Ÿåˆ—'})
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500

@app.route('/api/member/<int:telegram_id>/graph')
@login_required
def api_member_graph(telegram_id):
    """è·å–ä¼šå‘˜å…³ç³»å›¾è°±"""
    conn = get_db_conn()
    c = conn.cursor()
    
    # è·å–å½“å‰ä¼šå‘˜
    c.execute("""SELECT telegram_id, username, balance, is_vip, referrer_id,
        is_group_bound, is_bot_admin, is_joined_upline, direct_count, team_count
        FROM members WHERE telegram_id = ?""", (telegram_id,))
    row = c.fetchone()
    if not row:
        conn.close()
        return jsonify({'error': 'ä¼šå‘˜ä¸å­˜åœ¨'}), 404
    
    current = {
        'telegram_id': row[0], 'username': row[1], 'balance': row[2],
        'is_vip': row[3], 'referrer_id': row[4], 'is_group_bound': row[5],
        'is_bot_admin': row[6], 'is_joined_upline': row[7],
        'direct_count': row[8] or 0, 'team_count': row[9] or 0
    }
    
    # è·å–ä¸Šçº§é“¾
    upline = []
    current_ref = row[4]
    while current_ref and len(upline) < 10:
        c.execute("""SELECT telegram_id, username, is_vip, referrer_id,
            is_group_bound, is_bot_admin, is_joined_upline, direct_count, team_count
            FROM members WHERE telegram_id = ?""", (current_ref,))
        ref_row = c.fetchone()
        if not ref_row:
            break
        is_valid = ref_row[4] and ref_row[5] and ref_row[6]
        upline.append({
            'telegram_id': ref_row[0], 'username': ref_row[1], 'is_vip': ref_row[2],
            'is_group_bound': ref_row[4], 'is_bot_admin': ref_row[5], 'is_joined_upline': ref_row[6],
            'direct_count': ref_row[7] or 0, 'team_count': ref_row[8] or 0, 'is_valid': is_valid
        })
        current_ref = ref_row[3]
    
    # é€’å½’è·å–å¤šå±‚çº§ä¸‹çº§
    def get_downline_recursive(parent_id, max_level=10):
        result = {}
        for level in range(1, max_level + 1):
            if level == 1:
                c.execute("""SELECT telegram_id, username, is_vip,
                    is_group_bound, is_bot_admin, is_joined_upline
                    FROM members WHERE referrer_id = ? LIMIT 100""", (parent_id,))
            else:
                if level - 1 not in result or not result[level - 1]:
                    break
                parent_ids = [m['telegram_id'] for m in result[level - 1]]
                if not parent_ids:
                    break
                placeholders = ','.join('?' * len(parent_ids))
                c.execute(f"""SELECT telegram_id, username, is_vip,
                    is_group_bound, is_bot_admin, is_joined_upline
                    FROM members WHERE referrer_id IN ({placeholders}) LIMIT 100""", parent_ids)
            
            level_members = []
            for d in c.fetchall():
                c.execute('SELECT COUNT(*) FROM members WHERE referrer_id = ?', (d[0],))
                d_direct = c.fetchone()[0]
                c.execute("SELECT COUNT(*) FROM members WHERE level_path LIKE ? AND telegram_id != ?", (f'%/{d[0]}/%', d[0]))
                d_team = c.fetchone()[0]
                level_members.append({
                    'telegram_id': d[0], 'username': d[1], 'is_vip': d[2],
                    'is_group_bound': d[3], 'is_bot_admin': d[4], 'is_joined_upline': d[5],
                    'direct_count': d_direct, 'team_count': d_team
                })
            if level_members:
                result[level] = level_members
            else:
                break
        return result
    
    downline_by_level = get_downline_recursive(telegram_id)
    
    conn.close()
    return jsonify({'current': current, 'upline': upline, 'downline_by_level': downline_by_level})

@app.route('/api/statistics')
@login_required
def api_statistics():
    """è·å–ç»Ÿè®¡æ•°æ®API"""
    stats = WebDB.get_statistics()
    return jsonify(stats)

@app.route('/api/statistics/chart')
@login_required
def api_chart_data():
    """è·å–å›¾è¡¨æ•°æ®API"""
    chart_data = WebDB.get_chart_data()
    return jsonify(chart_data)

@app.route('/api/dashboard/stats')
@login_required
def api_dashboard_stats():
    """è·å–ä»ªè¡¨ç›˜ç»Ÿè®¡æ•°æ®"""
    try:
        from datetime import datetime, timedelta
        conn = get_db_conn()
        c = conn.cursor()
        
        today = datetime.now().strftime('%Y-%m-%d')
        yesterday = (datetime.now() - timedelta(days=1)).strftime('%Y-%m-%d')
        month_start = datetime.now().strftime('%Y-%m-01')
        
        c.execute('SELECT COUNT(*) FROM members')
        total_members = c.fetchone()[0]
        
        c.execute('SELECT COUNT(*) FROM members WHERE is_vip = 1')
        vip_members = c.fetchone()[0]
        
        c.execute('SELECT COUNT(*) FROM members WHERE DATE(register_time) = ?', (today,))
        today_register = c.fetchone()[0]
        
        c.execute('SELECT COUNT(*) FROM members WHERE DATE(register_time) = ?', (yesterday,))
        yesterday_register = c.fetchone()[0]
        
        c.execute('SELECT COUNT(*) FROM members WHERE DATE(register_time) >= ?', (month_start,))
        month_register = c.fetchone()[0]
        
        c.execute('SELECT COUNT(*) FROM members WHERE is_vip = 1 AND DATE(vip_time) = ?', (today,))
        today_vip = c.fetchone()[0]
        
        c.execute('SELECT COUNT(*) FROM members WHERE is_vip = 1 AND DATE(vip_time) = ?', (yesterday,))
        yesterday_vip = c.fetchone()[0]
        
        c.execute('SELECT COUNT(*) FROM members WHERE is_vip = 1 AND DATE(vip_time) >= ?', (month_start,))
        month_vip = c.fetchone()[0]
        
        c.execute("SELECT telegram_id, username, total_earned FROM fallback_accounts ORDER BY total_earned DESC LIMIT 10")
        fallback_rows = c.fetchall()
        
        fallback_accounts = []
        total_income = 0
        
        for row in fallback_rows:
            total_income += row[2] or 0
            fallback_accounts.append({
                "telegram_id": row[0],
                "username": row[1],
                "balance": row[2] or 0,
                "total_earned": row[2] or 0,
                "is_vip": 1
            })
        
        today_income = total_income
        yesterday_income = 0
        month_income = total_income
        
        trend_labels = []
        trend_register = []
        trend_vip = []
        for i in range(6, -1, -1):
            date = (datetime.now() - timedelta(days=i)).strftime('%Y-%m-%d')
            trend_labels.append((datetime.now() - timedelta(days=i)).strftime('%m-%d'))
            
            c.execute('SELECT COUNT(*) FROM members WHERE DATE(register_time) = ?', (date,))
            trend_register.append(c.fetchone()[0])
            
            c.execute('SELECT COUNT(*) FROM members WHERE is_vip = 1 AND DATE(vip_time) = ?', (date,))
            trend_vip.append(c.fetchone()[0])
        
        conn.close()
        
        return jsonify({
            'success': True,
            'data': {
                'total_members': total_members,
                'vip_members': vip_members,
                'today_register': today_register,
                'yesterday_register': yesterday_register,
                'month_register': month_register,
                'today_vip': today_vip,
                'yesterday_vip': yesterday_vip,
                'month_vip': month_vip,
                'today_income': round(today_income, 2),
                'yesterday_income': round(yesterday_income, 2),
                'month_income': round(month_income, 2),
                'total_income': round(total_income, 2),
                'fallback_accounts': fallback_accounts,
                'trend_data': {
                    'labels': trend_labels,
                    'register_counts': trend_register,
                    'vip_counts': trend_vip
                }
            }
        })
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500

@app.route('/api/member-groups')
@login_required
def api_get_member_groups():
    """è·å–ä¼šå‘˜ç¾¤åˆ—è¡¨"""
    try:
        search = request.args.get('search', '').strip()
        conn = get_db_conn()
        c = conn.cursor()
        
        if search:
            c.execute('''
                SELECT 
                    mg.id, mg.telegram_id, mg.group_id, mg.group_name,
                    mg.group_link, mg.member_count, mg.bot_id, mg.is_bot_admin,
                    mg.create_time, m.username
                FROM member_groups mg
                LEFT JOIN members m ON mg.telegram_id = m.telegram_id
                WHERE mg.group_name LIKE ? OR mg.group_link LIKE ? OR m.username LIKE ?
                ORDER BY mg.id DESC
            ''', (f'%{search}%', f'%{search}%', f'%{search}%'))
        else:
            c.execute('''
                SELECT 
                    mg.id, mg.telegram_id, mg.group_id, mg.group_name,
                    mg.group_link, mg.member_count, mg.bot_id, mg.is_bot_admin,
                    mg.create_time, m.username
                FROM member_groups mg
                LEFT JOIN members m ON mg.telegram_id = m.telegram_id
                ORDER BY mg.id DESC
            ''')
        
        rows = c.fetchall()
        groups = []
        for row in rows:
            groups.append({
                'id': row[0],
                'telegram_id': row[1],
                'group_id': row[2],
                'group_name': row[3] or '',
                'group_link': row[4] or '',
                'member_count': row[5] or 0,
                'bot_id': row[6],
                'is_bot_admin': row[7],
                'create_time': row[8][:19] if row[8] else '',
                'owner_username': row[9] or ''
            })
        
        conn.close()
        return jsonify({'success': True, 'groups': groups})
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/api/member-groups/<int:id>', methods=['PUT'])
@login_required
def api_update_member_group(id):
    """æ›´æ–°ä¼šå‘˜ç¾¤ç»„ä¿¡æ¯"""
    try:
        data = request.json or {}
        group_name = data.get('group_name')
        group_link = data.get('group_link')

        conn = get_db_conn()
        c = conn.cursor()

        updates = []
        params = []
        if group_name is not None:
            updates.append("group_name = ?")
            params.append(group_name)
        if group_link is not None:
            updates.append("group_link = ?")
            params.append(group_link)

        if not updates:
            conn.close()
            return jsonify({'success': False, 'message': 'æ²¡æœ‰è¦æ›´æ–°çš„å†…å®¹'})

        params.append(id)
        c.execute(f"UPDATE member_groups SET {', '.join(updates)} WHERE id = ?", params)
        conn.commit()
        conn.close()

        return jsonify({'success': True, 'message': 'æ›´æ–°æˆåŠŸ'})
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500


@app.route('/api/member-groups/<int:id>/verify', methods=['POST'])
@login_required
def api_verify_member_group(id):
    """éªŒè¯ç¾¤ç»„çŠ¶æ€ (è§¦å‘Botæ£€æµ‹)"""
    try:
        conn = get_db_conn()
        c = conn.cursor()
        c.execute("SELECT group_link FROM member_groups WHERE id = ?", (id,))
        row = c.fetchone()
        conn.close()

        if not row or not row[0]:
            return jsonify({'success': False, 'message': 'ç¾¤ç»„ä¸å­˜åœ¨æˆ–æ— é“¾æ¥'}), 404

        group_link = row[0]

        # å°è¯•è°ƒç”¨ Bot éªŒè¯ (è¿™æ˜¯ä¸€ä¸ªå¼‚æ­¥æ“ä½œï¼ŒWebç«¯åªèƒ½è¿”å›å·²æäº¤)
        # è¿™é‡Œç®€å•è¿”å›æˆåŠŸï¼Œå®é™…éªŒè¯ä¾èµ–åå° check_member_status_task ä»»åŠ¡
        # æˆ–è€…å¯ä»¥æ‰‹åŠ¨è§¦å‘ä¸€æ¬¡æ£€æµ‹é€»è¾‘

        return jsonify({
            'success': True,
            'message': 'éªŒè¯è¯·æ±‚å·²æäº¤ï¼Œè¯·ç¨ååˆ·æ–°æŸ¥çœ‹çŠ¶æ€ (ç³»ç»Ÿåå°ä¼šè‡ªåŠ¨å®šæ—¶æ£€æµ‹)'
        })
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500

@app.route('/api/member-groups/broadcast', methods=['POST'])
@login_required
def api_broadcast_to_groups():
    """å‘é€‰ä¸­çš„ä¼šå‘˜ç¾¤ç»„å‘é€å¹¿æ’­æ¶ˆæ¯"""
    try:
        data = request.get_json() or {}
        group_ids = data.get('group_ids', [])
        message = (data.get('message', '')).strip()

        if not message:
            return jsonify({'success': False, 'message': 'æ¶ˆæ¯å†…å®¹ä¸èƒ½ä¸ºç©º'}), 400

        if not group_ids:
            return jsonify({'success': False, 'message': 'è¯·é€‰æ‹©è¦å‘é€çš„ç¾¤ç»„'}), 400

        conn = get_db_conn()
        c = conn.cursor()

        # è·å–é€‰ä¸­çš„ç¾¤ç»„ä¿¡æ¯
        placeholders = ','.join(['?' for _ in group_ids])
        c.execute(f'SELECT id, group_link, group_name FROM member_groups WHERE id IN ({placeholders})', group_ids)
        groups = c.fetchall()
        conn.close()

        if not groups:
            return jsonify({'success': False, 'message': 'æœªæ‰¾åˆ°å¯¹åº”çš„ç¾¤ç»„'}), 404

        # ã€ä¿®å¤ç‚¹ã€‘æ­£ç¡®å¼•ç”¨ bot_logic ä¸­çš„å˜é‡
        import bot_logic
        # ç¡®ä¿åˆ—è¡¨å­˜åœ¨
        if not hasattr(bot_logic, 'pending_broadcasts'):
            bot_logic.pending_broadcasts = []

        sent_count = 0
        for group in groups:
            group_link = group[1]
            if group_link and 't.me/' in group_link:
                try:
                    # ç›´æ¥è¿½åŠ åˆ° bot_logic æ¨¡å—çš„åˆ—è¡¨ä¸­
                    bot_logic.pending_broadcasts.append({
                        'type': 'broadcast',
                        'group_links': [group_link],
                        'message_content': message
                    })
                    sent_count += 1
                except Exception as e:
                    print(f'[ç¾¤å‘API] æ·»åŠ ç¾¤ç»„ {group[0]} å¤±è´¥: {e}')
                    continue

        if sent_count == 0:
            return jsonify({'success': False, 'message': 'æ²¡æœ‰æœ‰æ•ˆçš„ç¾¤ç»„é“¾æ¥å¯ä»¥å‘é€'}), 400

        return jsonify({
            'success': True,
            'sent_count': sent_count,
            'message': f'å·²å°†ç¾¤å‘ä»»åŠ¡æ·»åŠ åˆ°é˜Ÿåˆ—ï¼Œå°†å‘é€åˆ° {sent_count} ä¸ªç¾¤ç»„'
        })

    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500

@app.route('/api/fallback-accounts', methods=['GET', 'POST'])
@login_required
def api_fallback_accounts():
    """è·å–æ¡æ¼è´¦å·åˆ—è¡¨æˆ–æ·»åŠ æ–°è´¦å·"""
    try:
        conn = get_db_conn()
        c = conn.cursor()

        if request.method == 'GET':
            # è·å–æ¡æ¼è´¦å·åˆ—è¡¨
            c.execute('''
                SELECT fa.id, fa.telegram_id, fa.username, fa.group_link, fa.total_earned, fa.is_active,
                       m.is_vip, m.balance
                FROM fallback_accounts fa
                LEFT JOIN members m ON fa.telegram_id = m.telegram_id
                ORDER BY fa.id ASC
            ''')
            accounts = []
            for row in c.fetchall():
                telegram_id = row[1]
                # é‡æ–°è®¡ç®—ï¼šç»Ÿè®¡ earnings_records ä¸­ï¼Œç»™è¯¥æ¡æ¼è´¦å·çš„æ‰€æœ‰å«"æ¡æ¼"è¯´æ˜çš„æ”¶ç›Š
                c2 = conn.cursor()
                c2.execute('''
                    SELECT COALESCE(SUM(amount), 0)
                    FROM earnings_records
                    WHERE earning_user = ? AND description LIKE '%æ¡æ¼%'
                ''', (telegram_id,))
                calculated_total = c2.fetchone()[0] or 0

                stored_total = row[4] or 0
                if abs(calculated_total - stored_total) > 0.01:
                    c.execute('UPDATE fallback_accounts SET total_earned = ? WHERE telegram_id = ?',
                             (calculated_total, telegram_id))
                    conn.commit()
                    stored_total = calculated_total

                accounts.append({
                    'id': row[0],
                    'telegram_id': telegram_id,
                    'username': row[2] or str(telegram_id),
                    'group_link': row[3] or '',
                    'total_earned': stored_total,
                    'is_active': row[5] if row[5] is not None else 1,
                    'is_vip': row[6] if row[6] is not None else 0,
                    'balance': row[7] if row[7] is not None else 0
                })
            conn.close()
            return jsonify({'success': True, 'accounts': accounts})

        elif request.method == 'POST':
            # æ·»åŠ æ–°æ¡æ¼è´¦å·
            data = request.json or {}
            username = data.get('username', '').strip()
            group_link = data.get('group_link', '').strip()

            if not username:
                conn.close()
                return jsonify({'success': False, 'message': 'è¯·è¾“å…¥Telegramç”¨æˆ·å'}), 400

            # å¤„ç†ç”¨æˆ·åæ ¼å¼
            if username.startswith('@'):
                username = username[1:]

            # å°è¯•è§£ætelegram_idï¼ˆå¦‚æœæ˜¯æ•°å­—ï¼‰
            telegram_id = None
            if username.isdigit():
                telegram_id = int(username)
            # å¦‚æœä¸æ˜¯æ•°å­—ï¼Œå°±å½“ä½œç”¨æˆ·åå¤„ç†ï¼Œtelegram_idè®¾ä¸ºNone

            # æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨ï¼ˆé€šè¿‡ç”¨æˆ·åæˆ–telegram_idï¼‰
            if telegram_id:
                c.execute('SELECT id FROM fallback_accounts WHERE telegram_id = ? OR username = ?', (telegram_id, username))
            else:
                c.execute('SELECT id FROM fallback_accounts WHERE username = ?', (username,))

            if c.fetchone():
                conn.close()
                return jsonify({'success': False, 'message': 'è¯¥è´¦å·å·²å­˜åœ¨'}), 400

            # å¦‚æœæœ‰telegram_idï¼Œæ£€æŸ¥æ˜¯å¦å­˜åœ¨å¯¹åº”çš„membersè®°å½•
            if telegram_id:
                c.execute('SELECT telegram_id FROM members WHERE telegram_id = ?', (telegram_id,))
                member_exists = c.fetchone() is not None

                if not member_exists:
                    # å¦‚æœmembersè¡¨ä¸­æ²¡æœ‰ï¼Œå…ˆåˆ›å»ºmembersè®°å½•
                    c.execute('''
                        INSERT INTO members (telegram_id, username, register_time)
                        VALUES (?, ?, ?)
                    ''', (telegram_id, username, get_cn_time()))

            # æ·»åŠ åˆ°fallback_accounts
            c.execute('''
                INSERT INTO fallback_accounts (telegram_id, username, group_link, is_active, main_account_id)
                VALUES (?, ?, ?, 1, ?)
            ''', (telegram_id, username, group_link if group_link else None, telegram_id))

            conn.commit()
            conn.close()

            return jsonify({'success': True, 'message': 'æ¡æ¼è´¦å·æ·»åŠ æˆåŠŸ'})

    except Exception as e:
        try:
            conn.close()
        except:
            pass
        return jsonify({'success': False, 'message': str(e)}), 500

@app.route('/api/earnings')
@login_required
def api_get_earnings():
    """è·å–æ”¶ç›Šè®°å½•åˆ—è¡¨"""
    try:
        page = request.args.get('page', 1, type=int)
        per_page = request.args.get('per_page', 20, type=int)
        search = request.args.get('search', '').strip()
        
        conn = get_db_conn()
        c = conn.cursor()
        offset = (page - 1) * per_page
        
        where_clause = ''
        params = []
        
        if search:
            if search.isdigit():
                where_clause = 'WHERE er.earning_user = ?'
                params = [int(search)]
            else:
                where_clause = 'WHERE (m.username LIKE ? OR fa.username LIKE ?)'
                params = [f'%{search}%', f'%{search}%']
        
        count_query = f'''
            SELECT COUNT(*) FROM earnings_records er
            LEFT JOIN members m ON er.earning_user = m.telegram_id
            LEFT JOIN fallback_accounts fa ON er.earning_user = fa.telegram_id
            {where_clause}
        '''
        c.execute(count_query, params)
        total = c.fetchone()[0]
        
        query = f'''
            SELECT er.id, er.earning_user as member_id,
                   COALESCE(m.username, fa.username, '') as username,
                   er.amount, er.upgraded_user, er.description, er.create_time
            FROM earnings_records er
            LEFT JOIN members m ON er.earning_user = m.telegram_id
            LEFT JOIN fallback_accounts fa ON er.earning_user = fa.telegram_id
            {where_clause}
            ORDER BY er.create_time DESC
            LIMIT ? OFFSET ?
        '''
        c.execute(query, params + [per_page, offset])
        
        records = []
        for row in c.fetchall():
            member_id = row[1]
            username = row[2] or ''
            upgraded_user_id = row[4] if len(row) > 4 else None
            
            if member_id and not username:
                c2 = conn.cursor()
                c2.execute('SELECT username, telegram_id FROM fallback_accounts WHERE telegram_id = ?', (member_id,))
                fb_row = c2.fetchone()
                if fb_row:
                    username = fb_row[0] or ''
                    if not username:
                        username = str(fb_row[1]) if fb_row[1] else str(member_id)
                else:
                    c2.execute('SELECT username FROM members WHERE telegram_id = ?', (member_id,))
                    m_row = c2.fetchone()
                    if m_row and m_row[0]:
                        username = m_row[0]
                    else:
                        username = str(member_id)
            # ç›´æ¥è¯»å–æ•°æ®åº“ä¸­çš„ description
            detailed_description = row[5] or ''

            # å¦‚æœæ˜¯æ—§æ•°æ®ï¼ˆæ²¡æœ‰è¯¦ç»†è¯´æ˜ï¼‰ï¼Œå¯ä»¥ä¿ç•™ä¸€ç‚¹ç®€å•çš„å…¼å®¹é€»è¾‘ï¼Œæˆ–è€…ç›´æ¥æ˜¾ç¤º
            if not detailed_description:
                detailed_description = "æ”¶ç›Šè®°å½•"

            try:
                if upgraded_user_id:
                    upm = DB.get_member(upgraded_user_id)
                    upgraded_name = f"@{upm['username']}" if upm and upm.get('username') else str(upgraded_user_id)
                else:
                    upgraded_name = '-'
            except:
                upgraded_name = str(upgraded_user_id) if upgraded_user_id else '-'
            
            records.append({
                'id': row[0],
                'member_id': member_id if member_id is not None else 0,
                'username': username or (str(member_id) if member_id else 'N/A'),
                'amount': row[3],
                'upgraded_user_id': upgraded_user_id or 0,
                'upgraded_user_name': upgraded_name,
                'description': detailed_description,  # ä½¿ç”¨è¯¦ç»†è¯´æ˜
                'create_time': row[6][:19] if row[6] else ''
            })
        
        conn.close()
        
        return jsonify({
            'success': True,
            'records': records,
            'total': total,
            'page': page,
            'pages': (total + per_page - 1) // per_page if total > 0 else 1,
            'per_page': per_page
        })
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500

@app.route('/api/resource_categories')
@login_required
def api_get_resource_categories():
    """è·å–èµ„æºåˆ†ç±»åˆ—è¡¨"""
    try:
        categories = DB.get_resource_categories(0)
        return jsonify({'success': True, 'categories': categories})
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500


@app.route('/api/resource_categories/<int:id>')
@login_required
def api_get_resource_category(id):
    """è·å–å•ä¸ªèµ„æºåˆ†ç±»"""
    try:
        conn = get_db_conn()
        c = conn.cursor()
        c.execute('SELECT id, name, parent_id FROM resource_categories WHERE id = ?', (id,))
        row = c.fetchone()
        conn.close()
        if row:
            return jsonify({'id': row[0], 'name': row[1], 'parent_id': row[2]})
        return jsonify({'success': False, 'message': 'åˆ†ç±»ä¸å­˜åœ¨'}), 404
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500


@app.route('/api/resource_categories', methods=['POST'])
@login_required
def api_create_resource_category():
    """åˆ›å»ºèµ„æºåˆ†ç±»"""
    try:
        data = request.json or {}
        name = (data.get('name') or '').strip()
        parent_id = int(data.get('parent_id', 0) or 0)
        if not name:
            return jsonify({'success': False, 'message': 'åˆ†ç±»åç§°ä¸èƒ½ä¸ºç©º'}), 400
        conn = get_db_conn()
        c = conn.cursor()
        c.execute('INSERT INTO resource_categories (name, parent_id) VALUES (?, ?)', (name, parent_id))
        conn.commit()
        conn.close()
        return jsonify({'success': True, 'message': 'åˆ›å»ºæˆåŠŸ'})
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500


@app.route('/api/resource_categories/<int:id>', methods=['PUT'])
@login_required
def api_update_resource_category(id):
    """æ›´æ–°èµ„æºåˆ†ç±»"""
    try:
        data = request.json or {}
        name = (data.get('name') or '').strip()
        parent_id = int(data.get('parent_id', 0) or 0)
        if not name:
            return jsonify({'success': False, 'message': 'åˆ†ç±»åç§°ä¸èƒ½ä¸ºç©º'}), 400
        conn = get_db_conn()
        c = conn.cursor()
        c.execute('UPDATE resource_categories SET name = ?, parent_id = ? WHERE id = ?', (name, parent_id, id))
        conn.commit()
        conn.close()
        return jsonify({'success': True, 'message': 'æ›´æ–°æˆåŠŸ'})
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500


@app.route('/api/resource_categories/<int:id>', methods=['DELETE'])
@login_required
def api_delete_resource_category(id):
    """åˆ é™¤èµ„æºåˆ†ç±»"""
    try:
        conn = get_db_conn()
        c = conn.cursor()
        c.execute('SELECT COUNT(*) FROM resource_categories WHERE parent_id = ?', (id,))
        if c.fetchone()[0] > 0:
            conn.close()
            return jsonify({'success': False, 'message': 'è¯¥åˆ†ç±»ä¸‹æœ‰å­åˆ†ç±»ï¼Œæ— æ³•åˆ é™¤'}), 400
        c.execute('SELECT COUNT(*) FROM resources WHERE category_id = ?', (id,))
        if c.fetchone()[0] > 0:
            conn.close()
            return jsonify({'success': False, 'message': 'è¯¥åˆ†ç±»ä¸‹æœ‰èµ„æºï¼Œæ— æ³•åˆ é™¤'}), 400
        c.execute('DELETE FROM resource_categories WHERE id = ?', (id,))
        conn.commit()
        conn.close()
        return jsonify({'success': True, 'message': 'åˆ é™¤æˆåŠŸ'})
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500


@app.route('/api/resources')
@login_required
def api_get_resources():
    """è·å–èµ„æºåˆ—è¡¨"""
    try:
        category_id = request.args.get('category_id', type=int)
        conn = get_db_conn()
        c = conn.cursor()
        if category_id:
            c.execute('''
                SELECT r.id, r.name, r.link, r.type, r.member_count, r.category_id, rc.name
                FROM resources r
                LEFT JOIN resource_categories rc ON r.category_id = rc.id
                WHERE r.category_id = ?
                ORDER BY r.id DESC
            ''', (category_id,))
        else:
            c.execute('''
                SELECT r.id, r.name, r.link, r.type, r.member_count, r.category_id, rc.name
                FROM resources r
                LEFT JOIN resource_categories rc ON r.category_id = rc.id
                ORDER BY r.id DESC
            ''')
        rows = c.fetchall()
        resources = []
        for row in rows:
            resources.append({
                'id': row[0],
                'name': row[1],
                'link': row[2],
                'type': row[3],
                'member_count': row[4],
                'category_id': row[5],
                'category_name': row[6] or ''
            })
        conn.close()
        return jsonify({'success': True, 'resources': resources})
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500


@app.route('/api/resources/<int:id>')
@login_required
def api_get_resource(id):
    """è·å–å•ä¸ªèµ„æº"""
    try:
        conn = get_db_conn()
        c = conn.cursor()
        c.execute('SELECT id, name, link, type, member_count, category_id FROM resources WHERE id = ?', (id,))
        row = c.fetchone()
        conn.close()
        if row:
            return jsonify({
                'id': row[0],
                'name': row[1],
                'link': row[2],
                'type': row[3],
                'member_count': row[4],
                'category_id': row[5]
            })
        return jsonify({'success': False, 'message': 'èµ„æºä¸å­˜åœ¨'}), 404
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500


@app.route('/api/resources', methods=['POST'])
@login_required
def api_create_resource():
    """åˆ›å»ºèµ„æº"""
    try:
        data = request.json or {}
        name = (data.get('name') or '').strip()
        link = (data.get('link') or '').strip()
        rtype = (data.get('type') or '').strip()
        category_id = int(data.get('category_id', 0) or 0)
        member_count = int(data.get('member_count', 0) or 0)
        if not name or not link or not rtype:
            return jsonify({'success': False, 'message': 'å¿…å¡«å­—æ®µä¸èƒ½ä¸ºç©º'}), 400
        if rtype not in ['group', 'channel']:
            return jsonify({'success': False, 'message': 'èµ„æºç±»å‹ä¸æ­£ç¡®'}), 400
        if not (link.startswith('https://t.me/') or link.startswith('t.me/') or link.startswith('@')):
            return jsonify({'success': False, 'message': 'Telegramé“¾æ¥æ ¼å¼ä¸æ­£ç¡®'}), 400
        conn = get_db_conn()
        c = conn.cursor()
        c.execute('INSERT INTO resources (category_id, name, link, type, member_count) VALUES (?, ?, ?, ?, ?)',
                  (category_id, name, link, rtype, member_count))
        conn.commit()
        conn.close()
        return jsonify({'success': True, 'message': 'åˆ›å»ºæˆåŠŸ'})
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500


@app.route('/api/resources/<int:id>', methods=['PUT'])
@login_required
def api_update_resource(id):
    """æ›´æ–°èµ„æº"""
    try:
        data = request.json or {}
        category_id = int(data.get('category_id', 0) or 0)
        name = (data.get('name') or '').strip()
        link = (data.get('link') or '').strip()
        rtype = (data.get('type') or '').strip()
        member_count = int(data.get('member_count', 0) or 0)
        conn = get_db_conn()
        c = conn.cursor()
        c.execute('''
            UPDATE resources 
            SET category_id = ?, name = ?, link = ?, type = ?, member_count = ?
            WHERE id = ?
        ''', (category_id, name, link, rtype, member_count, id))
        conn.commit()
        conn.close()
        return jsonify({'success': True, 'message': 'æ›´æ–°æˆåŠŸ'})
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500


@app.route('/api/resources/<int:id>', methods=['DELETE'])
@login_required
def api_delete_resource(id):
    """åˆ é™¤èµ„æº"""
    try:
        conn = get_db_conn()
        c = conn.cursor()
        c.execute('DELETE FROM resources WHERE id = ?', (id,))
        conn.commit()
        conn.close()
        return jsonify({'success': True, 'message': 'åˆ é™¤æˆåŠŸ'})
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500

@app.route('/api/broadcast/messages')
@login_required
def api_get_broadcast_messages():
    """è·å–ç¾¤å‘å†…å®¹åˆ—è¡¨"""
    try:
        conn = get_db_conn()
        c = conn.cursor()
        c.execute("""SELECT id, title, content, media_type, media_url, is_active, create_time,
                    image_url, video_url, buttons, buttons_per_row, broadcast_interval
                    FROM broadcast_messages ORDER BY id DESC""")
        rows = c.fetchall()
        messages = []
        for row in rows:
            messages.append({
                'id': row[0],
                'title': row[1],
                'content': row[2],
                'media_type': row[3],
                'media_url': row[4],
                'is_active': row[5],
                'create_time': row[6],
                'image_url': row[7] or '',
                'video_url': row[8] or '',
                'buttons': row[9] or '[]',
                'buttons_per_row': row[10] or 2,
                'broadcast_interval': row[11] or 120
            })
        conn.close()
        return jsonify({'success': True, 'messages': messages})
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/broadcast/send', methods=['POST'])
@login_required
def api_broadcast_send():
    """æ‰‹åŠ¨ç¾¤å‘æ¶ˆæ¯åˆ°æŒ‡å®šç¾¤ç»„"""
    try:
        data = request.get_json() or {}
        message = data.get('message', '')
        group_ids = data.get('group_ids', [])
        send_all = data.get('all', False)

        if not message:
            return jsonify({'success': False, 'message': 'æ¶ˆæ¯å†…å®¹ä¸èƒ½ä¸ºç©º'}), 400

        conn = get_db_conn()
        c = conn.cursor()

        if send_all:
            c.execute('SELECT id, group_link, group_name FROM member_groups')
        else:
            if not group_ids:
                conn.close()
                return jsonify({'success': False, 'message': 'è¯·é€‰æ‹©ç¾¤ç»„'}), 400
            placeholders = ','.join(['?' for _ in group_ids])
            c.execute(f'SELECT id, group_link, group_name FROM member_groups WHERE id IN ({placeholders})', group_ids)

        groups = c.fetchall()
        conn.close()

        if not groups:
            return jsonify({'success': False, 'message': 'æ²¡æœ‰æ‰¾åˆ°ç¾¤ç»„'}), 400

        # åŠ å…¥å‘é€é˜Ÿåˆ—
        sent = 0
        for g in groups:
            group_link = g[1]
            if group_link and 't.me/' in group_link:
                try:
                    pending_broadcasts.append({
                        'type': 'broadcast',
                        'group_links': [group_link],
                        'message_content': message
                    })
                    sent += 1
                except Exception:
                    pass

        return jsonify({'success': True, 'sent': sent, 'message': f'å·²åŠ å…¥å‘é€é˜Ÿåˆ—: {sent}ä¸ªç¾¤ç»„'})
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500

@app.route('/api/bot-configs')
@login_required
def api_bot_configs():
    """è·å–Boté…ç½®åˆ—è¡¨ (ä¿®å¤ç‰ˆ: è¿”å›å®Œæ•´å¯¹è±¡ç»“æ„)"""
    try:
        conn = get_db_conn()
        c = conn.cursor()
        # ä» bot_configs è¡¨è¯»å–è¯¦ç»†ä¿¡æ¯ï¼Œè€Œä¸æ˜¯ä» system_config è¯»å–ç®€å•å­—ç¬¦ä¸²
        c.execute("SELECT id, bot_token, bot_username, is_active, create_time FROM bot_configs ORDER BY id DESC")
        rows = c.fetchall()
        conn.close()

        configs = []
        for row in rows:
            configs.append({
                'id': row[0],
                'bot_token': row[1],
                'bot_username': row[2] or 'æœªçŸ¥',
                'is_active': row[3],
                'create_time': row[4] or ''
            })

        # è¿”å› configs å­—æ®µï¼Œå‰ç«¯è¡¨æ ¼æ‰èƒ½æ­£ç¡®æ¸²æŸ“
        return jsonify({'success': True, 'configs': configs, 'tokens': configs})
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500


@app.route('/api/bot-config', methods=['POST'])
@login_required
def api_create_bot_config():
    """æ·»åŠ æœºå™¨äººé…ç½®"""
    try:
        data = request.json or {}
        token = (data.get('bot_token') or '').strip()
        username = (data.get('bot_username') or '').strip()
        if not token:
            return jsonify({'success': False, 'message': 'Bot Token ä¸èƒ½ä¸ºç©º'}), 400
        conn = get_db_conn()
        c = conn.cursor()
        now = get_cn_time()
        c.execute('INSERT INTO bot_configs (bot_token, bot_username, is_active, create_time) VALUES (?, ?, ?, ?)',
                  (token, username, 1, now))
        conn.commit()
        conn.close()
        return jsonify({'success': True, 'message': 'æœºå™¨äººå·²æ·»åŠ '})
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500


@app.route('/api/bot-config/<int:id>', methods=['DELETE'])
@login_required
def api_delete_bot_config(id):
    """åˆ é™¤æœºå™¨äººé…ç½®"""
    try:
        conn = get_db_conn()
        c = conn.cursor()
        c.execute('DELETE FROM bot_configs WHERE id = ?', (id,))
        conn.commit()
        conn.close()
        return jsonify({'success': True, 'message': 'å·²åˆ é™¤'})
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500


# ============ ç¾¤å‘æ¶ˆæ¯å¢åˆ æ”¹æŸ¥ APIï¼ˆä¸å‰ç«¯æ¨¡æ¿åŒ¹é…ï¼‰ ============
@app.route('/api/broadcast/message', methods=['POST'])
@login_required
def api_create_broadcast_message():
    """åˆ›å»ºç¾¤å‘æ¶ˆæ¯ï¼ˆä¾›å‰ç«¯ templates/broadcast.html ä½¿ç”¨ï¼‰"""
    try:
        data = request.get_json() or {}
        title = (data.get('title') or '')[:200]
        content = data.get('content') or ''
        image_url = data.get('image_url') or ''
        video_url = data.get('video_url') or ''
        buttons = data.get('buttons') or '[]'
        buttons_per_row = int(data.get('buttons_per_row', 2) or 2)
        broadcast_interval = int(data.get('broadcast_interval', 120) or 120)
        now = get_cn_time()

        conn = get_db_conn()
        c = conn.cursor()
        c.execute('''
            INSERT INTO broadcast_messages
            (title, content, media_type, media_url, is_active, create_time, image_url, video_url, buttons, buttons_per_row, broadcast_interval)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        ''', (title, content, None, None, 1, now, image_url, video_url, buttons, buttons_per_row, broadcast_interval))
        conn.commit()
        conn.close()
        return jsonify({'success': True, 'message': 'åˆ›å»ºæˆåŠŸ'})
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500


@app.route('/api/broadcast/message/<int:id>', methods=['GET'])
@login_required
def api_get_broadcast_message(id):
    try:
        conn = get_db_conn()
        c = conn.cursor()
        c.execute('SELECT id, title, content, image_url, video_url, buttons, buttons_per_row, is_active, broadcast_interval, create_time FROM broadcast_messages WHERE id = ?', (id,))
        row = c.fetchone()
        conn.close()
        if not row:
            return jsonify({'success': False, 'message': 'æœªæ‰¾åˆ°è¯¥æ¶ˆæ¯'}), 404
        msg = {
            'id': row[0],
            'title': row[1],
            'content': row[2],
            'image_url': row[3] or '',
            'video_url': row[4] or '',
            'buttons': row[5] or '[]',
            'buttons_per_row': row[6] or 2,
            'is_active': row[7],
            'broadcast_interval': row[8] or 120,
            'create_time': row[9] or ''
        }
        return jsonify({'success': True, 'message': msg})
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500


@app.route('/api/broadcast/message/<int:id>', methods=['PUT'])
@login_required
def api_update_broadcast_message(id):
    try:
        data = request.get_json() or {}
        title = (data.get('title') or '')[:200]
        content = data.get('content') or ''
        image_url = data.get('image_url') or ''
        video_url = data.get('video_url') or ''
        buttons = data.get('buttons') or '[]'
        buttons_per_row = int(data.get('buttons_per_row', 2) or 2)
        broadcast_interval = int(data.get('broadcast_interval', 120) or 120)
        is_active = 1 if data.get('is_active', True) else 0

        conn = get_db_conn()
        c = conn.cursor()
        c.execute('''
            UPDATE broadcast_messages
            SET title = ?, content = ?, image_url = ?, video_url = ?, buttons = ?, buttons_per_row = ?, broadcast_interval = ?, is_active = ?
            WHERE id = ?
        ''', (title, content, image_url, video_url, buttons, buttons_per_row, broadcast_interval, is_active, id))
        conn.commit()
        conn.close()
        return jsonify({'success': True, 'message': 'æ›´æ–°æˆåŠŸ'})
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500


@app.route('/api/broadcast/message/<int:id>', methods=['DELETE'])
@login_required
def api_delete_broadcast_message(id):
    try:
        conn = get_db_conn()
        c = conn.cursor()
        c.execute('DELETE FROM broadcast_messages WHERE id = ?', (id,))
        conn.commit()
        conn.close()
        return jsonify({'success': True, 'message': 'åˆ é™¤æˆåŠŸ'})
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500

@app.route('/api/upload', methods=['POST'])
@login_required
def api_upload_file():
    """ä¸Šä¼ æ–‡ä»¶API"""
    try:
        file = request.files.get('file')
        if not file:
            return jsonify({'success': False, 'message': 'æ²¡æœ‰æ–‡ä»¶'}), 400

        # æ£€æŸ¥æ–‡ä»¶å¤§å°ï¼ˆ50MBï¼‰
        if file.content_length and file.content_length > 50 * 1024 * 1024:
            return jsonify({'success': False, 'message': 'æ–‡ä»¶å¤§å°è¶…è¿‡50MB'}), 400

        # æ£€æŸ¥æ–‡ä»¶ç±»å‹
        allowed_types = ['image/jpeg', 'image/png', 'image/gif', 'image/webp', 'video/mp4', 'video/avi', 'video/mov']
        if file.content_type not in allowed_types:
            return jsonify({'success': False, 'message': 'ä¸æ”¯æŒçš„æ–‡ä»¶ç±»å‹'}), 400

        # ç”Ÿæˆæ–‡ä»¶å
        import uuid
        filename = f"{uuid.uuid4().hex}_{file.filename}"
        # ä½¿ç”¨é…ç½®ä¸­çš„ UPLOAD_DIRï¼ˆé€šå¸¸ä¸º <BASE_DIR>/static/uploadsï¼‰
        file_path = os.path.join(UPLOAD_DIR, filename)

        # ç¡®ä¿ä¸Šä¼ ç›®å½•å­˜åœ¨
        os.makedirs(os.path.dirname(file_path), exist_ok=True)

        # ä¿å­˜æ–‡ä»¶
        file.save(file_path)

        # è¿”å›æ–‡ä»¶URL
        file_url = f"/static/uploads/{filename}"
        return jsonify({'success': True, 'url': file_url, 'message': 'ä¸Šä¼ æˆåŠŸ'})

    except Exception as e:
        print(f"ä¸Šä¼ æ–‡ä»¶é”™è¯¯: {e}")
        return jsonify({'success': False, 'message': 'ä¸Šä¼ å¤±è´¥'}), 500

@app.route('/api/welcome-messages')
@login_required
def api_welcome_messages():
    """è·å–æ¬¢è¿æ¶ˆæ¯åˆ—è¡¨"""
    try:
        config = get_system_config()
        return jsonify({
            'success': True,
            'welcome_enabled': config.get('welcome_enabled', '0'),
            'welcome_message': config.get('welcome_message', '')
        })
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500

@app.route('/api/advertisements')
@login_required
def api_advertisements():
    """è·å–å¹¿å‘Šåˆ—è¡¨"""
    try:
        conn = get_db_conn()
        c = conn.cursor()
        c.execute("SELECT id, content, is_active, create_time FROM broadcast_messages WHERE media_type = 'ad' ORDER BY id DESC")
        rows = c.fetchall()
        ads = []
        for row in rows:
            ads.append({
                'id': row[0],
                'content': row[1],
                'is_active': row[2],
                'create_time': row[3]
            })
        conn.close()
        return jsonify({'success': True, 'advertisements': ads})
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500

@app.route('/api/level-settings')
@login_required
def api_level_settings():
    """è·å–å±‚çº§è®¾ç½®"""
    try:
        config = get_system_config()
        # level_amounts: per-level reward amounts (list or dict). If missing, generate defaults.
        level_count = int(config.get('level_count', 10))
        level_reward = float(config.get('level_reward', 1.0))
        level_amounts = config.get('level_amounts')
        if not level_amounts:
            # default: same reward for each level
            level_amounts = [level_reward for _ in range(level_count)]
        else:
            try:
                # ensure it's a list of length level_count (if dict convert)
                import json
                if isinstance(level_amounts, str):
                    parsed = json.loads(level_amounts)
                else:
                    parsed = level_amounts
                if isinstance(parsed, dict):
                    # convert dict {1: amt,...} to list
                    amounts = []
                    for i in range(1, level_count + 1):
                        amounts.append(float(parsed.get(str(i)) or parsed.get(i) or level_reward))
                    level_amounts = amounts
                elif isinstance(parsed, list):
                    # pad or trim
                    parsed = [float(x) for x in parsed]
                    if len(parsed) < level_count:
                        parsed += [level_reward] * (level_count - len(parsed))
                    else:
                        parsed = parsed[:level_count]
                    level_amounts = parsed
                else:
                    level_amounts = [level_reward for _ in range(level_count)]
            except Exception:
                level_amounts = [level_reward for _ in range(level_count)]

        return jsonify({
            'success': True,
            'level_count': level_count,
            'level_reward': level_reward,
            'level_amounts': level_amounts
        })
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500


@app.route('/api/level-settings', methods=['POST'])
@login_required
def api_update_level_settings():
    """ä¿å­˜å±‚çº§è®¾ç½®ï¼ˆä¿®å¤ç‰ˆï¼šè‡ªåŠ¨åŒæ­¥å±‚æ•°å’Œé‡‘é¢åˆ—è¡¨ï¼‰"""
    try:
        data = request.json or {}
        level_count = data.get('level_count')
        level_amounts = data.get('level_amounts') # å‰ç«¯å‘æ¥çš„æ˜¯åˆ—è¡¨æˆ–å­—å…¸

        from database import update_system_config
        import json

        # 1. å¤„ç†é‡‘é¢åˆ—è¡¨
        final_amounts = []
        if level_amounts:
            # å¦‚æœæ˜¯å­—å…¸è½¬åˆ—è¡¨ï¼Œå¦‚æœæ˜¯åˆ—è¡¨ç›´æ¥ç”¨
            if isinstance(level_amounts, dict):
                # æ‰¾å‡ºæœ€å¤§çš„keyä½œä¸ºé•¿åº¦
                max_key = max([int(k) for k in level_amounts.keys()] + [0])
                for i in range(1, max_key + 1):
                    val = level_amounts.get(str(i)) or level_amounts.get(i) or 0
                    final_amounts.append(float(val))
            elif isinstance(level_amounts, list):
                final_amounts = [float(x) for x in level_amounts]

            # ä¿å­˜é‡‘é¢é…ç½®
            update_system_config('level_amounts', json.dumps(final_amounts))

        # 2. å¤„ç†å±‚æ•° (é€»è¾‘ä¼˜åŒ–ï¼šå¦‚æœé‡‘é¢åˆ—è¡¨é•¿åº¦ > è®¾ç½®çš„å±‚æ•°ï¼Œè‡ªåŠ¨å¢åŠ å±‚æ•°)
        if level_count is not None:
            count = int(level_count)
            # å¦‚æœç”¨æˆ·å¡«å†™çš„é‡‘é¢åˆ—è¡¨æ¯”å±‚æ•°é•¿ï¼Œè¯´æ˜ç”¨æˆ·æƒ³å¢åŠ å±‚æ•°ï¼Œä»¥é‡‘é¢åˆ—è¡¨é•¿åº¦ä¸ºå‡†
            if final_amounts and len(final_amounts) > count:
                count = len(final_amounts)

            update_system_config('level_count', count)

        return jsonify({'success': True, 'message': 'å±‚çº§è®¾ç½®å·²ä¿å­˜'})
    except Exception as e:
        print(f"ä¿å­˜è®¾ç½®å‡ºé”™: {e}")
        return jsonify({'success': False, 'message': str(e)}), 500

@app.route('/api/withdrawals')
@login_required
def api_withdrawals():
    """è·å–æç°åˆ—è¡¨API"""
    page = request.args.get('page', 1, type=int)
    per_page = request.args.get('per_page', 20, type=int)
    status = request.args.get('status', 'all')
    search = request.args.get('search', '').strip()
    
    data = WebDB.get_withdrawals(page, per_page, status, search)
    return jsonify(data)

@app.route('/api/withdrawals/<int:id>/process', methods=['POST'])
@login_required
def api_process_withdrawal(id):
    """å¤„ç†æç°API"""
    data = request.json
    action = data.get('action')
    
    success, message = WebDB.process_withdrawal(id, action)
    if success:
        return jsonify({'success': True, 'message': message})
    return jsonify({'success': False, 'message': message}), 400

@app.route('/api/recharges/stats')
@login_required
def api_recharges_stats():
    """è·å–å……å€¼ç»Ÿè®¡æ•°æ®"""
    try:
        conn = get_db_conn()
        c = conn.cursor()

        # æ€»å……å€¼é‡‘é¢
        c.execute('SELECT COALESCE(SUM(amount), 0) FROM recharge_records')
        total_amount = c.fetchone()[0]

        # æˆåŠŸå……å€¼é‡‘é¢
        c.execute('SELECT COALESCE(SUM(amount), 0) FROM recharge_records WHERE status = "completed"')
        success_amount = c.fetchone()[0]

        # å¤±è´¥å……å€¼é‡‘é¢
        c.execute('SELECT COALESCE(SUM(amount), 0) FROM recharge_records WHERE status = "failed"')
        failed_amount = c.fetchone()[0]

        # æ€»æäº¤ç¬”æ•°
        c.execute('SELECT COUNT(*) FROM recharge_records')
        total_count = c.fetchone()[0]

        # æˆåŠŸç¬”æ•°
        c.execute('SELECT COUNT(*) FROM recharge_records WHERE status = "completed"')
        success_count = c.fetchone()[0]

        # å¤±è´¥ç¬”æ•°
        c.execute('SELECT COUNT(*) FROM recharge_records WHERE status = "failed"')
        failed_count = c.fetchone()[0]

        # å¾…å¤„ç†ç¬”æ•°
        c.execute('SELECT COUNT(*) FROM recharge_records WHERE status = "pending"')
        pending_count = c.fetchone()[0]

        conn.close()

        return jsonify({
            'success': True,
            'stats': {
                'total_amount': float(total_amount),
                'success_amount': float(success_amount),
                'failed_amount': float(failed_amount),
                'total_count': total_count,
                'success_count': success_count,
                'failed_count': failed_count,
                'pending_count': pending_count
            }
        })

    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500

@app.route('/api/recharges')
@login_required
def api_recharges():
    """è·å–å……å€¼è®¢å•åˆ—è¡¨"""
    try:
        page = int(request.args.get('page', 1))
        per_page = int(request.args.get('per_page', 20))
        search = request.args.get('search', '').lstrip('@').strip()
        
        conn = get_db_conn()
        c = conn.cursor()
        
        where_clause = ''
        params = []
        if search:
            where_clause = 'WHERE r.member_id LIKE ? OR r.order_id LIKE ? OR m.username LIKE ?'
            search_param = f'%{search}%'
            params = [search_param, search_param, search_param]
        
        count_query = f'SELECT COUNT(*) FROM recharge_records r LEFT JOIN members m ON r.member_id = m.telegram_id {where_clause}'
        c.execute(count_query, params)
        total = c.fetchone()[0]
        
        offset = (page - 1) * per_page

        # æ£€æŸ¥ recharge_records è¡¨ä¸­æ˜¯å¦å­˜åœ¨ remark å­—æ®µ
        c.execute("PRAGMA table_info(recharge_records)")
        cols = [r[1] for r in c.fetchall()]
        remark_present = 'remark' in cols

        if remark_present:
            query = f'''
                SELECT r.id, r.member_id, m.username, r.amount, r.order_id,
                       r.status, r.create_time, r.payment_method, r.remark
                FROM recharge_records r
                LEFT JOIN members m ON r.member_id = m.telegram_id
                {where_clause}
                ORDER BY r.create_time DESC
                LIMIT ? OFFSET ?
            '''
        else:
            query = f'''
                SELECT r.id, r.member_id, m.username, r.amount, r.order_id,
                       r.status, r.create_time, r.payment_method
                FROM recharge_records r
                LEFT JOIN members m ON r.member_id = m.telegram_id
                {where_clause}
                ORDER BY r.create_time DESC
                LIMIT ? OFFSET ?
            '''
        c.execute(query, params + [per_page, offset])

        recharges = []
        for row in c.fetchall():
            # æ ¹æ®remarkåˆ¤æ–­å……å€¼ç±»å‹
            remark = row[8] if remark_present and len(row) > 8 else ''
            recharge_type = 'å¼€é€šVIP' if remark == 'å¼€é€š' else 'å……å€¼'

            item = {
                'id': row[0],
                'telegram_id': row[1],
                'username': row[2] or '',
                'amount': row[3],
                'order_number': row[4] or '',
                'status': row[5],
                'create_time': row[6][:19] if row[6] else '',
                'payment_method': row[7] or '',
                'type': recharge_type  # æ–°å¢ç±»å‹å­—æ®µ
            }
            if remark_present:
                item['remark'] = remark
            else:
                item['remark'] = ''
            recharges.append(item)
        
        conn.close()
        
        return jsonify({
            'success': True,
            'records': recharges,
            'total': total,
            'page': page,
            'per_page': per_page
        })
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500

@app.route('/api/recharges/<int:recharge_id>/status', methods=['POST'])
@login_required
def api_update_recharge_status(recharge_id):
    """ã€æ ¸å¿ƒä¿®å¤ã€‘åå°æ‰‹åŠ¨ä¿®æ”¹å……å€¼è®¢å•çŠ¶æ€ - ç»Ÿä¸€è°ƒç”¨ process_recharge"""
    try:
        data = request.get_json() or {}
        new_status = (data.get('status') or '').strip()
        if not new_status:
            return jsonify({'success': False, 'message': 'ç¼ºå°‘çŠ¶æ€å‚æ•°'})

        conn = get_db_conn()
        c = conn.cursor()
        c.execute('SELECT member_id, amount, status, order_id FROM recharge_records WHERE id = ?', (recharge_id,))
        row = c.fetchone()
        if not row:
            conn.close()
            return jsonify({'success': False, 'message': 'è®¢å•ä¸å­˜åœ¨'})

        member_id, amount, old_status, order_id = row
        
        if new_status != 'completed':
            c.execute('UPDATE recharge_records SET status = ? WHERE id = ?', (new_status, recharge_id))
            conn.commit()
            conn.close()
            return jsonify({'success': True, 'message': 'è®¢å•çŠ¶æ€å·²æ›´æ–°'})

        if old_status == 'completed':
            conn.close()
            return jsonify({'success': True, 'message': 'è¯¥è®¢å•å·²æ˜¯å·²æ”¯ä»˜çŠ¶æ€ï¼Œæ— éœ€é‡å¤å¤„ç†'})

        # 1. æ ‡è®°æ•°æ®åº“çŠ¶æ€
        # ã€ä¿®å¤ç‚¹ã€‘æ ¹æ®é‡‘é¢åˆ¤æ–­æ˜¯å¦æ ‡è®°ä¸º"å¼€é€š"
        config = get_system_config()
        vip_price = float(config.get('vip_price', 10))
        remark_text = 'ç®¡ç†å‘˜æ‰‹åŠ¨é€šè¿‡'

        # æ£€æŸ¥æ˜¯å¦æ˜¯VIPè®¢å•ï¼ˆåŸºäºé‡‘é¢åˆ¤æ–­ï¼‰
        is_vip_order = False
        if amount >= vip_price:
            is_vip_order = True
            remark_text = 'å¼€é€š'  # å…³é”®ï¼šè¿™å°±æŠŠç±»å‹æ”¹æˆäº†"å¼€é€šVIP"

        c.execute('UPDATE recharge_records SET status = ?, remark = ? WHERE id = ?',
                 ('completed', remark_text, recharge_id))

        # 2. ç»™ç”¨æˆ·åŠ ä½™é¢ (é‡è¦ï¼)
        c.execute('UPDATE members SET balance = balance + ? WHERE telegram_id = ?', (amount, member_id))
        conn.commit()
        conn.close()

        # 3. ã€æ ¸å¿ƒã€‘å‘Šè¯‰æœºå™¨äººå»å¤„ç†ä¸šåŠ¡ï¼ˆå¼€VIPã€åˆ†çº¢ã€å‘é€šçŸ¥ï¼‰
        # è¿™ä¼šè§¦å‘ bot_logic.process_rechargeï¼Œå®ƒä¼šè‡ªåŠ¨è¯†åˆ«ä½™é¢æ˜¯å¦è¶³å¤Ÿå¼€VIP
        try:
            import bot_logic
            if hasattr(bot_logic, 'process_recharge_queue'):
                # æ¨å…¥é˜Ÿåˆ—ï¼Œè®©æœºå™¨äººçº¿ç¨‹å»æ‰£æ¬¾ã€å¼€é€šVIPã€å‘åˆ†çº¢
                bot_logic.process_recharge_queue.append({
                    'member_id': member_id,
                    'amount': amount,
                    'is_vip_order': is_vip_order  # ä¼ é€’æ­£ç¡®çš„æ ‡å¿—
                })
                print(f"[Webåå°æ‰‹åŠ¨é€šè¿‡] å·²å°†è®¢å• {order_id} æ¨é€ç»™æœºå™¨äººå¤„ç†VIPé€»è¾‘ï¼ŒVIPè®¢å•: {is_vip_order}")
        except Exception as e:
            print(f"[Webåå°æ‰‹åŠ¨é€šè¿‡] æ¨é€æœºå™¨äººé˜Ÿåˆ—å¤±è´¥: {e}")

        return jsonify({'success': True, 'message': 'å·²æ‰‹åŠ¨é€šè¿‡ï¼ŒVIPå¼€é€šå’Œåˆ†çº¢å°†åœ¨å‡ ç§’å†…è‡ªåŠ¨å¤„ç†'})
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500

@app.route('/api/members/broadcast', methods=['POST'])
@login_required
def api_members_broadcast():
    global notify_queue
    """å‘ä¼šå‘˜å‘é€ç¾¤å‘æ¶ˆæ¯"""
    try:
        data = request.get_json() or {}
        message = (data.get('message') or '').strip()
        member_ids = data.get('member_ids') or []
        send_all = bool(data.get('all'))

        if not message:
            return jsonify({'success': False, 'message': 'æ¶ˆæ¯å†…å®¹ä¸èƒ½ä¸ºç©º'})

        conn = get_db_conn()
        c = conn.cursor()

        targets = []
        if send_all:
            c.execute('SELECT telegram_id FROM members')
            targets = [row[0] for row in c.fetchall()]
        else:
            ids = []
            for mid in member_ids:
                try:
                    ids.append(int(mid))
                except (TypeError, ValueError):
                    continue
            if not ids:
                conn.close()
                return jsonify({'success': False, 'message': 'è¯·é€‰æ‹©è¦å‘é€çš„ä¼šå‘˜'})
            placeholders = ','.join(['?' for _ in ids])
            c.execute(f'SELECT telegram_id FROM members WHERE telegram_id IN ({placeholders})', ids)
            targets = [row[0] for row in c.fetchall()]

        conn.close()

        if not targets:
            return jsonify({'success': False, 'message': 'æœªæ‰¾åˆ°å¯¹åº”çš„ä¼šå‘˜'})

        # ç¡®ä¿notify_queueå·²åˆå§‹åŒ–
        if not notify_queue:
            from bot_logic import notify_queue
        
        for mid in targets:
            notify_queue.append({'member_id': mid, 'message': message})

        count = len(targets)
        return jsonify({'success': True, 'count': count, 'message': f'å·²åŠ å…¥å‘é€é˜Ÿåˆ—ï¼Œå°†å‘ {count} ä½ä¼šå‘˜å‘é€'})
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500

@app.route('/api/settings', methods=['GET'])
@login_required
def api_get_settings():
    """è·å–ç³»ç»Ÿè®¾ç½®API"""
    try:
        config = get_system_config()
        return jsonify({
            'success': True,
            'settings': {
                'levels': config.get('level_count', 10),
                'reward_per_level': config.get('level_reward', 1),
                'vip_price': config.get('vip_price', 10),
                'withdraw_threshold': config.get('withdraw_threshold', 50),
                'usdt_address': config.get('usdt_address', ''),
                'service_text': config.get('support_text', ''),
                'pinned_ad': config.get('pinned_ad', ''),
                'welcome_message': config.get('welcome_message', ''),
                'welcome_enabled': config.get('welcome_enabled', '1'),
                'auto_register_enabled': config.get('auto_register_enabled', '0')
            }
        })
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500

@app.route('/api/settings', methods=['POST'])
@login_required
def api_update_settings():
    """æ›´æ–°ç³»ç»Ÿè®¾ç½®API"""
    try:
        data = request.json
        key = data.get('key')
        value = data.get('value')
        
        if not key:
            return jsonify({'success': False, 'message': 'ç¼ºå°‘keyå‚æ•°'}), 400
        
        from database import update_system_config
        update_system_config(key, value)
        
        return jsonify({'success': True, 'message': 'è®¾ç½®å·²æ›´æ–°'})
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500

# ==================== è¡¥å…¨é—æ¼çš„ API è·¯ç”± ====================

@app.route('/api/settings/fallback-accounts')
@login_required
def api_settings_fallback_accounts():
    """æ¡æ¼è´¦å·è®¾ç½® API (å…¼å®¹æ—§å‰ç«¯)"""
    return api_fallback_accounts()

@app.route('/api/customer_services')
@login_required
def api_get_customer_services():
    """è·å–å®¢æœåˆ—è¡¨API"""
    try:
        services = DB.get_customer_services()
        # Return as an array for frontend templates that expect a plain list
        return jsonify(services)
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500


@app.route('/api/customer_services', methods=['POST'])
@login_required
def api_create_customer_service():
    """åˆ›å»ºå®¢æœ"""
    try:
        data = request.json or {}
        name = (data.get('name') or '').strip()
        link = (data.get('link') or '').strip()
        if not name or not link:
            return jsonify({'success': False, 'message': 'åç§°å’Œé“¾æ¥ä¸èƒ½ä¸ºç©º'}), 400
        conn = get_db_conn()
        c = conn.cursor()
        c.execute('INSERT INTO customer_service (name, link) VALUES (?, ?)', (name, link))
        conn.commit()
        new_id = c.lastrowid
        conn.close()
        return jsonify({'success': True, 'id': new_id})
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500


@app.route('/api/customer_services/<int:id>', methods=['GET'])
@login_required
def api_get_customer_service(id):
    """è·å–å•ä¸ªå®¢æœ"""
    try:
        conn = get_db_conn()
        c = conn.cursor()
        c.execute('SELECT id, name, link FROM customer_service WHERE id = ?', (id,))
        row = c.fetchone()
        conn.close()
        if not row:
            return jsonify({'success': False, 'message': 'å®¢æœä¸å­˜åœ¨'}), 404
        return jsonify({'id': row[0], 'name': row[1], 'link': row[2]})
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500


@app.route('/api/customer_services/<int:id>', methods=['PUT'])
@login_required
def api_update_customer_service(id):
    """æ›´æ–°å®¢æœ"""
    try:
        data = request.json or {}
        name = data.get('name')
        link = data.get('link')
        if not name and not link:
            return jsonify({'success': False, 'message': 'æ— æ›´æ–°å­—æ®µ'}), 400
        conn = get_db_conn()
        c = conn.cursor()
        if name:
            c.execute('UPDATE customer_service SET name = ? WHERE id = ?', (name, id))
        if link:
            c.execute('UPDATE customer_service SET link = ? WHERE id = ?', (link, id))
        conn.commit()
        conn.close()
        return jsonify({'success': True, 'message': 'æ›´æ–°æˆåŠŸ'})
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500


@app.route('/api/customer_services/<int:id>', methods=['DELETE'])
@login_required
def api_delete_customer_service(id):
    """åˆ é™¤å®¢æœ"""
    try:
        conn = get_db_conn()
        c = conn.cursor()
        c.execute('DELETE FROM customer_service WHERE id = ?', (id,))
        conn.commit()
        conn.close()
        return jsonify({'success': True, 'message': 'åˆ é™¤æˆåŠŸ'})
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500

@app.route('/api/payment-config', methods=['GET'])
@login_required
def api_get_payment_config():
    """è·å–æ”¯ä»˜é…ç½®API"""
    try:
        # Return payload compatible with frontend field names
        return jsonify({
            'success': True,
            'config': {
                'payment_url': PAYMENT_CONFIG.get('api_url', ''),
                'payment_token': PAYMENT_CONFIG.get('key', ''),
                'payment_rate': PAYMENT_CONFIG.get('payment_rate', 1.00),
                'payment_channel': PAYMENT_CONFIG.get('pay_type', 'trc20'),
                'payment_user_id': PAYMENT_CONFIG.get('partner_id', '')
            }
        })
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500


@app.route('/api/payment-config', methods=['POST'])
@login_required
def api_update_payment_config():
    """æ›´æ–°æ”¯ä»˜é…ç½®ï¼ˆå‰ç«¯ä¿å­˜ï¼‰"""
    try:
        data = request.json or {}
        # write to system_config and update in-memory PAYMENT_CONFIG
        from database import update_system_config
        # Support both frontend keys and alternative keys
        url = data.get('payment_url') or data.get('api_url') or data.get('paymentUrl')
        token = data.get('payment_token') or data.get('paymentToken') or data.get('key')
        rate = data.get('payment_rate') or data.get('paymentRate')
        channel = data.get('payment_channel') or data.get('paymentChannel') or data.get('pay_type')
        user_id = data.get('payment_user_id') or data.get('paymentUserId') or data.get('partner_id')

        if url is not None:
            update_system_config('payment_url', url)
            PAYMENT_CONFIG['api_url'] = url
        if token is not None:
            update_system_config('payment_token', token)
            PAYMENT_CONFIG['key'] = token
        if rate is not None:
            update_system_config('payment_rate', str(rate))
            PAYMENT_CONFIG['payment_rate'] = float(rate)
        if channel is not None:
            update_system_config('payment_channel', channel)
            PAYMENT_CONFIG['pay_type'] = channel
        if user_id is not None:
            update_system_config('payment_user_id', str(user_id))
            PAYMENT_CONFIG['partner_id'] = str(user_id)

        return jsonify({'success': True, 'message': 'æ”¯ä»˜é…ç½®å·²ä¿å­˜'})
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500

@app.route('/api/settings/bot-tokens')
@login_required
def api_bot_tokens_alias():
    """Bot Tokenåˆ—è¡¨ (å…¼å®¹æ—§å‰ç«¯)"""
    return api_bot_configs()


@app.route('/api/settings/bot-tokens', methods=['POST'])
@login_required
def api_add_bot_token_alias():
    """æ·»åŠ Bot Token (å…¼å®¹æ—§å‰ç«¯)"""
    try:
        data = request.json or {}
        token = (data.get('token') or '').strip()
        if not token:
            return jsonify({'success': False, 'message': 'Tokenä¸èƒ½ä¸ºç©º'}), 400
        conn = get_db_conn()
        c = conn.cursor()
        c.execute("SELECT COUNT(*) FROM system_config WHERE key LIKE 'bot_token_%'")
        count = c.fetchone()[0]
        key = f'bot_token_{count + 1}'
        c.execute('INSERT INTO system_config (key, value) VALUES (?, ?)', (key, token))
        conn.commit()
        conn.close()
        return jsonify({'success': True, 'message': 'Tokenå·²æ·»åŠ '})
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500


@app.route('/api/settings/bot-tokens/<int:index>', methods=['DELETE'])
@login_required
def api_delete_bot_token_alias(index):
    """åˆ é™¤Bot Token (å…¼å®¹æ—§å‰ç«¯)"""
    try:
        conn = get_db_conn()
        c = conn.cursor()
        # keys are 1-based in UI mapping to bot_token_{n}
        key = f'bot_token_{index + 1}'
        c.execute("DELETE FROM system_config WHERE key = ?", (key,))
        conn.commit()
        conn.close()
        return jsonify({'success': True, 'message': 'Tokenå·²åˆ é™¤'})
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500

@app.route('/api/fallback-accounts/<int:id>', methods=['DELETE'])
@login_required
def api_delete_fallback_account(id):
    """åˆ é™¤æ¡æ¼è´¦å·"""
    try:
        conn = get_db_conn()
        c = conn.cursor()
        c.execute('DELETE FROM fallback_accounts WHERE id = ?', (id,))
        conn.commit()
        conn.close()
        return jsonify({'success': True, 'message': 'åˆ é™¤æˆåŠŸ'})
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500

@app.route('/api/fallback-accounts/<int:id>', methods=['PUT'])
@login_required
def api_update_fallback_account(id):
    """æ›´æ–°æ¡æ¼è´¦å·"""
    try:
        data = request.json
        conn = get_db_conn()
        c = conn.cursor()
        
        updates = []
        params = []
        
        if 'username' in data:
            updates.append('username = ?')
            params.append(data['username'])
        if 'group_link' in data:
            updates.append('group_link = ?')
            params.append(data['group_link'])
        if 'is_active' in data:
            updates.append('is_active = ?')
            params.append(1 if data['is_active'] else 0)
        
        if updates:
            params.append(id)
            c.execute(f'UPDATE fallback_accounts SET {", ".join(updates)} WHERE id = ?', params)
            conn.commit()
        
        conn.close()
        return jsonify({'success': True, 'message': 'æ›´æ–°æˆåŠŸ'})
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500

# ==================== ç®¡ç†å‘˜æ‰‹åŠ¨å¼€é€šVIP API ====================

@app.route('/api/member/<int:telegram_id>/manual-vip', methods=['POST'])
@login_required
def api_manual_vip(telegram_id):
    """
    ã€æ ¸å¿ƒä¿®å¤ã€‘ç®¡ç†å‘˜æ‰‹åŠ¨å¼€é€šVIP - ç»Ÿä¸€è°ƒç”¨ distribute_vip_rewards
    åˆ é™¤æ‰€æœ‰æ‰‹å†™åˆ†çº¢é€»è¾‘
    """
    try:
        config = get_system_config()
        
        # ã€æ ¸å¿ƒä¿®å¤ã€‘ä½¿ç”¨botçš„äº‹ä»¶å¾ªç¯åˆ›å»ºå¼‚æ­¥ä»»åŠ¡
        # Flaskæ˜¯åŒæ­¥çš„ï¼Œæ‰€ä»¥é€šè¿‡äº‹ä»¶å¾ªç¯åˆ›å»ºä»»åŠ¡ï¼Œä¸ç­‰å¾…ç»“æœ
        if bot:
            bot.loop.create_task(admin_manual_vip_handler(telegram_id, config))
        else:
            # å¦‚æœbotæœªåˆå§‹åŒ–ï¼Œå»¶è¿Ÿå¯¼å…¥
            from bot_logic import bot, admin_manual_vip_handler
            bot.loop.create_task(admin_manual_vip_handler(telegram_id, config))
        
        return jsonify({
            'success': True,
            'message': 'VIPå¼€é€šä»»åŠ¡å·²æäº¤ï¼Œæ­£åœ¨åå°å¤„ç†ä¸­...'
        })
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500

def run_web():
    """Web å¯åŠ¨å…¥å£"""
    global PAYMENT_CONFIG

    # Load payment config from database
    try:
        config = get_system_config()
        PAYMENT_CONFIG.update({
            'api_url': config.get('payment_url', PAYMENT_CONFIG.get('api_url', '')),
            'partner_id': str(config.get('payment_user_id', PAYMENT_CONFIG.get('partner_id', ''))),
            'key': config.get('payment_token', PAYMENT_CONFIG.get('key', '')),
            'pay_type': config.get('payment_channel', PAYMENT_CONFIG.get('pay_type', 'trc20')),
            'payment_rate': float(config.get('payment_rate', PAYMENT_CONFIG.get('payment_rate', 1.0))),
        })
        print(f"[Webå¯åŠ¨] å·²åŠ è½½æ”¯ä»˜é…ç½®: URL={PAYMENT_CONFIG['api_url']}, PartnerID={PAYMENT_CONFIG['partner_id']}")
    except Exception as e:
        print(f"[Webå¯åŠ¨] åŠ è½½æ”¯ä»˜é…ç½®å¤±è´¥: {e}")

    # Ensure recharge_records has a remark column for admin notes
    try:
        conn = get_db_conn()
        c = conn.cursor()
        c.execute("PRAGMA table_info(recharge_records)")
        cols = [r[1] for r in c.fetchall()]
        if 'remark' not in cols:
            try:
                c.execute("ALTER TABLE recharge_records ADD COLUMN remark TEXT")
                conn.commit()
            except Exception:
                pass
        conn.close()
    except Exception:
        pass

    print("ğŸŒ Webç®¡ç†åå°å¯åŠ¨ä¸­...")
    app.run(debug=False, host='0.0.0.0', port=5051, use_reloader=False)

__all__ = ['app', 'run_web']

-e 

--- File: ./app/config.py ---
"""
é…ç½®æ–‡ä»¶
ç»Ÿä¸€ç®¡ç†é¡¹ç›®è·¯å¾„å’Œé…ç½®
"""
import os
from pathlib import Path

# é¡¹ç›®æ ¹ç›®å½•
BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))

# æ•°æ®ç›®å½•
DATA_DIR = os.path.join(BASE_DIR, 'data')

# æ•°æ®åº“è·¯å¾„
DB_PATH = os.path.join(DATA_DIR, 'bot.db')

# æ—¥å¿—è·¯å¾„
LOG_PATH = os.path.join(DATA_DIR, 'bot.log')

# PIDæ–‡ä»¶è·¯å¾„
PID_PATH = os.path.join(DATA_DIR, 'bot.pid')

# Sessionæ–‡ä»¶è·¯å¾„
SESSION_PATH = os.path.join(DATA_DIR, 'bot.session')

# é™æ€æ–‡ä»¶ä¸Šä¼ ç›®å½•
UPLOAD_DIR = os.path.join(BASE_DIR, 'static', 'uploads')

# ç¡®ä¿æ•°æ®ç›®å½•å­˜åœ¨
os.makedirs(DATA_DIR, exist_ok=True)
os.makedirs(UPLOAD_DIR, exist_ok=True)

# ==================== Telegram Bot é…ç½® ====================
# ä» .env æ–‡ä»¶æˆ–ç¯å¢ƒå˜é‡è¯»å–é…ç½®

def load_env_config():
    """ä» .env æ–‡ä»¶åŠ è½½é…ç½®"""
    env_file = os.path.join(BASE_DIR, '.env')
    config = {}
    
    # å¦‚æœå­˜åœ¨ .env æ–‡ä»¶ï¼Œè¯»å–é…ç½®
    if os.path.exists(env_file):
        with open(env_file, 'r', encoding='utf-8') as f:
            for line in f:
                line = line.strip()
                # è·³è¿‡ç©ºè¡Œå’Œæ³¨é‡Š
                if not line or line.startswith('#'):
                    continue
                # è§£æ key=value
                if '=' in line:
                    key, value = line.split('=', 1)
                    key = key.strip()
                    value = value.strip().strip('"').strip("'")
                    config[key] = value
    
    return config

# åŠ è½½ç¯å¢ƒé…ç½®
_env_config = load_env_config()

# Telegram API é…ç½®
# ä¼˜å…ˆä»ç¯å¢ƒå˜é‡è¯»å–ï¼Œå…¶æ¬¡ä» .env æ–‡ä»¶è¯»å–ï¼Œæœ€åä½¿ç”¨é»˜è®¤å€¼
API_ID = int(os.getenv('API_ID') or _env_config.get('API_ID', '21332425'))
API_HASH = os.getenv('API_HASH') or _env_config.get('API_HASH', 'f5d0cddc784e3a7a09ea9714ed01f238')
BOT_TOKEN = os.getenv('BOT_TOKEN') or _env_config.get('BOT_TOKEN', '8520376411:AAHGZMmI-oROPyrxBmDTo7_OCtpy8kHWORc')

# ç®¡ç†å‘˜ ID åˆ—è¡¨
_admin_ids_str = os.getenv('ADMIN_IDS') or _env_config.get('ADMIN_IDS', '7935612165')
ADMIN_IDS = [int(uid.strip()) for uid in _admin_ids_str.split(',') if uid.strip()]

# ä»£ç†é…ç½®
USE_PROXY = (os.getenv('USE_PROXY') or _env_config.get('USE_PROXY', 'False')).lower() == 'true'
PROXY_TYPE = os.getenv('PROXY_TYPE') or _env_config.get('PROXY_TYPE', 'socks5')
PROXY_HOST = os.getenv('PROXY_HOST') or _env_config.get('PROXY_HOST', '127.0.0.1')
PROXY_PORT = int(os.getenv('PROXY_PORT') or _env_config.get('PROXY_PORT', '7897'))

-e 

--- File: ./app/core_functions.py ---
"""
æ ¸å¿ƒåŠŸèƒ½æ¨¡å—
åŒ…å«ç¾¤ç»„æ£€æµ‹ã€å±‚çº§è®¡ç®—ã€åˆ†çº¢åˆ†é…ç­‰æ ¸å¿ƒé€»è¾‘
"""
import sqlite3
import os
import sys
from datetime import datetime, timedelta, timezone
from telethon import TelegramClient
from telethon.tl.functions.channels import GetParticipantRequest
from telethon.tl.types import ChannelParticipantAdmin, ChannelParticipantCreator

# å¯¼å…¥é…ç½®
BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
sys.path.insert(0, BASE_DIR)
from app.config import DB_PATH

# å®šä¹‰ä¸­å›½æ—¶åŒº
CN_TIMEZONE = timezone(timedelta(hours=8))

def get_cn_time():
    """è·å–ä¸­å›½æ—¶é—´å­—ç¬¦ä¸²"""
    return datetime.now(CN_TIMEZONE).isoformat()

async def verify_group_link(bot, link):
    """éªŒè¯ç¾¤é“¾æ¥ï¼Œæ£€æŸ¥æœºå™¨äººæ˜¯å¦åœ¨ç¾¤å†…ä¸”ä¸ºç®¡ç†å‘˜
    
    æ”¯æŒï¼š
    - http://t.me/ç¾¤ç”¨æˆ·å / https://t.me/ç¾¤ç”¨æˆ·å ï¼ˆå…¬å¼€ç¾¤ï¼Œæ”¯æŒè‡ªåŠ¨æ£€æµ‹ç®¡ç†å‘˜ï¼‰
    - http://t.me/+xxxx / https://t.me/+xxxx / https://t.me/joinchat/xxxx ï¼ˆç§æœ‰é‚€è¯·é“¾æ¥ï¼Œåªèƒ½è®°å½•ï¼Œæ— æ³•è‡ªåŠ¨æ£€æµ‹ç®¡ç†å‘˜ï¼‰
    
    è¿”å›ç¤ºä¾‹ï¼š
    - {'success': True, 'message': 'xxx', 'admin_checked': True/False}
    """
    try:
        # å¿…é¡»æ˜¯ http(s)://t.me/ å¼€å¤´
        if link.startswith('http://t.me/'):
            tail = link.replace('http://t.me/', '').split('?')[0]
        elif link.startswith('https://t.me/'):
            tail = link.replace('https://t.me/', '').split('?')[0]
        else:
            return {'success': False, 'message': 'é“¾æ¥æ ¼å¼ä¸æ­£ç¡®ï¼Œè¯·ä½¿ç”¨ http://t.me/ å¼€å¤´çš„é“¾æ¥', 'admin_checked': False}
        
        # 1) ç§æœ‰é‚€è¯·é“¾æ¥: +hash æˆ– joinchat/hash -> æ— æ³•ç”¨ Bot æ£€æµ‹ç®¡ç†å‘˜ï¼Œåªèƒ½è®°å½•
        if tail.startswith('+') or tail.startswith('joinchat/'):
            return {
                'success': True,
                'message': 'ç§æœ‰é‚€è¯·é“¾æ¥å·²è®°å½•ï¼ŒTelegram é™åˆ¶æ— æ³•è‡ªåŠ¨æ£€æµ‹ç®¡ç†å‘˜ï¼Œè¯·ç¡®ä¿æœºå™¨äººå·²åœ¨ç¾¤ä¸”ä¸ºç®¡ç†å‘˜',
                'admin_checked': False
            }
        
        # 2) æ™®é€šå…¬å¼€ç¾¤ç”¨æˆ·åï¼šå¯ä»¥æ£€æµ‹æ˜¯å¦ä¸ºç®¡ç†å‘˜
        username = tail
        try:
            # å°è¯•è·å–å®ä½“
            entity = await bot.get_entity(username)
        except Exception as e:
            print(f'è·å–å®ä½“å¤±è´¥: {e}')
            return {'success': False, 'message': 'æ— æ³•è®¿é—®è¯¥ç¾¤ï¼Œå¯èƒ½æ˜¯ç§æœ‰ç¾¤ or é“¾æ¥æ— æ•ˆ', 'admin_checked': False}
        
        # æ£€æŸ¥æ˜¯å¦æ˜¯ç¾¤ç»„æˆ–è¶…çº§ç¾¤
        if not hasattr(entity, 'broadcast') or entity.broadcast:
            return {'success': False, 'message': 'è¿™ä¸æ˜¯ä¸€ä¸ªç¾¤ç»„é“¾æ¥', 'admin_checked': False}
            
        # è·å–æœºå™¨äººåœ¨ç¾¤å†…çš„æƒé™
        try:
            me = await bot.get_me()
            participant = await bot(GetParticipantRequest(
                channel=entity,
                participant=me.id
            ))
            
            # æ£€æŸ¥æ˜¯å¦ä¸ºç®¡ç†å‘˜
            from telethon.tl.types import (
                ChatParticipantAdmin,
                ChatParticipantCreator,
                ChannelParticipantAdmin,
                ChannelParticipantCreator
            )
            
            is_admin = isinstance(participant.participant, (
                ChatParticipantAdmin,
                ChatParticipantCreator,
                ChannelParticipantAdmin,
                ChannelParticipantCreator
            ))
            
            if not is_admin:
                return {'success': False, 'message': 'æœºå™¨äººä¸æ˜¯ç¾¤ç®¡ç†å‘˜', 'admin_checked': True}
            
            return {'success': True, 'message': 'éªŒè¯æˆåŠŸ', 'admin_checked': True}
        
        except Exception as e:
            print(f'è·å–æƒé™å¤±è´¥: {e}')
            return {'success': False, 'message': 'æœºå™¨äººä¸åœ¨è¯¥ç¾¤å†…æˆ–æ— æ³•è·å–æƒé™', 'admin_checked': True}
            
    except Exception as e:
        print(f'éªŒè¯ç¾¤é“¾æ¥å¤±è´¥: {e}')
        return {'success': False, 'message': f'éªŒè¯å¤±è´¥: {str(e)}', 'admin_checked': False}


async def check_user_in_group(bot, user_id, group_link):
    """
    æ£€æµ‹ç”¨æˆ·æ˜¯å¦åœ¨æŒ‡å®šç¾¤ç»„ä¸­
    
    Args:
        bot: Telegramæœºå™¨äººå®¢æˆ·ç«¯
        user_id: ç”¨æˆ·Telegram ID
        group_link: ç¾¤ç»„é“¾æ¥
    
    Returns:
        bool: Trueè¡¨ç¤ºç”¨æˆ·åœ¨ç¾¤ç»„ä¸­
    """
    try:
        # ä»ç¾¤é“¾æ¥æå–ç¾¤ç»„
        if 'joinchat/' in group_link or 't.me/' in group_link:
            group_entity = await bot.get_entity(group_link)
        else:
            return False
        
        # æ£€æŸ¥ç”¨æˆ·æ˜¯å¦åœ¨ç¾¤ç»„ä¸­
        try:
            participant = await bot(GetParticipantRequest(group_entity, user_id))
            return True
        except:
            return False
    except Exception as e:
        print(f"æ£€æµ‹ç”¨æˆ·æ˜¯å¦åœ¨ç¾¤å¤±è´¥: {e}")
        return False


async def check_bot_is_admin(bot, bot_id, group_link):
    """
    æ£€æµ‹æœºå™¨äººæ˜¯å¦ä¸ºç¾¤ç»„ç®¡ç†å‘˜
    
    Args:
        bot: Telegramæœºå™¨äººå®¢æˆ·ç«¯
        bot_id: æœºå™¨äººçš„Telegram ID
        group_link: ç¾¤ç»„é“¾æ¥
    
    Returns:
        bool: Trueè¡¨ç¤ºæœºå™¨äººæ˜¯ç®¡ç†å‘˜
    """
    try:
        group_entity = await bot.get_entity(group_link)
        
        # è·å–æœºå™¨äººåœ¨ç¾¤ç»„ä¸­çš„èº«ä»½
        participant = await bot(GetParticipantRequest(group_entity, bot_id))
        
        # æ£€æŸ¥æ˜¯å¦ä¸ºç®¡ç†å‘˜æˆ–åˆ›å»ºè€…
        if isinstance(participant.participant, (ChannelParticipantAdmin, ChannelParticipantCreator)):
            return True
        return False
    except Exception as e:
        print(f"æ£€æµ‹æœºå™¨äººç®¡ç†å‘˜æƒé™å¤±è´¥: {e}")
        return False


def get_upline_chain(telegram_id, max_level=10):
    """
    è·å–ç”¨æˆ·çš„ä¸Šçº§é“¾ï¼ˆå‘ä¸ŠNå±‚ï¼‰ï¼Œå¦‚æœä¸Šçº§ä¸è¶³ï¼Œè‡ªåŠ¨ç”¨æ¡æ¼è´¦å·è¡¥é½
    
    Args:
        telegram_id: ç”¨æˆ·Telegram ID
        max_level: æœ€å¤§å±‚çº§æ•°
    
    Returns:
        list: ä¸Šçº§é“¾åˆ—è¡¨ï¼Œæ ¼å¼: [{'level': å±‚çº§, 'id': telegram_id, 'is_fallback': bool}, ...]
    """
    import sys
    import os
    sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
    from app.config import DB_PATH
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    
    upline_chain = []  # æ ¼å¼: [{'level': å±‚çº§, 'id': telegram_id, 'is_fallback': bool}]
    current_id = telegram_id
    
    # 1. å…ˆæ‰¾çœŸå®çš„æ¨èäººé“¾æ¡
    for level in range(1, max_level + 1):
        c.execute('SELECT referrer_id FROM members WHERE telegram_id = ?', (current_id,))
        row = c.fetchone()
        
        if row and row[0]:
            # æ‰¾åˆ°çœŸå®ä¸Šçº§
            upline_chain.append({'level': level, 'id': row[0], 'is_fallback': False})
            current_id = row[0]
        else:
            # æ²¡æœ‰ä¸Šçº§äº†ï¼Œåœæ­¢æŸ¥æ‰¾çœŸå®ä¸Šçº§
            break
    
    # 2. å¦‚æœå±‚æ•°ä¸è¶³ï¼Œç”¨æ¡æ¼è´¦å·è¡¥é½
    current_chain_len = len(upline_chain)
    needed_count = max_level - current_chain_len
    
    if needed_count > 0:
        # è·å–æ‰€æœ‰æ¿€æ´»çš„æ¡æ¼è´¦å·ï¼ŒæŒ‰IDæ’åº
        c.execute('SELECT telegram_id FROM fallback_accounts WHERE is_active = 1 ORDER BY id ASC')
        fallback_rows = c.fetchall()
        # è¿‡æ»¤æ‰ None å€¼ï¼Œç¡®ä¿å…¨æ˜¯æœ‰æ•ˆçš„ ID
        fallback_ids = [r[0] for r in fallback_rows if r[0] is not None]
        
        if fallback_ids:
            # ä»ä¸‹ä¸€å±‚å¼€å§‹è¡¥
            start_level = current_chain_len + 1
            for i in range(needed_count):
                current_level = start_level + i
                # å¾ªç¯ä½¿ç”¨æ¡æ¼è´¦å·: ç¬¬1ä¸ªè¡¥ä½ç”¨ç¬¬1ä¸ªè´¦å·ï¼Œç¬¬2ä¸ªç”¨ç¬¬2ä¸ª...
                # ä½¿ç”¨å–ä½™ç®—æ³•å®ç°å¾ªç¯åˆ†é…
                fb_id = fallback_ids[i % len(fallback_ids)]
                
                upline_chain.append({
                    'level': current_level, 
                    'id': fb_id, 
                    'is_fallback': True
                })
        else:
            print(f'[get_upline_chain] è­¦å‘Š: æ•°æ®åº“ä¸­æ²¡æœ‰æ¿€æ´»çš„æ¡æ¼è´¦å·ï¼Œæ— æ³•è¡¥è¶³ {needed_count} å±‚')
    
    conn.close()
    return upline_chain


def get_downline_tree(telegram_id, max_level=10):
    """
    è·å–ç”¨æˆ·çš„ä¸‹çº§æ ‘ï¼ˆå‘ä¸‹Nå±‚ï¼‰
    
    Args:
        telegram_id: ç”¨æˆ·Telegram ID
        max_level: æœ€å¤§å±‚çº§æ•°
    
    Returns:
        dict: ä¸‹çº§æ ‘ç»“æ„ {å±‚çº§: [ç”¨æˆ·åˆ—è¡¨]}
    """
    import sys
    import os
    sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
    from app.config import DB_PATH
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    
    downline_tree = {}
    current_level_ids = [telegram_id]
    
    for level in range(1, max_level + 1):
        if not current_level_ids:
            break
        
        # æŸ¥è¯¢å½“å‰å±‚çº§æ‰€æœ‰ç”¨æˆ·çš„ç›´æ¨ä¸‹çº§
        placeholders = ','.join(['?'] * len(current_level_ids))
        c.execute(f'''
            SELECT telegram_id, username, is_vip, register_time
            FROM members
            WHERE referrer_id IN ({placeholders})
        ''', current_level_ids)
        
        downlines = c.fetchall()
        if downlines:
            downline_tree[level] = [
                {
                    'telegram_id': row[0],
                    'username': row[1],
                    'is_vip': row[2],
                    'register_time': row[3]
                }
                for row in downlines
            ]
            # å‡†å¤‡ä¸‹ä¸€å±‚çš„æŸ¥è¯¢
            current_level_ids = [row[0] for row in downlines]
        else:
            break
    
    conn.close()
    return downline_tree


def calculate_team_stats(telegram_id, max_level=10):
    """
    è®¡ç®—å›¢é˜Ÿç»Ÿè®¡æ•°æ®
    
    Args:
        telegram_id: ç”¨æˆ·Telegram ID
        max_level: æœ€å¤§å±‚çº§æ•°
    
    Returns:
        dict: {'direct_count': ç›´æ¨äººæ•°, 'team_count': å›¢é˜Ÿæ€»äººæ•°, 'vip_count': VIPäººæ•°}
    """
    import sys
    import os
    sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
    from app.config import DB_PATH
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    
    # ç›´æ¨äººæ•°
    c.execute('SELECT COUNT(*) FROM members WHERE referrer_id = ?', (telegram_id,))
    direct_count = c.fetchone()[0]
    
    # å›¢é˜Ÿæ€»äººæ•°ï¼ˆé€’å½’æŸ¥è¯¢æ‰€æœ‰ä¸‹çº§ï¼‰
    team_count = 0
    vip_count = 0
    
    downline_tree = get_downline_tree(telegram_id, max_level)
    for level_users in downline_tree.values():
        team_count += len(level_users)
        vip_count += sum(1 for u in level_users if u['is_vip'])
    
    conn.close()
    return {
        'direct_count': direct_count,
        'team_count': team_count,
        'vip_count': vip_count
    }


async def check_user_conditions(bot, telegram_id):
    """
    æ£€æŸ¥ç”¨æˆ·æ˜¯å¦æ»¡è¶³æ‰€æœ‰æ¡ä»¶
    
    Returns:
        dict: {
            'is_vip': bool,
            'is_group_bound': bool,
            'is_bot_admin': bool,
            'is_joined_upline': bool,
            'missing_conditions': []  # æœªæ»¡è¶³çš„æ¡ä»¶åˆ—è¡¨
        }
    """
    import sys
    import os
    sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
    from app.config import DB_PATH
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    
    c.execute('''
        SELECT is_vip, is_group_bound, is_bot_admin, is_joined_upline, group_link
        FROM members WHERE telegram_id = ?
    ''', (telegram_id,))
    row = c.fetchone()
    conn.close()
    
    if not row:
        return None
    
    is_vip, is_group_bound, is_bot_admin, is_joined_upline, group_link = row
    
    missing_conditions = []
    if not is_vip:
        missing_conditions.append('æœªå¼€é€šVIP')
    if not is_group_bound:
        missing_conditions.append('æœªç»‘å®šç¾¤ç»„')
    if not is_bot_admin:
        missing_conditions.append('æœªè®¾ç½®æœºå™¨äººä¸ºç®¡ç†å‘˜')
    if not is_joined_upline:
        missing_conditions.append('æœªåŠ å…¥ä¸Šå±‚æ‰€æœ‰ç¾¤ç»„')
    
    return {
        'is_vip': bool(is_vip),
        'is_group_bound': bool(is_group_bound),
        'is_bot_admin': bool(is_bot_admin),
        'is_joined_upline': bool(is_joined_upline),
        'group_link': group_link or '',
        'missing_conditions': missing_conditions,
        'all_conditions_met': len(missing_conditions) == 0
    }


def update_level_path(telegram_id):
    """
    æ›´æ–°ç”¨æˆ·çš„å±‚çº§è·¯å¾„
    
    Args:
        telegram_id: ç”¨æˆ·Telegram ID
    """
    import sys
    import os
    sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
    from app.config import DB_PATH
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    
    # è·å–ä¸Šçº§é“¾
    path = []
    current_id = telegram_id
    
    for _ in range(20):  # æœ€å¤š20å±‚
        c.execute('SELECT referrer_id FROM members WHERE telegram_id = ?', (current_id,))
        row = c.fetchone()
        if not row or not row[0]:
            break
        path.insert(0, str(row[0]))
        current_id = row[0]
    
    level_path = ','.join(path) if path else ''
    
    # æ›´æ–°level_pathå­—æ®µ
    c.execute('UPDATE members SET level_path = ? WHERE telegram_id = ?', (level_path, telegram_id))
    conn.commit()
    conn.close()


def get_fallback_account(level):
    """
    è·å–æŒ‡å®šå±‚çº§çš„æ¡æ¼è´¦å·

    Args:
        level: å±‚çº§æ•° (1-10)

    Returns:
        int: æ¡æ¼è´¦å·çš„telegram_id
    """
    import sys
    import os
    sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
    from app.config import DB_PATH
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()

    # æŒ‰é¡ºåºè·å–æ¡æ¼è´¦å·
    c.execute('SELECT telegram_id FROM fallback_accounts WHERE is_active = 1 ORDER BY id LIMIT 1 OFFSET ?',
             (level - 1,))
    row = c.fetchone()
    conn.close()

    return row[0] if row else None


# ã€æ–°å¢ã€‘ç”ŸæˆVIPå¼€é€šæˆåŠŸåçš„è¯¦ç»†æ–‡æ¡ˆ
def generate_vip_success_message(telegram_id, amount, vip_price, current_balance):
    """ç”Ÿæˆç¬¦åˆè¦æ±‚çš„VIPå¼€é€šæ–‡æ¡ˆ"""
    try:
        from app.config import DB_PATH
        conn = sqlite3.connect(DB_PATH)
        c = conn.cursor()

        # è·å–ç³»ç»Ÿé…ç½®çš„å±‚æ•°
        c.execute("SELECT value FROM system_config WHERE key = 'level_count'")
        row = c.fetchone()
        level_count = int(row[0]) if row else 10
        conn.close()

        # è·å–ä¸Šçº§ç¾¤åˆ—è¡¨
        upline_chain = get_upline_chain(telegram_id, level_count)
        upline_groups_text = ""
        group_count = 0

        # å†æ¬¡è¿æ¥è·å–ä¸Šçº§è¯¦ç»†ä¿¡æ¯
        conn = sqlite3.connect(DB_PATH)
        c = conn.cursor()

        for item in upline_chain:
            if item.get('is_fallback'): continue # è·³è¿‡æ¡æ¼è´¦å·çš„ç¾¤

            uid = item['id']
            lvl = item['level']
            c.execute("SELECT username, group_link FROM members WHERE telegram_id = ?", (uid,))
            u_row = c.fetchone()

            if u_row and u_row[1]: # æœ‰ç¾¤é“¾æ¥
                # ç®€å•å¤„ç†ç¾¤å
                g_link = u_row[1]
                u_name = u_row[0] or f"ç”¨æˆ·{uid}"
                upline_groups_text += f"{lvl}. @{u_name}çš„ç¾¤\n"
                group_count += 1

        conn.close()

        msg = (
            f"ğŸ‰ å……å€¼æˆåŠŸï¼VIPå·²å¼€é€šï¼\n\n"
            f"ğŸ’° å……å€¼é‡‘é¢: {amount} U\n"
            f"ğŸ’ VIPè´¹ç”¨: {vip_price} U\n"
            f"ğŸ’µ å½“å‰ä½™é¢: {current_balance} U\n\n"
            f"âš ï¸ é‡è¦ï¼šè¯·ç«‹å³å®Œæˆä»¥ä¸‹æ“ä½œ\n\n"
            f"1ï¸âƒ£ ç»‘å®šæ‚¨çš„ç¾¤ç»„\n"
            f"2ï¸âƒ£ åŠ å…¥ä¸Šå±‚ç¾¤ç»„ï¼ˆå…±{group_count}ä¸ªï¼‰\n"
            f"{upline_groups_text}\n"
            f"å®Œæˆä»¥ä¸Šæ“ä½œåï¼Œæ‚¨çš„ä¸‹çº§å¼€é€šVIPæ—¶\n"
            f"æ‚¨æ‰èƒ½è·å¾—åˆ†çº¢ï¼"
        )
        return msg
    except Exception as e:
        print(f"[ç”Ÿæˆæ–‡æ¡ˆé”™è¯¯] {e}")
        return f"ğŸ‰ VIPå¼€é€šæˆåŠŸï¼\nèŠ±è´¹: {vip_price}U\nä½™é¢: {current_balance}U"


async def distribute_vip_rewards(bot, telegram_id, pay_amount, config):
    """
    ç»Ÿä¸€å¤„ç†VIPå¼€é€šåçš„åˆ†çº¢é€»è¾‘ï¼ˆç»ˆæä¿®å¤ç‰ˆï¼šå…¨é“¾è·¯å»é‡ + è¯¦ç»†è¯´æ˜è®°å½•ï¼‰
    """
    import sys
    import os
    sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
    from app.config import DB_PATH

    level_count = int(config.get('level_count', 10))
    reward_amount = float(config.get('level_reward', 1))

    chain = get_upline_chain(telegram_id, level_count)

    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    c.execute('SELECT username FROM members WHERE telegram_id = ?', (telegram_id,))
    user_row = c.fetchone()
    source_username = user_row[0] if user_row else str(telegram_id)
    conn.close()

    reward_stats = {'real': 0, 'fallback': 0}

    # è®°å½•æœ¬è½®å·²è·å¾—å¥–åŠ±çš„è´¦å·IDï¼ˆåŒ…æ‹¬çœŸå®ç”¨æˆ·å’Œæ¡æ¼è´¦å·ï¼‰
    used_ids_in_this_round = set()

    # é¢„å…ˆåŠ è½½æ‰€æœ‰æ´»è·ƒæ¡æ¼è´¦å·ï¼ˆæŒ‰IDæ’åºï¼‰
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    c.execute('SELECT telegram_id FROM fallback_accounts WHERE is_active = 1 ORDER BY id ASC')
    all_fb_rows = c.fetchall()
    all_valid_fbs = [r[0] for r in all_fb_rows if r[0] is not None]
    conn.close()

    for item in chain:
        level = item['level']
        upline_id = item['id']
        is_fallback_in_chain = item['is_fallback']

        if not upline_id or str(upline_id) == 'None': continue

        conn = sqlite3.connect(DB_PATH, timeout=10)
        c = conn.cursor()

        try:
            target_id_to_reward = None
            is_rewarding_fallback = False

            # ã€å…³é”®ä¿®æ”¹ã€‘ç”¨äºå­˜å‚¨å…·ä½“çš„å¤±è´¥åŸå› æè¿°
            record_description = ""
            # --- æ­¥éª¤Aï¼šç¡®å®šè¿™ä¸€å±‚çš„åŸå§‹æ¥æ”¶è€… ---
            if is_fallback_in_chain:
                # é“¾æ¡æœ¬èº«å°±æ˜¯æ¡æ¼è´¦å·ï¼ˆè¯´æ˜è¿™ä¸€å±‚æ²¡æœ‰çœŸå®ä¸Šçº§ï¼‰
                candidate_id = upline_id
                is_rewarding_fallback = True
                record_description = f"ç¬¬{level}å±‚æ— ä¸Šçº§ï¼ˆè‡ªåŠ¨æ¡æ¼ï¼‰"
            else:
                # çœŸå®ç”¨æˆ·ï¼Œæ£€æŸ¥æ¡ä»¶
                c.execute('SELECT username, is_vip, is_group_bound, is_bot_admin, is_joined_upline FROM members WHERE telegram_id = ?', (upline_id,))
                row = c.fetchone()

                # è·å–ä¸Šçº§æ˜¾ç¤ºåç§°
                upline_name = str(upline_id)
                if row and row[0]:
                    upline_name = f"@{row[0]}"

                if row and row[1] and row[2] and row[3] and row[4]:
                    # çœŸå®ç”¨æˆ·è¾¾æ ‡
                    candidate_id = upline_id
                    is_rewarding_fallback = False
                    record_description = f"ç¬¬{level}å±‚ä¸‹çº§å¼€é€šVIP"
                else:
                    # çœŸå®ç”¨æˆ·ä¸è¾¾æ ‡
                    candidate_id = None
                    is_rewarding_fallback = True

                    # ã€å…³é”®ä¿®æ”¹ã€‘æ„å»ºè¯¦ç»†çš„å¤±è´¥åŸå› 
                    fail_reasons = []
                    if not row:
                        fail_reasons.append("ç”¨æˆ·ä¸å­˜åœ¨")
                    else:
                        if not row[1]: fail_reasons.append("æœªVIP")
                        if not row[2]: fail_reasons.append("æœªç»‘ç¾¤")
                        if not row[3]: fail_reasons.append("æœªè®¾ç½®ç¾¤ç®¡")
                        if not row[4]: fail_reasons.append("æœªåŠ ç¾¤")

                    reason_str = ",".join(fail_reasons)
                    # è¿™é‡Œçš„æ ¼å¼å°±æ˜¯æ‚¨æƒ³è¦çš„ï¼šæ˜¾ç¤ºå…·ä½“å“ªä¸ªä¸Šçº§æ²¡å®Œæˆ
                    record_description = f"ä¸Šçº§ {upline_name} {reason_str}ï¼ˆè½¬å…¥æ¡æ¼ï¼‰"
                    # è®°å½•é”™è¿‡æ”¶ç›Šé€šçŸ¥
                    if row:
                        c.execute('UPDATE members SET missed_balance = missed_balance + ? WHERE telegram_id = ?',
                                 (reward_amount, upline_id))
                        # å‘é€é€šçŸ¥ç»™é‚£ä¸ªä¸äº‰æ°”çš„ä¸Šçº§
                        try:
                            await bot.send_message(
                                upline_id,
                                f"ğŸ’¸ **é”™å¤±æ”¶ç›Šé€šçŸ¥**\n\n"
                                f"æ‚¨é”™è¿‡äº† {reward_amount} U çš„æ”¶ç›Šï¼\n"
                                f"åŸå› : {reason_str}\n"
                                f"æ¥æº: ä¸‹çº§ @{source_username} (ç¬¬{level}å±‚) å¼€é€šVIP\n\n"
                                f"è¯·å°½å¿«å®Œæˆä»»åŠ¡ï¼Œä»¥å…å†æ¬¡é”™è¿‡ï¼"
                            )
                        except: pass

            # --- æ­¥éª¤Bï¼šå¦‚æœéœ€è¦æ¡æ¼ï¼Œå¯»æ‰¾æ›¿è¡¥ ---
            if is_rewarding_fallback:
                start_index = (level - 1) % len(all_valid_fbs) if all_valid_fbs else 0
                found_fb = None

                # ä¼˜å…ˆæ£€æŸ¥ chain è‡ªå¸¦çš„é‚£ä¸ªæ¡æ¼å·
                if candidate_id and candidate_id in all_valid_fbs and candidate_id not in used_ids_in_this_round:
                    found_fb = candidate_id
                else:
                    # è½®è¯¢æŸ¥æ‰¾
                    if all_valid_fbs:
                        for i in range(len(all_valid_fbs)):
                            idx = (start_index + i) % len(all_valid_fbs)
                            fb_candidate = all_valid_fbs[idx]
                            if fb_candidate not in used_ids_in_this_round:
                                found_fb = fb_candidate
                                break
                        if found_fb is None: found_fb = all_valid_fbs[start_index]

                target_id_to_reward = found_fb
            else:
                target_id_to_reward = candidate_id

            # --- æ­¥éª¤Cï¼šæ‰§è¡Œå‘æ”¾ ---
            if target_id_to_reward:
                # ç¡®ä¿è´¦å·å­˜åœ¨
                if is_rewarding_fallback:
                    c.execute('SELECT id FROM members WHERE telegram_id = ?', (target_id_to_reward,))
                    if not c.fetchone():
                        c.execute('SELECT username FROM fallback_accounts WHERE telegram_id = ?', (target_id_to_reward,))
                        fb_name = c.fetchone()
                        name = fb_name[0] if fb_name else f'fallback_{target_id_to_reward}'
                        c.execute('INSERT OR IGNORE INTO members (telegram_id, username, is_vip, register_time) VALUES (?, ?, 1, ?)',
                                 (target_id_to_reward, name, get_cn_time()))

                    c.execute('UPDATE fallback_accounts SET total_earned = total_earned + ? WHERE telegram_id = ?',
                             (reward_amount, target_id_to_reward))
                    reward_stats['fallback'] += 1
                else:
                    reward_stats['real'] += 1

                used_ids_in_this_round.add(int(target_id_to_reward))

                # æ›´æ–°ä½™é¢
                c.execute('UPDATE members SET balance = balance + ?, total_earned = total_earned + ? WHERE telegram_id = ?',
                         (reward_amount, reward_amount, target_id_to_reward))

                # ã€å…³é”®ä¿®æ”¹ã€‘å†™å…¥æ•°æ®åº“æ—¶ä½¿ç”¨ä¸Šé¢æ„å»ºå¥½çš„è¯¦ç»†è¯´æ˜
                c.execute('''INSERT INTO earnings_records (upgraded_user, earning_user, amount, description, create_time)
                           VALUES (?, ?, ?, ?, ?)''',
                           (telegram_id, target_id_to_reward, reward_amount, record_description, get_cn_time()))

                # é€šçŸ¥
                if not is_rewarding_fallback:
                    try:
                        await bot.send_message(target_id_to_reward,
                            f'ğŸ‰ è·å¾— {reward_amount} U å¥–åŠ±\næ¥æºï¼šç¬¬ {level} å±‚ä¸‹çº§ @{source_username} å¼€é€šVIP')
                    except: pass

            conn.commit()
        except Exception as e:
            print(f"[åˆ†çº¢åˆ†é…é”™è¯¯] Level {level}: {e}")
        finally:
            conn.close()

    return reward_stats
-e 

--- File: ./app/database.py ---
"""
æ•°æ®åº“å±‚ - ç»Ÿä¸€ç®¡ç†æ‰€æœ‰æ•°æ®åº“æ“ä½œ
"""
import sqlite3
import time
import os
import sys
from datetime import datetime, timedelta, timezone
from werkzeug.security import generate_password_hash
from flask_login import UserMixin

# å…¼å®¹ä¸åŒå¯¼å…¥æ–¹å¼
try:
    # ä¼˜å…ˆå°è¯•ä» app.config å¯¼å…¥ï¼ˆå½“ä½œä¸ºæ¨¡å—å¯¼å…¥æ—¶ï¼‰
    from app.config import DB_PATH
except ImportError:
    try:
        # å°è¯•ä» config å¯¼å…¥ï¼ˆå½“åœ¨ app ç›®å½•ä¸‹ç›´æ¥è¿è¡Œæ—¶ï¼‰
        from config import DB_PATH
    except ImportError:
        # å¦‚æœéƒ½å¤±è´¥ï¼Œä½¿ç”¨ç›¸å¯¹è·¯å¾„è®¡ç®—
        BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
        DATA_DIR = os.path.join(BASE_DIR, 'data')
        DB_PATH = os.path.join(DATA_DIR, 'bot.db')

# å®šä¹‰ä¸­å›½æ—¶åŒº
CN_TIMEZONE = timezone(timedelta(hours=8))

def get_cn_time():
    """è·å–ä¸­å›½æ—¶é—´å­—ç¬¦ä¸²"""
    return datetime.now(CN_TIMEZONE).isoformat()

def get_db_conn():
    """è·å–æ•°æ®åº“è¿æ¥ï¼Œè®¾ç½®è¶…æ—¶å’Œ WAL æ¨¡å¼ä»¥é¿å…é”å®š"""
    conn = sqlite3.connect(DB_PATH, timeout=10.0)
    conn.execute('PRAGMA journal_mode=WAL')
    conn.execute('PRAGMA busy_timeout=10000')
    return conn

def init_db():
    """åˆå§‹åŒ–æ•°æ®åº“è¡¨ç»“æ„"""
    conn = get_db_conn()
    c = conn.cursor()
    
    # ä¼šå‘˜è¡¨
    c.execute('''CREATE TABLE IF NOT EXISTS members (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        telegram_id INTEGER UNIQUE,
        username TEXT,
        backup_account TEXT,
        referrer_id INTEGER,
        balance REAL DEFAULT 0,
        missed_balance REAL DEFAULT 0,
        group_link TEXT,
        is_vip INTEGER DEFAULT 0,
        register_time TEXT,
        vip_time TEXT,
        is_group_bound INTEGER DEFAULT 0,
        is_bot_admin INTEGER DEFAULT 0,
        is_joined_upline INTEGER DEFAULT 0,
        level_path TEXT,
        direct_count INTEGER DEFAULT 0,
        team_count INTEGER DEFAULT 0,
        total_earned REAL DEFAULT 0,
        withdraw_address TEXT,
        FOREIGN KEY (referrer_id) REFERENCES members(telegram_id)
    )''')
    
    # å®¢æœè¡¨
    c.execute('''CREATE TABLE IF NOT EXISTS customer_service (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        name TEXT,
        link TEXT
    )''')
    
    # è¡Œä¸šèµ„æºåˆ†ç±»è¡¨
    c.execute('''CREATE TABLE IF NOT EXISTS resource_categories (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        name TEXT,
        parent_id INTEGER DEFAULT 0
    )''')
    
    # è¡Œä¸šèµ„æºè¡¨
    c.execute('''CREATE TABLE IF NOT EXISTS resources (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        category_id INTEGER,
        name TEXT,
        link TEXT,
        type TEXT,
        member_count INTEGER DEFAULT 0,
        FOREIGN KEY (category_id) REFERENCES resource_categories(id)
    )''')
    
    # æç°è®°å½•è¡¨
    c.execute('''CREATE TABLE IF NOT EXISTS withdrawals (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        member_id INTEGER,
        amount REAL,
        usdt_address TEXT,
        status TEXT DEFAULT 'pending',
        create_time TEXT,
        process_time TEXT,
        FOREIGN KEY (member_id) REFERENCES members(telegram_id)
    )''')
    
    # ç³»ç»Ÿé…ç½®è¡¨
    c.execute('''CREATE TABLE IF NOT EXISTS system_config (
        key TEXT PRIMARY KEY,
        value TEXT
    )''')

    # ç®¡ç†å‘˜è¡¨
    c.execute('''CREATE TABLE IF NOT EXISTS admin_users (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        username TEXT UNIQUE,
        password_hash TEXT
    )''')
    
    # æ”¶ç›Šè®°å½•è¡¨ï¼ˆè®°å½•è°è§¦å‘å‡çº§ã€å“ªä¸ªç”¨æˆ·è·å¾—æ”¶ç›Šã€é‡‘é¢ã€è¯´æ˜ã€æ—¶é—´ï¼‰
    c.execute('''CREATE TABLE IF NOT EXISTS earnings_records (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        upgraded_user INTEGER,     -- å‡çº§çš„å‘èµ·è€…ï¼ˆè°å¼€é€š/å‡çº§é€ æˆåˆ†çº¢ï¼‰
        earning_user INTEGER,      -- è·å¾—æ”¶ç›Šçš„ç”¨æˆ·ï¼ˆæ”¶åˆ°åˆ†çº¢çš„è´¦æˆ·ï¼‰
        amount REAL,
        description TEXT,
        create_time TEXT,
        FOREIGN KEY (earning_user) REFERENCES members(telegram_id)
    )''')
    
    # å……å€¼è®°å½•è¡¨
    c.execute('''CREATE TABLE IF NOT EXISTS recharge_records (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        member_id INTEGER,
        amount REAL,
        order_id TEXT,
        status TEXT,
        payment_method TEXT,
        create_time TEXT,
        FOREIGN KEY (member_id) REFERENCES members(telegram_id)
    )''')
    
    # æ¡æ¼è´¦å·è¡¨
    c.execute('''CREATE TABLE IF NOT EXISTS fallback_accounts (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        telegram_id INTEGER UNIQUE,
        username TEXT,
        group_link TEXT,
        total_earned REAL DEFAULT 0,
        is_active INTEGER DEFAULT 1,
        main_account_id INTEGER
    )''')

    # ç¾¤å‘é˜Ÿåˆ—è¡¨
    c.execute('''CREATE TABLE IF NOT EXISTS broadcast_queue (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        group_link TEXT,
        group_name TEXT,
        message TEXT,
        status TEXT DEFAULT 'pending',
        result TEXT,
        create_time TEXT
    )''')

    # ç¾¤å‘æ¶ˆæ¯è¡¨
    c.execute('''CREATE TABLE IF NOT EXISTS broadcast_messages (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        title TEXT,
        content TEXT,
        media_type TEXT,
        media_url TEXT,
        image_url TEXT,
        video_url TEXT,
        buttons TEXT,
        buttons_per_row INTEGER DEFAULT 2,
        schedule_enabled INTEGER DEFAULT 0,
        schedule_time TEXT,
        is_active INTEGER DEFAULT 1,
        create_time TEXT
    )''')

    # ç¾¤å‘åˆ†é…è¡¨ï¼šè®°å½•å“ªäº›ç¾¤è¢«åˆ†é…äº†å“ªäº›ç¾¤å‘å†…å®¹ï¼Œä»¥åŠå¯ç”¨çŠ¶æ€å’Œæœ€åå‘é€æ—¶é—´
    c.execute('''CREATE TABLE IF NOT EXISTS broadcast_assignments (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        group_id INTEGER,
        message_id INTEGER,
        is_active INTEGER DEFAULT 1,
        create_time TEXT,
        last_sent_time TEXT,
        FOREIGN KEY (group_id) REFERENCES member_groups(id),
        FOREIGN KEY (message_id) REFERENCES broadcast_messages(id)
    )''')

    # ä¼šå‘˜ç¾¤ç»„è¡¨
    c.execute('''CREATE TABLE IF NOT EXISTS member_groups (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        telegram_id INTEGER,
        group_id INTEGER,
        group_name TEXT,
        group_link TEXT,
        member_count INTEGER DEFAULT 0,
        bot_id INTEGER,
        is_bot_admin INTEGER DEFAULT 0,
        owner_username TEXT,
        group_type TEXT DEFAULT 'group',
        schedule_broadcast INTEGER DEFAULT 1,
        create_time TEXT,
        FOREIGN KEY (telegram_id) REFERENCES members(telegram_id)
    )''')
    
    # ç¾¤å‘æ—¥å¿—è¡¨
    c.execute('''CREATE TABLE IF NOT EXISTS broadcast_logs (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        message_id INTEGER,
        group_ids TEXT,
        status TEXT DEFAULT 'pending',
        sent_count INTEGER DEFAULT 0,
        failed_count INTEGER DEFAULT 0,
        create_time TEXT
    )''')
    
    # å¹¿å‘Šè¡¨
    c.execute('''CREATE TABLE IF NOT EXISTS advertisements (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        title TEXT,
        content TEXT,
        position TEXT DEFAULT 'top',
        is_active INTEGER DEFAULT 1,
        create_time TEXT
    )''')
    
    # æ¬¢è¿è¯­è¡¨
    c.execute('''CREATE TABLE IF NOT EXISTS welcome_messages (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        group_id TEXT,
        message TEXT,
        is_active INTEGER DEFAULT 1,
        create_time TEXT
    )''')
    
    # æœºå™¨äººé…ç½®è¡¨
    c.execute('''CREATE TABLE IF NOT EXISTS bot_configs (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        bot_token TEXT,
        bot_username TEXT,
        is_active INTEGER DEFAULT 1,
        api_id INTEGER,
        api_hash TEXT,
        create_time TEXT
    )''')

    # æ£€æŸ¥æ˜¯å¦æœ‰ç®¡ç†å‘˜ï¼Œå¦‚æœæ²¡æœ‰åˆ™åˆ›å»ºé»˜è®¤ç®¡ç†å‘˜
    c.execute('SELECT COUNT(*) FROM admin_users')
    if c.fetchone()[0] == 0:
        default_password_hash = generate_password_hash('admin')
        c.execute('INSERT INTO admin_users (username, password_hash) VALUES (?, ?)', ('admin', default_password_hash))
        print('âš ï¸ åˆ›å»ºé»˜è®¤ç®¡ç†å‘˜è´¦å·: admin / admin')
    
    conn.commit()
    conn.close()

# æ•°æ®åº“æ“ä½œç±»
class DB:
    @staticmethod
    def get_conn():
        """è·å–æ•°æ®åº“è¿æ¥"""
        return get_db_conn()
    
    @staticmethod
    def get_member(telegram_id):
        """è·å–ä¼šå‘˜ä¿¡æ¯"""
        conn = DB.get_conn()
        c = conn.cursor()
        c.execute('''
            SELECT 
                id, telegram_id, username, backup_account, referrer_id,
                balance, missed_balance, group_link, is_vip, register_time, vip_time,
                is_group_bound, is_bot_admin, is_joined_upline, level_path,
                direct_count, team_count, total_earned, withdraw_address
            FROM members WHERE telegram_id = ?
        ''', (telegram_id,))
        row = c.fetchone()
        conn.close()
        if row:
            return {
                'id': row[0], 'telegram_id': row[1], 'username': row[2],
                'backup_account': row[3], 'referrer_id': row[4], 'balance': row[5],
                'missed_balance': row[6], 'group_link': row[7], 'is_vip': row[8],
                'register_time': row[9], 'vip_time': row[10],
                'is_group_bound': row[11], 'is_bot_admin': row[12],
                'is_joined_upline': row[13], 'level_path': row[14],
                'direct_count': row[15], 'team_count': row[16],
                'total_earned': row[17], 'withdraw_address': row[18]
            }
        return None
    
    @staticmethod
    def create_member(telegram_id, username, referrer_id=None):
        """åˆ›å»ºä¼šå‘˜è®°å½•ï¼Œå¸¦é‡è¯•"""
        max_retries = 5
        for retry in range(max_retries):
            conn = DB.get_conn()
            c = conn.cursor()
            try:
                c.execute(
                    '''INSERT INTO members (telegram_id, username, referrer_id, register_time)
                        VALUES (?, ?, ?, ?)''',
                    (telegram_id, username, referrer_id, get_cn_time())
                )
                conn.commit()
                conn.close()
                return True
            except sqlite3.IntegrityError:
                conn.close()
                return True
            except sqlite3.OperationalError as e:
                conn.close()
                if 'locked' in str(e).lower() and retry < max_retries - 1:
                    time.sleep(0.2)
                    continue
                return False
            except Exception:
                conn.close()
                return False
        return False
    
    @staticmethod
    def update_member(telegram_id, **kwargs):
        """æ›´æ–°ä¼šå‘˜ä¿¡æ¯"""
        conn = DB.get_conn()
        c = conn.cursor()
        sets = ', '.join([f'{k} = ?' for k in kwargs.keys()])
        values = list(kwargs.values()) + [telegram_id]
        c.execute(f'UPDATE members SET {sets} WHERE telegram_id = ?', values)
        conn.commit()
        conn.close()
    
    @staticmethod
    def get_upline_members(telegram_id, levels=10):
        """è·å–ä¸ŠNå±‚æ¨èäººï¼ˆå·²åºŸå¼ƒï¼Œè¯·ä½¿ç”¨ core_functions.get_upline_chainï¼‰"""
        members = []
        conn = DB.get_conn()
        c = conn.cursor()
        current_id = telegram_id
        
        for _ in range(levels):
            c.execute('SELECT referrer_id FROM members WHERE telegram_id = ?', (current_id,))
            row = c.fetchone()
            if row and row[0]:
                c.execute('SELECT telegram_id, username, is_vip, balance FROM members WHERE telegram_id = ?', (row[0],))
                member_row = c.fetchone()
                if member_row:
                    members.append({
                        'telegram_id': member_row[0],
                        'username': member_row[1],
                        'is_vip': member_row[2],
                        'balance': member_row[3]
                    })
                    current_id = row[0]
                else:
                    break
            else:
                break
        conn.close()
        return members
    
    @staticmethod
    def get_downline_count(telegram_id, level=1):
        """è·å–ä¸‹Nå±‚ä¼šå‘˜æ•°é‡"""
        conn = DB.get_conn()
        c = conn.cursor()
        
        current_level_ids = [telegram_id]
        counts = []
        
        for _ in range(level):
            if not current_level_ids:
                counts.append({'total': 0, 'vip': 0})
                continue
            placeholders = ','.join(['?' for _ in current_level_ids])
            c.execute(f'SELECT telegram_id, is_vip FROM members WHERE referrer_id IN ({placeholders})', 
                     current_level_ids)
            rows = c.fetchall()
            counts.append({'total': len(rows), 'vip': sum(1 for r in rows if r[1])})
            current_level_ids = [r[0] for r in rows]
        
        conn.close()
        return counts

    @staticmethod
    def get_customer_services():
        """è·å–å®¢æœåˆ—è¡¨"""
        conn = DB.get_conn()
        c = conn.cursor()
        c.execute('SELECT * FROM customer_service')
        rows = c.fetchall()
        conn.close()
        return [{'id': r[0], 'name': r[1], 'link': r[2]} for r in rows]
    
    @staticmethod
    def get_resource_categories(parent_id=0):
        """è·å–èµ„æºåˆ†ç±»"""
        conn = DB.get_conn()
        c = conn.cursor()
        c.execute('SELECT * FROM resource_categories WHERE parent_id = ?', (parent_id,))
        rows = c.fetchall()
        conn.close()
        return [{'id': r[0], 'name': r[1]} for r in rows]
    
    @staticmethod
    def get_resources(category_id, page=1, per_page=20):
        """è·å–èµ„æºåˆ—è¡¨"""
        conn = DB.get_conn()
        c = conn.cursor()
        offset = (page - 1) * per_page
        c.execute('SELECT * FROM resources WHERE category_id = ? LIMIT ? OFFSET ?', 
                 (category_id, per_page, offset))
        rows = c.fetchall()
        c.execute('SELECT COUNT(*) FROM resources WHERE category_id = ?', (category_id,))
        total = c.fetchone()[0]
        conn.close()
        return {
            'items': [{'id': r[0], 'name': r[2], 'link': r[3], 'type': r[4], 'count': r[5]} for r in rows],
            'total': total,
            'pages': (total + per_page - 1) // per_page
        }

def get_system_config():
    """ä»æ•°æ®åº“åŠ¨æ€è¯»å–ç³»ç»Ÿé…ç½®"""
    conn = get_db_conn()
    c = conn.cursor()
    c.execute('SELECT key, value FROM system_config')
    config_rows = c.fetchall()
    
    # é»˜è®¤é…ç½®
    config = {
        'level_count': 10,
        'level_reward': 1,
        'vip_price': 10,
        'withdraw_threshold': 50,
        'support_text': 'ğŸ‘©â€ğŸ’¼ åœ¨çº¿å®¢æœ\n\næš‚æ— å®¢æœä¿¡æ¯ï¼Œè¯·è”ç³»ç®¡ç†å‘˜',
        'usdt_address': 'TUnpYkxUeawyGeMD3PGzhDkdkNYhRJcLfD',
        'pinned_ad': '',
        'welcome_message': '',
        'welcome_enabled': '1',
        'auto_register_enabled': '0'
    }
    
    key_mapping = {
        'levels': 'level_count',
        'reward_per_level': 'level_reward',
        'vip_price': 'vip_price',
        'withdraw_threshold': 'withdraw_threshold',
        'service_text': 'support_text',
        'usdt_address': 'usdt_address',
        'pinned_ad': 'pinned_ad',
        'welcome_message': 'welcome_message',
        'welcome_enabled': 'welcome_enabled',
        'level_amounts': 'level_amounts',
        'auto_register_enabled': 'auto_register_enabled'
    }
    
    for key, value in config_rows:
        if key in key_mapping:
            config_key = key_mapping[key]
            if key in ['levels', 'reward_per_level', 'vip_price', 'withdraw_threshold']:
                config[config_key] = float(value) if '.' in str(value) else int(value)
            elif key == 'level_amounts':
                # stored as JSON string -> parse to list/dict
                try:
                    import json
                    config['level_amounts'] = json.loads(value)
                except Exception:
                    config['level_amounts'] = value
            else:
                config[config_key] = value
    
    conn.close()
    return config

def update_system_config(key, value):
    """æ›´æ–°ç³»ç»Ÿé…ç½®åˆ°æ•°æ®åº“"""
    reverse_key_mapping = {
        'level_count': 'levels',
        'level_reward': 'reward_per_level',
        'vip_price': 'vip_price',
        'withdraw_threshold': 'withdraw_threshold',
        'support_text': 'service_text',
        'usdt_address': 'usdt_address'
    }
    
    db_key = reverse_key_mapping.get(key, key)
    
    conn = get_db_conn()
    c = conn.cursor()
    c.execute('''
        INSERT INTO system_config (key, value) 
        VALUES (?, ?)
        ON CONFLICT(key) DO UPDATE SET value=excluded.value
    ''', (db_key, str(value)))
    conn.commit()
    conn.close()

class AdminUser(UserMixin):
    """ç®¡ç†å‘˜ç”¨æˆ·ç±»"""
    def __init__(self, id, username, password_hash):
        self.id = id
        self.username = username
        self.password_hash = password_hash

# Webåå°æ•°æ®åº“æ“ä½œç±»ï¼ˆåˆå¹¶åçš„å®Œæ•´ç‰ˆæœ¬ï¼‰
class WebDB:
    """Webç®¡ç†åå°æ•°æ®åº“æ“ä½œ"""
    
    @staticmethod
    def get_user_by_username(username):
        """æ ¹æ®ç”¨æˆ·åè·å–ç”¨æˆ·"""
        conn = get_db_conn()
        c = conn.cursor()
        c.execute('SELECT id, username, password_hash FROM admin_users WHERE username = ?', (username,))
        row = c.fetchone()
        conn.close()
        if row:
            return AdminUser(row[0], row[1], row[2])
        return None
    
    @staticmethod
    def get_user_by_id(user_id):
        """æ ¹æ®IDè·å–ç”¨æˆ·"""
        conn = get_db_conn()
        c = conn.cursor()
        c.execute('SELECT id, username, password_hash FROM admin_users WHERE id = ?', (user_id,))
        row = c.fetchone()
        conn.close()
        if row:
            return AdminUser(row[0], row[1], row[2])
        return None
    
    @staticmethod
    def update_password(user_id, new_password):
        """æ›´æ–°å¯†ç """
        from werkzeug.security import generate_password_hash
        conn = get_db_conn()
        c = conn.cursor()
        password_hash = generate_password_hash(new_password)
        c.execute('UPDATE admin_users SET password_hash = ? WHERE id = ?', (password_hash, user_id))
        conn.commit()
        conn.close()
    
    @staticmethod
    def get_statistics():
        """è·å–ç»Ÿè®¡æ•°æ®"""
        conn = get_db_conn()
        c = conn.cursor()
        
        c.execute('SELECT COUNT(*) FROM members')
        total_members = c.fetchone()[0] or 0
        
        c.execute('SELECT COUNT(*) FROM members WHERE is_vip = 1')
        vip_members = c.fetchone()[0] or 0
        
        c.execute('SELECT COALESCE(SUM(balance), 0) FROM members')
        total_balance = c.fetchone()[0] or 0
        
        c.execute('SELECT COALESCE(SUM(missed_balance), 0) FROM members')
        total_missed = c.fetchone()[0] or 0
        
        conn.close()
        
        return {
            'total_members': total_members,
            'vip_members': vip_members,
            'total_balance': total_balance,
            'total_missed': total_missed
        }
    
    @staticmethod
    def get_chart_data():
        """è·å–å›¾è¡¨ç»Ÿè®¡æ•°æ®"""
        conn = get_db_conn()
        c = conn.cursor()
        
        # è·å–è¿‘7å¤©çš„æ³¨å†Œè¶‹åŠ¿
        from datetime import datetime, timedelta
        today = datetime.now().date()
        dates = []
        counts = []
        
        for i in range(6, -1, -1):
            date = today - timedelta(days=i)
            date_str = date.strftime('%Y-%m-%d')
            dates.append(date.strftime('%m-%d'))
            
            c.execute("SELECT COUNT(*) FROM members WHERE register_time LIKE ?", (f"{date_str}%",))
            count = c.fetchone()[0]
            counts.append(count)
            
        # è·å–VIPæ¯”ä¾‹
        c.execute('SELECT COUNT(*) FROM members WHERE is_vip = 1')
        vip_count = c.fetchone()[0]
        c.execute('SELECT COUNT(*) FROM members WHERE is_vip = 0')
        normal_count = c.fetchone()[0]
        
        conn.close()
        
        return {
            'growth': {'labels': dates, 'data': counts},
            'composition': {'vip': vip_count, 'normal': normal_count}
        }
    
    @staticmethod
    def get_withdrawals(page=1, per_page=20, status='all', search=''):
        """è·å–æç°åˆ—è¡¨"""
        conn = get_db_conn()
        c = conn.cursor()
        offset = (page - 1) * per_page
        
        try:
            search_term = search.lstrip('@').strip() if search else ''
            
            if status != 'all':
                c.execute('SELECT id, member_id, amount, usdt_address, status, create_time, process_time FROM withdrawals WHERE status = ? ORDER BY id DESC', (status,))
            else:
                c.execute('SELECT id, member_id, amount, usdt_address, status, create_time, process_time FROM withdrawals ORDER BY id DESC')
            
            all_rows = c.fetchall()
            
            results = []
            for row in all_rows:
                member_id = row[1]
                c.execute('SELECT username FROM members WHERE telegram_id = ?', (member_id,))
                user_row = c.fetchone()
                username = user_row[0] if user_row else str(member_id)
                
                if search_term:
                    if search_term.lower() not in username.lower() and search_term not in str(member_id):
                        continue
                
                results.append({
                    'id': row[0],
                    'member_id': row[1],
                    'amount': row[2],
                    'usdt_address': row[3],
                    'status': row[4],
                    'create_time': row[5],
                    'process_time': row[6],
                    'username': username
                })
            
            total = len(results)
            withdrawals = results[offset:offset + per_page]
            
            return {
                'withdrawals': withdrawals,
                'total': total,
                'page': page,
                'pages': (total + per_page - 1) // per_page if total > 0 else 1,
                'per_page': per_page
            }
        except Exception as e:
            print(f"get_withdrawals error: {e}")
            import traceback
            traceback.print_exc()
            return {'withdrawals': [], 'total': 0, 'page': 1, 'pages': 1, 'per_page': per_page}
        finally:
            conn.close()
    
    @staticmethod
    def process_withdrawal(withdrawal_id, action):
        """å¤„ç†æç°è¯·æ±‚"""
        conn = get_db_conn()
        c = conn.cursor()
        
        try:
            c.execute('SELECT member_id, amount, status FROM withdrawals WHERE id = ?', (withdrawal_id,))
            row = c.fetchone()
            
            if not row:
                return False, "è®°å½•ä¸å­˜åœ¨"
                
            member_id, amount, status = row
            
            from datetime import datetime
            now = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
            
            if action == 'approve':
                if status == 'rejected':
                    c.execute('UPDATE members SET balance = balance - ? WHERE telegram_id = ?', 
                             (amount, member_id))
                
                c.execute('UPDATE withdrawals SET status = ?, process_time = ? WHERE id = ?', 
                         ('approved', now, withdrawal_id))
                
            elif action == 'reject':
                if status != 'pending':
                    return False, "åªèƒ½æ‹’ç»å¾…å¤„ç†çš„æç°"
                
                c.execute('UPDATE withdrawals SET status = ?, process_time = ? WHERE id = ?', 
                         ('rejected', now, withdrawal_id))
                c.execute('UPDATE members SET balance = balance + ? WHERE telegram_id = ?', 
                         (amount, member_id))
            else:
                return False, "æ— æ•ˆæ“ä½œ"
                
            conn.commit()
            
            # å‘é€BOTé€šçŸ¥
            try:
                import requests
                if action == 'approve':
                    msg = f"âœ… æç°å®¡æ ¸é€šè¿‡\n\nğŸ’° é‡‘é¢: {amount} USDT\nğŸ“ è®¢å•å·: #{withdrawal_id}\nâ° æ—¶é—´: {now}\n\nè¯·æ³¨æ„æŸ¥æ”¶ï¼Œæ„Ÿè°¢æ‚¨çš„è€å¿ƒç­‰å¾…ï¼"
                else:
                    msg = f"âŒ æç°ç”³è¯·è¢«æ‹’ç»\n\nğŸ’° é‡‘é¢: {amount} USDT\nğŸ“ è®¢å•å·: #{withdrawal_id}\nâ° æ—¶é—´: {now}\n\nä½™é¢å·²é€€å›è´¦æˆ·ï¼Œå¦‚æœ‰ç–‘é—®è¯·è”ç³»å®¢æœã€‚"
                
                requests.post("http://127.0.0.1:5051/internal/notify", json={
                    'member_id': member_id, 'message': msg
                }, timeout=1)
            except:
                pass
            
            return True, "æ“ä½œæˆåŠŸ"
        except Exception as e:
            return False, str(e)
        finally:
            conn.close()
    
    @staticmethod
    def get_all_members(page=1, per_page=20, search='', filter_type='all'):
        """è·å–ä¼šå‘˜åˆ—è¡¨ï¼ˆå®Œæ•´ç‰ˆï¼Œè¿‡æ»¤æ‰æ¡æ¼è´¦å·ï¼‰"""
        conn = get_db_conn()
        c = conn.cursor()
        offset = (page - 1) * per_page
        
        search_term = search.lstrip('@').strip() if search else ''
        
        # æ„å»ºæŸ¥è¯¢æ¡ä»¶ï¼ˆä½¿ç”¨è¡¨åˆ«å mï¼‰
        where_clauses = []
        params = []

        # ã€æ ¸å¿ƒä¿®æ”¹ã€‘è¿‡æ»¤æ‰æ¡æ¼è´¦å·ï¼šæ’é™¤åœ¨ fallback_accounts è¡¨ä¸­çš„ç”¨æˆ·
        where_clauses.append('m.telegram_id NOT IN (SELECT telegram_id FROM fallback_accounts)')
        
        if filter_type == 'vip':
            where_clauses.append('m.is_vip = 1')
        elif filter_type == 'normal':
            where_clauses.append('m.is_vip = 0')
        
        if search_term:
            where_clauses.append('(m.username LIKE ? OR m.telegram_id LIKE ?)')
            params.extend([f'%{search_term}%', f'%{search_term}%'])
        
        where_sql = ' AND '.join(where_clauses) if where_clauses else '1=1'
        
        # è·å–æ€»æ•°ï¼ˆä½¿ç”¨JOINä»¥ä¿æŒä¸€è‡´æ€§ï¼‰
        c.execute(f'''
            SELECT COUNT(*) 
            FROM members m
            LEFT JOIN members r ON m.referrer_id = r.telegram_id
            WHERE {where_sql}
        ''', params)
        total = c.fetchone()[0]
        
        # è·å–åˆ†é¡µæ•°æ®ï¼ˆåŒ…å«æ‰€æœ‰å¿…è¦å­—æ®µï¼‰
        c.execute(f'''
            SELECT m.id, m.telegram_id, m.username, m.balance, m.is_vip, m.register_time, m.vip_time, 
                   m.referrer_id, m.group_link, m.missed_balance, m.total_earned,
                   m.is_group_bound, m.is_bot_admin, m.is_joined_upline, m.backup_account,
                   r.username as referrer_username
            FROM members m
            LEFT JOIN members r ON m.referrer_id = r.telegram_id
            WHERE {where_sql}
            ORDER BY m.id DESC
            LIMIT ? OFFSET ?
        ''', params + [per_page, offset])
        
        rows = c.fetchall()
        members = []
        
        # è·å–ç³»ç»Ÿé…ç½®çš„å±‚çº§æ•°
        try:
            c.execute("SELECT value FROM system_config WHERE key = 'level_count'")
            level_row = c.fetchone()
            level_count_cfg = int(level_row[0]) if level_row else 10
        except Exception:
            level_count_cfg = 10
        
        for row in rows:
            tg_id = row[1]
            # ã€æ ¸å¿ƒä¿®å¤ã€‘å®æ—¶è®¡ç®—ç›´æ¨ä¸å›¢é˜Ÿï¼ˆé¿å… team_count å…¨ä¸º 0ï¼‰
            downline_counts = DB.get_downline_count(tg_id, level_count_cfg)
            direct_count = downline_counts[0]['total'] if downline_counts else 0
            team_count = sum(item.get('total', 0) for item in downline_counts) if downline_counts else 0
            
            members.append({
                'id': row[0],  # æ·»åŠ IDå­—æ®µ
                'telegram_id': row[1],
                'username': row[2] or '',
                'balance': row[3] or 0,
                'is_vip': bool(row[4]),
                'register_time': row[5][:19] if row[5] else '',
                'vip_time': row[6][:19] if row[6] else '',
                'referrer_id': row[7],
                'referrer_username': row[15] or '',  # æ·»åŠ æ¨èäººç”¨æˆ·å
                'group_link': row[8] or '',
                'missed_balance': row[9] or 0,
                'total_earned': row[10] or 0,
                'is_group_bound': bool(row[11]),  # æ·»åŠ ç¾¤çŠ¶æ€å­—æ®µ
                'is_bot_admin': bool(row[12]),
                'is_joined_upline': bool(row[13]),
                'direct_count': direct_count,  # å®æ—¶è®¡ç®—çš„ç›´æ¨äººæ•°
                'team_count': team_count  # å®æ—¶è®¡ç®—çš„å›¢é˜Ÿäººæ•°
            })
        
        conn.close()
        
        return {
            'members': members,
            'total': total,
            'page': page,
            'per_page': per_page,
            'pages': (total + per_page - 1) // per_page
        }
    
    @staticmethod
    def get_member_detail(telegram_id):
        """è·å–ä¼šå‘˜è¯¦æƒ…"""
        conn = get_db_conn()
        c = conn.cursor()
        
        c.execute('''
            SELECT telegram_id, username, balance, is_vip, register_time, vip_time,
                   referrer_id, group_link, missed_balance, total_earned, backup_account
            FROM members WHERE telegram_id = ?
        ''', (telegram_id,))
        
        row = c.fetchone()
        conn.close()
        
        if not row:
            return None
        
        return {
            'telegram_id': row[0],
            'username': row[1] or '',
            'balance': row[2] or 0,
            'is_vip': bool(row[3]),
            'register_time': row[4][:19] if row[4] else '',
            'vip_time': row[5][:19] if row[5] else '',
            'referrer_id': row[6],
            'group_link': row[7] or '',
            'missed_balance': row[8] or 0,
            'total_earned': row[9] or 0,
            'backup_account': row[10] or ''
        }
    
    @staticmethod
    def update_member(telegram_id, data):
        """æ›´æ–°ä¼šå‘˜ä¿¡æ¯"""
        conn = get_db_conn()
        c = conn.cursor()
        
        allowed_fields = ['username', 'balance', 'is_vip', 'group_link', 'missed_balance', 'total_earned']
        updates = []
        params = []
        
        for field in allowed_fields:
            if field in data:
                updates.append(f'{field} = ?')
                params.append(data[field])
        
        if updates:
            params.append(telegram_id)
            c.execute(f'UPDATE members SET {", ".join(updates)} WHERE telegram_id = ?', params)
            conn.commit()
        
        conn.close()
    
    @staticmethod
    def delete_member(telegram_id):
        """åˆ é™¤ä¼šå‘˜"""
        conn = get_db_conn()
        c = conn.cursor()
        c.execute('DELETE FROM members WHERE telegram_id = ?', (telegram_id,))
        conn.commit()
        conn.close()

# ==================== æ•°æ®åº“å‡çº§å‡½æ•° ====================

def upgrade_members_table():
    """å‡çº§membersè¡¨ç»“æ„"""
    conn = get_db_conn()
    c = conn.cursor()
    try:
        c.execute('ALTER TABLE members ADD COLUMN is_group_bound INTEGER DEFAULT 0')
    except: pass
    try:
        c.execute('ALTER TABLE members ADD COLUMN is_bot_admin INTEGER DEFAULT 0')
    except: pass
    try:
        c.execute('ALTER TABLE members ADD COLUMN is_joined_upline INTEGER DEFAULT 0')
    except: pass
    try:
        c.execute('ALTER TABLE members ADD COLUMN level_path TEXT')
    except: pass
    try:
        c.execute('ALTER TABLE members ADD COLUMN direct_count INTEGER DEFAULT 0')
    except: pass
    try:
        c.execute('ALTER TABLE members ADD COLUMN team_count INTEGER DEFAULT 0')
    except: pass
    try:
        c.execute('ALTER TABLE members ADD COLUMN total_earned REAL DEFAULT 0')
    except: pass
    try:
        c.execute('ALTER TABLE members ADD COLUMN withdraw_address TEXT')
    except: pass
    conn.commit()
    conn.close()

def upgrade_member_groups_table():
    """å‡çº§member_groupsè¡¨ç»“æ„"""
    conn = get_db_conn()
    c = conn.cursor()
    try:
        c.execute('ALTER TABLE member_groups ADD COLUMN owner_username TEXT')
    except: pass
    try:
        c.execute('ALTER TABLE member_groups ADD COLUMN group_type TEXT DEFAULT "group"')
    except: pass
    try:
        c.execute('ALTER TABLE member_groups ADD COLUMN schedule_broadcast INTEGER DEFAULT 1')
    except: pass
    conn.commit()
    conn.close()

def upgrade_broadcast_table():
    """å‡çº§broadcast_messagesè¡¨ç»“æ„"""
    conn = get_db_conn()
    c = conn.cursor()
    try:
        c.execute('ALTER TABLE broadcast_messages ADD COLUMN image_url TEXT')
    except: pass
    try:
        c.execute('ALTER TABLE broadcast_messages ADD COLUMN video_url TEXT')
    except: pass
    try:
        c.execute('ALTER TABLE broadcast_messages ADD COLUMN buttons TEXT')
    except: pass
    try:
        c.execute('ALTER TABLE broadcast_messages ADD COLUMN buttons_per_row INTEGER DEFAULT 2')
    except: pass
    try:
        c.execute('ALTER TABLE broadcast_messages ADD COLUMN schedule_enabled INTEGER DEFAULT 0')
    except: pass
    try:
        c.execute('ALTER TABLE broadcast_messages ADD COLUMN schedule_time TEXT')
    except: pass
    try:
        c.execute('ALTER TABLE broadcast_messages ADD COLUMN broadcast_interval INTEGER DEFAULT 120')
    except: pass
    try:
        c.execute('ALTER TABLE broadcast_messages ADD COLUMN broadcast_interval INTEGER DEFAULT 120')
    except: pass
    conn.commit()
    conn.close()

def upsert_member_group(telegram_id, group_link, owner_username=None, is_bot_admin=1):
    """
    å†™å…¥æˆ–æ›´æ–° member_groups è¡¨ï¼Œä¾¿äºåå°åˆ—è¡¨å±•ç¤ºã€‚
    é»˜è®¤ is_bot_admin=1ï¼Œå› ä¸ºéªŒè¯é€šè¿‡åæ‰ä¼šè°ƒç”¨ã€‚
    """
    if not group_link:
        return
    try:
        conn = get_db_conn()
        c = conn.cursor()
        c.execute('SELECT id FROM member_groups WHERE telegram_id = ?', (telegram_id,))
        row = c.fetchone()
        now = get_cn_time()
        if row:
            c.execute(
                '''UPDATE member_groups 
                   SET group_link = ?, owner_username = COALESCE(?, owner_username)
                 WHERE id = ?''',
                (group_link, owner_username, row[0])
            )
        else:
            c.execute(
                '''INSERT INTO member_groups 
                   (telegram_id, group_name, group_link, is_bot_admin, create_time, owner_username, group_type, schedule_broadcast)
                   VALUES (?, ?, ?, ?, ?, ?, ?, ?)''',
                (telegram_id, '', group_link, is_bot_admin, now, owner_username or '', 'group', 1)
            )
        conn.commit()
        conn.close()
    except Exception as e:
        print(f'[member_groups upsert] error: {e}')

def sync_member_groups_from_members():
    """å¯åŠ¨æ—¶åŒæ­¥å·²å­˜åœ¨çš„ä¼šå‘˜ç¾¤é“¾æ¥åˆ° member_groupsï¼Œé¿å…åå°åˆ—è¡¨ä¸ºç©º"""
    try:
        conn = get_db_conn()
        c = conn.cursor()
        c.execute("SELECT telegram_id, username, group_link FROM members WHERE group_link IS NOT NULL AND group_link != ''")
        rows = c.fetchall()
        conn.close()
        for r in rows:
            tg_id, uname, glink = r
            try:
                upsert_member_group(tg_id, glink, uname or None, is_bot_admin=1)
            except Exception as inner_err:
                print(f'[sync_member_groups] å•æ¡å¤±è´¥ {tg_id}: {inner_err}')
    except Exception as e:
        print(f'[sync_member_groups] å¤±è´¥: {e}')

# åœ¨æ¨¡å—åŠ è½½æ—¶æ‰§è¡Œæ•°æ®åº“å‡çº§
upgrade_members_table()
upgrade_member_groups_table()
upgrade_broadcast_table()

-e 

--- File: ./app/payment.py ---
"""
æ”¯ä»˜ç›¸å…³åŠŸèƒ½æ¨¡å—
åŒ…å«USDTå……å€¼ã€æ”¯ä»˜è®¢å•åˆ›å»ºã€æ”¯ä»˜çŠ¶æ€æ£€æŸ¥ç­‰åŠŸèƒ½
"""
import asyncio
import time
import hashlib
import requests as req
import re
from datetime import datetime, timedelta, timezone
from telethon import Button

from config import ADMIN_IDS
from database import DB, get_cn_time, get_system_config, get_db_conn
from core_functions import update_level_path, distribute_vip_rewards, get_upline_chain

# æ”¯ä»˜é…ç½®
PAYMENT_CONFIG = {
    'api_url': 'https://usdt.qxzy7888.org/pay/',
    'partner_id': '15',
    'key': '5c9dd0b054b184f964',
    'notify_url': 'http://154.201.68.178:5051/api/payment/notify',
    'return_url': 'http://154.201.68.178:5051/payment/success',
    'pay_type': 'trc20',
    'version': '1.0'
}

# æ”¯ä»˜è®¢å•ç›¸å…³
payment_orders = {}  # å­˜å‚¨å……å€¼è®¢å•
payment_tasks = {}  # å­˜å‚¨æ”¯ä»˜æ£€æŸ¥ä»»åŠ¡
interval_time_in_seconds = 9  # æ£€æŸ¥æ”¯ä»˜é—´éš”ï¼ˆç§’ï¼‰
check_duration_seconds = 1200  # è®¢å•æœ‰æ•ˆæœŸï¼ˆç§’ï¼‰ï¼Œ20åˆ†é’Ÿ

CN_TIMEZONE = timezone(timedelta(hours=8))

def generate_payment_sign(params, key):
    """ç”Ÿæˆæ”¯ä»˜ç­¾å"""
    sorted_params = sorted([(k, v) for k, v in params.items() if v is not None and v != ''])
    sign_str = '&'.join([f'{k}={v}' for k, v in sorted_params])
    sign_str += f'&key={key}'
    return hashlib.md5(sign_str.encode()).hexdigest().upper()

def create_payment_order(amount, out_trade_no, remark=''):
    """åˆ›å»ºæ”¯ä»˜è®¢å•"""
    params = {
        'amount': f'{amount:.2f}',
        'partnerid': PAYMENT_CONFIG['partner_id'],
        'notifyUrl': PAYMENT_CONFIG['notify_url'],
        'out_trade_no': out_trade_no,
        'payType': PAYMENT_CONFIG['pay_type'],
        'returnUrl': PAYMENT_CONFIG['return_url'],
        'version': PAYMENT_CONFIG['version'],
        'format': 'json'
    }
    params['sign'] = generate_payment_sign(params, PAYMENT_CONFIG['key'])
    if remark:
        params['remark'] = remark
    try:
        print(f'[æ”¯ä»˜API] è¯·æ±‚å‚æ•°: {params}')
        response = req.post(PAYMENT_CONFIG['api_url'], data=params, timeout=10)
        result = response.json()
        print(f'[æ”¯ä»˜API] å“åº”: {result}')
        return result
    except Exception as e:
        print(f'[æ”¯ä»˜APIé”™è¯¯] {e}')
        import traceback
        traceback.print_exc()
        return None

def check_usdt_transaction(usdt_address):
    """æŸ¥è¯¢USDT TRC20åœ°å€çš„äº¤æ˜“è®°å½•"""
    try:
        api_url = f"https://api.trongrid.io/v1/accounts/{usdt_address}/transactions/trc20?limit=200&contract_address=TR7NHqjeKQxGTCi8q8ZY4pL8otSzgjLj6t"
        response = req.get(api_url, timeout=10)
        if response.status_code == 200:
            return response.json()
        return None
    except Exception as e:
        print(f"æŸ¥è¯¢USDTäº¤æ˜“å¤±è´¥: {e}")
        return None

def extract_usdt_address_from_payment_url(payment_url):
    """ä»æ”¯ä»˜é“¾æ¥é¡µé¢è§£æUSDTæ”¶æ¬¾åœ°å€"""
    if not payment_url:
        return None
    
    try:
        headers = {
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
        }
        response = req.get(payment_url, headers=headers, timeout=10, allow_redirects=True)
        
        if response.status_code == 200:
            html = response.text
            # åŒ¹é…TRC20åœ°å€æ ¼å¼ï¼šTå¼€å¤´ï¼Œ34ä¸ªå­—ç¬¦
            pattern = r'T[A-Za-z1-9]{33}'
            matches = re.findall(pattern, html)
            if matches:
                return matches[0]
    except Exception as e:
        print(f'[è§£ææ”¯ä»˜åœ°å€] å¤±è´¥: {e}')
    
    return None

async def check_payment_task(bot, order):
    """æŒç»­æ£€æŸ¥è®¢å•æ”¯ä»˜çŠ¶æ€"""
    print(f"å¼€å§‹æ£€æŸ¥è®¢å• {order['order_number']} çš„æ”¯ä»˜çŠ¶æ€")
    
    while True:
        try:
            print(f"æ­£åœ¨æ£€æŸ¥è®¢å• {order['order_number']} - é‡‘é¢: {order['amount']} U")
            
            # æŸ¥è¯¢äº¤æ˜“è®°å½•
            transaction_data = check_usdt_transaction(order['usdt_address'])
            
            if transaction_data and 'data' in transaction_data:
                current_time = datetime.now(CN_TIMEZONE)
                
                for transaction in transaction_data['data']:
                    # è·å–äº¤æ˜“æ—¶é—´
                    transaction_time = datetime.fromtimestamp(
                        transaction['block_timestamp'] / 2000,
                        tz=CN_TIMEZONE
                    )
                    
                    # æ£€æŸ¥äº¤æ˜“æ˜¯å¦åœ¨è®¢å•åˆ›å»ºåä¸”åœ¨æœ‰æ•ˆæœŸå†…
                    if transaction_time > order['created_at'] and transaction_time < (order['created_at'] + timedelta(seconds=check_duration_seconds)):
                        # è·å–äº¤æ˜“é‡‘é¢ï¼ˆUSDTçš„ç²¾åº¦æ˜¯6ä½å°æ•°ï¼‰
                        amount = float(transaction['value']) / 2000000
                        
                        print(f"å‘ç°äº¤æ˜“ - é‡‘é¢: {amount} U, è®¢å•é‡‘é¢: {order['amount']} U")
                        
                        # æ£€æŸ¥é‡‘é¢æ˜¯å¦åŒ¹é…
                        if abs(float(order['amount']) - amount) < 0.01:  # å…è®¸0.01çš„è¯¯å·®
                            print(f"è®¢å• {order['order_number']} æ”¯ä»˜æˆåŠŸï¼")
                            
                            # å¤„ç†å……å€¼ï¼ˆåˆ¤æ–­æ˜¯å¦ä¸ºVIPè®¢å•ï¼‰
                            is_vip_order = order.get('is_vip_order', False)
                            # å»¶è¿Ÿå¯¼å…¥é¿å…å¾ªç¯ä¾èµ–
                            import importlib
                            bot_logic_module = importlib.import_module('bot_logic')
                            await bot_logic_module.process_recharge(order['telegram_id'], amount, is_vip_order)
                            
                            # æ¸…ç†è®¢å•å’Œä»»åŠ¡
                            order_number = order['order_number']
                            if order_number in payment_tasks:
                                _, timeout_task = payment_tasks[order_number]
                                timeout_task.cancel()
                                del payment_tasks[order_number]
                            
                            if order_number in payment_orders:
                                del payment_orders[order_number]
                            
                            return
            
            print(f"æœªå‘ç°è®¢å• {order['order_number']} çš„æ”¯ä»˜ï¼Œ{interval_time_in_seconds}ç§’åé‡è¯•")
            await asyncio.sleep(interval_time_in_seconds)
            
        except Exception as e:
            print(f"æ£€æŸ¥æ”¯ä»˜å¼‚å¸¸: {e}")
            await asyncio.sleep(interval_time_in_seconds)

async def payment_timeout_handler(bot, order):
    """å¤„ç†è®¢å•è¶…æ—¶ï¼ˆä¿®å¤ç‰ˆï¼šå¢åŠ çŠ¶æ€äºŒæ¬¡æ£€æŸ¥ï¼Œå®Œç¾è§£å†³æ‰‹åŠ¨å…¥æ¬¾å´æç¤ºè¶…æ—¶çš„é—®é¢˜ï¼‰

    é—®é¢˜æ ¹æºï¼š
    - ä¸‰æ–¹æ”¯ä»˜åå°æ˜¾ç¤º"ç­‰å¾…æ”¯ä»˜"æ˜¯æ­£å¸¸çš„ï¼ˆå› ä¸ºç®¡ç†å‘˜æ²¡çœŸä»˜é’±ï¼‰
    - æœ¬åœ°æœºå™¨äººåå°æ˜¾ç¤º"å·²å®Œæˆ"æ˜¯ç®¡ç†å‘˜æ‰‹åŠ¨æ“ä½œçš„ç»“æœ
    - æœºå™¨äººå€’è®¡æ—¶ä»»åŠ¡é†’æ¥åï¼Œæ²¡æœ‰æ£€æŸ¥æ•°æ®åº“çŠ¶æ€å°±å‘è¶…æ—¶é€šçŸ¥

    è§£å†³æ–¹æ¡ˆï¼š
    - åœ¨å‘é€è¶…æ—¶é€šçŸ¥å‰ï¼Œå…ˆå»æ•°æ®åº“æ£€æŸ¥è®¢å•çŠ¶æ€
    - å¦‚æœæ•°æ®åº“çŠ¶æ€å·²æ˜¯completedï¼Œç›´æ¥æ‹¦æˆªè¶…æ—¶é€šçŸ¥
    """
    # 1. ç­‰å¾…è®¢å•æœ‰æ•ˆæœŸï¼ˆä¾‹å¦‚20åˆ†é’Ÿ = 1200ç§’ï¼‰
    check_duration = 1200
    await asyncio.sleep(check_duration)
    
    order_number = order['order_number']
    telegram_id = order['telegram_id']
    
    # 2. æ¸…ç†å†…å­˜ä¸­çš„ä»»åŠ¡è®°å½•ï¼ˆåœæ­¢è½®è¯¢åŒºå—é“¾ï¼‰
    if order_number in payment_orders:
        del payment_orders[order_number]
    if order_number in payment_tasks:
        del payment_tasks[order_number]

    try:
        # 3. ã€å…³é”®æ­¥éª¤ã€‘å»æ•°æ®åº“æŸ¥æœ€æ–°çš„çŠ¶æ€
        conn = get_db_conn()
        c = conn.cursor()
        c.execute("SELECT status FROM recharge_records WHERE order_id = ?", (order_number,))
        row = c.fetchone()
        conn.close()

        # 4. å¦‚æœæ•°æ®åº“æ˜¾ç¤ºå·²å®Œæˆï¼ˆç®¡ç†å‘˜æ‰‹åŠ¨ç‚¹è¿‡æˆ–å›è°ƒæˆåŠŸï¼‰ï¼Œç›´æ¥é€€å‡ºï¼Œä»€ä¹ˆéƒ½ä¸å‘
        if row and row[0] == 'completed':
            print(f"[è¶…æ—¶æ£€æŸ¥] è®¢å• {order_number} å·²ç”±ç®¡ç†å‘˜æ‰‹åŠ¨å®Œæˆæˆ–æ”¯ä»˜æˆåŠŸï¼Œæ‹¦æˆªè¶…æ—¶é€šçŸ¥")
            return
        # 5. åªæœ‰çŠ¶æ€ç¡®å®ä¸æ˜¯ completed æ—¶ï¼Œæ‰å‘è¶…æ—¶é€šçŸ¥
            await bot.send_message(
            telegram_id,
            f'â° è®¢å•å·²å…³é—­\n\nè®¢å•å·: {order_number}\né‡‘é¢: {order["amount"]} U\n\næç¤ºï¼šå¦‚æœæ‚¨å·²æ”¯ä»˜ä½†æœªåˆ°è´¦ï¼Œè¯·è”ç³»äººå·¥å®¢æœå¤„ç†ã€‚'
            )
    except Exception as e:
        print(f"[è¶…æ—¶å¤„ç†é”™è¯¯] {e}")

async def create_recharge_order(bot, event, amount, is_vip_order=False):
    """åˆ›å»ºå……å€¼è®¢å•"""
    telegram_id = event.sender_id
    order_number = f"RCH_{telegram_id}_{int(time.time())}"
    payment_result = create_payment_order(amount, order_number, f"TG{telegram_id}")
    if not payment_result or payment_result.get("code") != 200:
        await event.respond("åˆ›å»ºæ”¯ä»˜è®¢å•å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•")
        return

    # ä¿å­˜å……å€¼è®°å½•åˆ°æ•°æ®åº“
    conn = get_db_conn()
    c = conn.cursor()
    remark = "å¼€é€š" if is_vip_order else ""

    # æ£€æŸ¥è¡¨æ˜¯å¦æœ‰remarkå­—æ®µ
    c.execute("PRAGMA table_info(recharge_records)")
    columns = [col[1] for col in c.fetchall()]
    if 'remark' in columns:
        c.execute('''INSERT INTO recharge_records
                     (member_id, amount, order_id, status, payment_method, remark, create_time)
                     VALUES (?, ?, ?, ?, ?, ?, ?)''',
                  (telegram_id, amount, order_number, 'pending', 'USDT', remark, get_cn_time()))
    else:
        c.execute('''INSERT INTO recharge_records
                     (member_id, amount, order_id, status, payment_method, create_time)
                     VALUES (?, ?, ?, ?, ?, ?)''',
                  (telegram_id, amount, order_number, 'pending', 'USDT', get_cn_time()))
    conn.commit()
    conn.close()
    
    # ä¼˜å…ˆä½¿ç”¨æ”¯ä»˜å¹³å°è¿”å›çš„æ”¯ä»˜é“¾æ¥/äºŒç»´ç 
    payment_url = None
    payment_qrcode = None
    usdt_address = None
    
    if payment_result.get("code") == 200:
        data = payment_result.get("data", {})
        if isinstance(data, dict):
            # å°è¯•è·å–æ”¯ä»˜é“¾æ¥
            payment_url = data.get("url") or data.get("data", {}).get("url") or data.get("data", {}).get("qrcode")
            payment_qrcode = data.get("data", {}).get("qrcode")
            
            # å°è¯•ä»æ”¯ä»˜å¹³å°è¿”å›çš„æ•°æ®ä¸­ç›´æ¥è·å–åœ°å€ï¼ˆå¦‚æœæœ‰çš„è¯ï¼‰
            if "address" in str(data).lower() or "æ”¶æ¬¾åœ°å€" in str(data):
                data_str = str(data)
                pattern = r'T[A-Za-z1-9]{33}'
                matches = re.findall(pattern, data_str)
                if matches:
                    usdt_address = matches[0]
    
    # å¦‚æœæ²¡æœ‰ä»è¿”å›æ•°æ®ä¸­è·å–åˆ°åœ°å€ï¼Œå°è¯•ä»æ”¯ä»˜é“¾æ¥é¡µé¢å®æ—¶è§£æ
    if not usdt_address and payment_url:
        print(f'[æ”¯ä»˜åœ°å€] å¼€å§‹å®æ—¶è§£ææ”¯ä»˜é“¾æ¥: {payment_url}')
        usdt_address = extract_usdt_address_from_payment_url(payment_url)
        if usdt_address:
            print(f'[æ”¯ä»˜åœ°å€] å®æ—¶è§£ææˆåŠŸ: {usdt_address}')
        else:
            print(f'[æ”¯ä»˜åœ°å€] å®æ—¶è§£æå¤±è´¥ï¼Œæœªæ‰¾åˆ°USDTåœ°å€')
    
    # åªä½¿ç”¨å®æ—¶è§£æåˆ°çš„åœ°å€ï¼Œä¸ä½¿ç”¨ä»»ä½•ç¼“å­˜æˆ–æ‰‹åŠ¨é…ç½®
    if usdt_address:
        msg = f'''âœ… æ”¯ä»˜è®¢å•å·²åˆ›å»º

è®¢å•å·: `{order_number}`
æ”¯ä»˜é‡‘é¢: {amount:.2f} USDT

ğŸ“ è¯·è½¬è´¦åˆ°ä»¥ä¸‹åœ°å€ï¼š
`{usdt_address}`
(TRC-20ç½‘ç»œ)

âš ï¸ è®¢å•10åˆ†é’Ÿå†…æœ‰æ•ˆï¼Œè¿‡æœŸåè¯·é‡æ–°åˆ›å»º
âš ï¸ è½¬è´¦é‡‘é¢å¿…é¡»ä¸è®¢å•é‡‘é¢å®Œå…¨ä¸€è‡´
âœ… æ”¯ä»˜å®Œæˆåï¼Œç³»ç»Ÿå°†è‡ªåŠ¨åˆ°è´¦ï¼ˆçº¦1-2åˆ†é’Ÿï¼‰'''
    
        buttons = [[Button.inline("è¿”å›", b"back")]]
        await event.respond(msg, buttons=buttons, parse_mode='markdown')
        
        # ä¿å­˜è®¢å•ä¿¡æ¯å¹¶å¯åŠ¨æ”¯ä»˜æ£€æŸ¥ä»»åŠ¡
        order_info = {
            'order_number': order_number,
            'telegram_id': telegram_id,
            'amount': amount,
            'usdt_address': usdt_address,
            'created_at': datetime.now(CN_TIMEZONE),
            'is_vip_order': is_vip_order
        }
        payment_orders[order_number] = order_info
        
        # å¯åŠ¨æ”¯ä»˜æ£€æŸ¥ä»»åŠ¡
        payment_task = bot.loop.create_task(check_payment_task(bot, order_info))
        timeout_task = bot.loop.create_task(payment_timeout_handler(bot, order_info))
        payment_tasks[order_number] = (payment_task, timeout_task)
    else:
        # å¦‚æœæ— æ³•è§£æåˆ°USDTåœ°å€ï¼Œæç¤ºé”™è¯¯
        error_msg = "âŒ æ— æ³•è·å–æ”¯ä»˜åœ°å€ï¼Œè¯·ç¨åé‡è¯•"
        if payment_url:
            error_msg += f"\n\næ”¯ä»˜é“¾æ¥: {payment_url}\nï¼ˆç³»ç»Ÿæ— æ³•è§£æè¯¥é“¾æ¥ä¸­çš„æ”¶æ¬¾åœ°å€ï¼‰"
        await event.respond(
            error_msg,
            buttons=[[Button.inline("è¿”å›", b"back")]]
        )

__all__ = [
    'create_recharge_order', 'check_payment_task', 'payment_timeout_handler',
    'check_usdt_transaction', 'create_payment_order', 'generate_payment_sign',
    'extract_usdt_address_from_payment_url', 'payment_orders', 'payment_tasks',
    'PAYMENT_CONFIG'
]

-e 

--- File: ./app/bot_commands_addon.py ---
"""
æœºå™¨äººå‘½ä»¤æ‰©å±•æ¨¡å—
æ·»åŠ ç¾¤ç»„ç»‘å®šã€æ£€æµ‹ç­‰æ–°åŠŸèƒ½å‘½ä»¤
éœ€è¦åœ¨a.pyä¸­å¯¼å…¥å¹¶æ³¨å†Œè¿™äº›å‘½ä»¤
"""

from telethon import events, Button
from core_functions import check_bot_is_admin, get_upline_chain, get_downline_tree, check_user_conditions
import sqlite3


async def handle_bind_group(event, bot, DB):
    """å¤„ç†ç¾¤ç»„ç»‘å®š"""
    telegram_id = event.sender_id
    member = DB.get_member(telegram_id)
    
    if not member:
        await event.respond('è¯·å…ˆå‘é€ /start æ³¨å†Œ')
        return
    
    if not member['is_vip']:
        await event.respond('âš ï¸ è¯·å…ˆå¼€é€šVIPæ‰èƒ½ç»‘å®šç¾¤ç»„')
        return
    
    # æç¤ºç”¨æˆ·å‘é€ç¾¤é“¾æ¥
    await event.respond(
        'ğŸ“± ç¾¤ç»„ç»‘å®šæ­¥éª¤ï¼š\n\n'
        '1ï¸âƒ£ å°†æœ¬æœºå™¨äººæ‹‰å…¥æ‚¨çš„ç¾¤ç»„\n'
        '2ï¸âƒ£ å°†æœºå™¨äººè®¾ç½®ä¸ºç®¡ç†å‘˜\n'
        '3ï¸âƒ£ åœ¨æ‚¨çš„ç¾¤é‡Œè¾“å…¥ /link è·å–ç¾¤é“¾æ¥\n'
        '4ï¸âƒ£ å°†ç¾¤é“¾æ¥å‘é€ç»™æˆ‘\n\n'
        'ğŸ’¡ ç¾¤é“¾æ¥æ ¼å¼ï¼šhttps://t.me/+xxx æˆ– @groupname'
    )


async def handle_group_link_message(event, bot, DB):
    """å¤„ç†ç”¨æˆ·å‘é€çš„ç¾¤é“¾æ¥"""
    telegram_id = event.sender_id
    group_link = event.message.text.strip()
    
    # éªŒè¯é“¾æ¥æ ¼å¼
    if not (group_link.startswith('https://t.me/') or group_link.startswith('@')):
        await event.respond('âŒ ç¾¤é“¾æ¥æ ¼å¼ä¸æ­£ç¡®\n\nè¯·å‘é€å®Œæ•´çš„ç¾¤é“¾æ¥ï¼Œæ ¼å¼å¦‚ï¼š\nhttps://t.me/+xxx æˆ– @groupname')
        return
    
    member = DB.get_member(telegram_id)
    if not member or not member['is_vip']:
        return
    
    # æ£€æµ‹æœºå™¨äººæ˜¯å¦åœ¨ç¾¤å†…ä¸”ä¸ºç®¡ç†å‘˜ï¼ˆç»“æœä»…ä½œæç¤ºï¼Œä¸é˜»æ–­æ“ä½œï¼‰
    bot_id = (await bot.get_me()).id
    is_admin = await check_bot_is_admin(bot, bot_id, group_link)
    
    # æ›´æ–°æ•°æ®åº“
    conn = DB.get_conn()
    c = conn.cursor()
    c.execute('''
        UPDATE members 
        SET group_link = ?, is_group_bound = 1, is_bot_admin = ?
        WHERE telegram_id = ?
    ''', (group_link, 1 if is_admin else 0, telegram_id))
    conn.commit()
    conn.close()
    
    if is_admin:
        await event.respond(
            'âœ… ç¾¤ç»„ç»‘å®šæˆåŠŸï¼\n\n'
            f'æ‚¨çš„ç¾¤é“¾æ¥ï¼š{group_link}\n\n'
            'ğŸ‰ æ­å–œï¼æ‚¨å·²å®Œæˆç¾¤ç»„ç»‘å®šå’Œç®¡ç†å‘˜è®¾ç½®\n\n'
            'ä¸‹ä¸€æ­¥ï¼šåŠ å…¥ä¸Šå±‚ç¾¤ç»„\n'
            'å‘é€ /join_upline æŸ¥çœ‹éœ€è¦åŠ å…¥çš„ç¾¤'
        )
    else:
        await event.respond(
            'âœ… ç¾¤ç»„é“¾æ¥å·²è®°å½•\n\n'
            f'é“¾æ¥: {group_link}\n\n'
            'â„¹ï¸ æœªèƒ½è‡ªåŠ¨æ£€æµ‹ç®¡ç†å‘˜æƒé™ï¼Œè¯·ç¡®ä¿æœºå™¨äººå·²åœ¨ç¾¤ä¸”ä¸ºç®¡ç†å‘˜ï¼Œ'
            'å¦åˆ™æŸäº›éªŒè¯åŠŸèƒ½å¯èƒ½ä¸å¯ç”¨ã€‚'
        )


async def handle_join_upline(event, bot, DB, get_system_config):
    """æ˜¾ç¤ºéœ€è¦åŠ å…¥çš„ä¸Šå±‚ç¾¤åˆ—è¡¨"""
    telegram_id = event.sender_id
    member = DB.get_member(telegram_id)
    
    if not member:
        await event.respond('è¯·å…ˆå‘é€ /start æ³¨å†Œ')
        return
    
    if not member['is_vip']:
        await event.respond('âš ï¸ è¯·å…ˆå¼€é€šVIP')
        return
    
    # è·å–ä¸Šçº§é“¾
    config = get_system_config()
    max_level = int(config['level_count'])
    upline_chain = get_upline_chain(telegram_id, max_level)
    
    if not upline_chain:
        await event.respond('æ‚¨æ²¡æœ‰ä¸Šçº§ï¼Œæ— éœ€åŠ ç¾¤')
        return
    
    # è·å–ä¸Šå±‚ç¾¤åˆ—è¡¨ï¼ˆæ–°æ ¼å¼ï¼šå­—å…¸åˆ—è¡¨ï¼‰
    upline_groups = []
    for item in upline_chain:
        if item.get('is_fallback'):
            # è·³è¿‡æ¡æ¼è´¦å·
            continue
        upline_id = item['id']
        level = item['level']
        up_member = DB.get_member(upline_id)
        if up_member and up_member['group_link']:
            upline_groups.append({
                'level': level,
                'username': up_member['username'],
                'group_link': up_member['group_link']
            })
    
    if not upline_groups:
        await event.respond('ä¸Šå±‚æš‚æ— å¯åŠ å…¥çš„ç¾¤')
        return
    
    # æ„å»ºæŒ‰é’®
    buttons = []
    text = f'ğŸ“‹ éœ€è¦åŠ å…¥çš„ä¸Šå±‚ç¾¤ç»„ï¼ˆå…±{len(upline_groups)}ä¸ªï¼‰\n\n'
    
    for i, group in enumerate(upline_groups, 1):
        text += f'{i}. ç¬¬{group["level"]}å±‚ - @{group["username"]}çš„ç¾¤\n'
        buttons.append([Button.url(f'åŠ å…¥ç¬¬{group["level"]}å±‚ç¾¤', group['group_link'])])
    
    text += '\nğŸ’¡ è¯·ä¾æ¬¡åŠ å…¥æ‰€æœ‰ç¾¤ç»„ï¼Œå®Œæˆåå‘é€ /check_status æ£€æŸ¥çŠ¶æ€'
    
    await event.respond(text, buttons=buttons)


async def handle_check_status(event, bot, DB):
    """æ£€æŸ¥ç”¨æˆ·å®ŒæˆçŠ¶æ€"""
    telegram_id = event.sender_id
    member = DB.get_member(telegram_id)
    
    if not member:
        await event.respond('è¯·å…ˆå‘é€ /start æ³¨å†Œ')
        return
    
    # æ£€æŸ¥æ‰€æœ‰æ¡ä»¶
    conditions = await check_user_conditions(bot, telegram_id)
    
    if not conditions:
        await event.respond('âŒ è·å–çŠ¶æ€å¤±è´¥')
        return
    
    # ç”ŸæˆçŠ¶æ€æŠ¥å‘Š
    status_text = 'ğŸ“Š æ‚¨çš„å®ŒæˆçŠ¶æ€\n\n'
    status_text += f'âœ… VIPçŠ¶æ€ï¼š{"å·²å¼€é€š" if conditions["is_vip"] else "æœªå¼€é€š"}\n'
    status_text += f'{"âœ…" if conditions["is_group_bound"] else "âŒ"} ç¾¤ç»„ç»‘å®šï¼š{"å·²å®Œæˆ" if conditions["is_group_bound"] else "æœªå®Œæˆ"}\n'
    status_text += f'{"âœ…" if conditions["is_bot_admin"] else "âŒ"} æœºå™¨äººç®¡ç†å‘˜ï¼š{"å·²è®¾ç½®" if conditions["is_bot_admin"] else "æœªè®¾ç½®"}\n'
    status_text += f'{"âœ…" if conditions["is_joined_upline"] else "âŒ"} åŠ å…¥ä¸Šå±‚ç¾¤ï¼š{"å·²å®Œæˆ" if conditions["is_joined_upline"] else "æœªå®Œæˆ"}\n\n'
    
    if conditions['all_conditions_met']:
        status_text += 'ğŸ‰ æ­å–œï¼æ‚¨å·²å®Œæˆæ‰€æœ‰æ¡ä»¶\nç°åœ¨æ‚¨çš„ä¸‹çº§å¼€é€šVIPæ—¶ï¼Œæ‚¨å°†è·å¾—åˆ†çº¢ï¼'
    else:
        status_text += 'âš ï¸ æœªå®Œæˆçš„æ¡ä»¶ï¼š\n'
        for cond in conditions['missing_conditions']:
            status_text += f'  â€¢ {cond}\n'
        status_text += '\nğŸ’¡ å®Œæˆæ‰€æœ‰æ¡ä»¶åæ‰èƒ½è·å¾—åˆ†çº¢'
    
    await event.respond(status_text)


async def handle_my_team(event, bot, DB):
    """æŸ¥çœ‹å›¢é˜Ÿæ•°æ®"""
    telegram_id = event.sender_id
    member = DB.get_member(telegram_id)
    
    if not member:
        await event.respond('è¯·å…ˆå‘é€ /start æ³¨å†Œ')
        return
    
    if not member['is_vip']:
        await event.respond('âš ï¸ è¯·å…ˆå¼€é€šVIPæ‰èƒ½æŸ¥çœ‹å›¢é˜Ÿæ•°æ®')
        return
    
    # è·å–ä¸‹çº§æ ‘
    downline_tree = get_downline_tree(telegram_id, 10)
    
    text = 'ğŸ‘¥ æˆ‘çš„å›¢é˜Ÿæ•°æ®\n\n'
    text += f'ğŸ’ VIPçŠ¶æ€ï¼šå·²å¼€é€š\n'
    text += f'ğŸ’° å½“å‰ä½™é¢ï¼š{member["balance"]} U\n'
    text += f'ğŸ’¸ ç´¯è®¡è·å¾—ï¼š{member.get("total_earned", 0)} U\n'
    text += f'âš ï¸ ç´¯è®¡é”™è¿‡ï¼š{member["missed_balance"]} U\n\n'
    
    text += 'ğŸ“Š å›¢é˜Ÿå±‚çº§åˆ†å¸ƒï¼š\n\n'
    
    total_members = 0
    total_vip = 0
    
    for level in range(1, 11):
        if level in downline_tree:
            members = downline_tree[level]
            vip_count = sum(1 for m in members if m['is_vip'])
            total_members += len(members)
            total_vip += vip_count
            text += f'ç¬¬{level}å±‚ï¼š{len(members)}äºº (VIP:{vip_count}äºº)\n'
        else:
            text += f'ç¬¬{level}å±‚ï¼š0äºº\n'
    
    text += f'\nğŸ“ˆ å›¢é˜Ÿæ€»è®¡ï¼š{total_members}äºº\n'
    text += f'ğŸ’ VIPæ€»æ•°ï¼š{total_vip}äºº\n'
    
    await event.respond(text)


# æ·»åŠ å‘½ä»¤è¯´æ˜
COMMAND_HELP = """
ğŸ¤– ç¾¤ç»„ç®¡ç†å‘½ä»¤

/bind_group - ç»‘å®šæ‚¨çš„ç¾¤ç»„
/join_upline - æŸ¥çœ‹éœ€è¦åŠ å…¥çš„ä¸Šå±‚ç¾¤
/check_status - æ£€æŸ¥å®ŒæˆçŠ¶æ€
/my_team - æŸ¥çœ‹å›¢é˜Ÿæ•°æ®

ğŸ’¡ å®Œæˆæ‰€æœ‰æ¡ä»¶åï¼Œæ‚¨çš„ä¸‹çº§å¼€é€šVIPæ—¶
   æ‚¨å°†è·å¾— 1U åˆ†çº¢ï¼
"""
-e 

--- File: ./reset_database.py ---
#!/usr/bin/env python3
"""
æ•°æ®åº“é‡ç½®è„šæœ¬ - é‡ç½®æ•°æ®åº“å¹¶æ·»åŠ æ¡æ¼è´¦å·
âš ï¸ è­¦å‘Šï¼šæ­¤è„šæœ¬ä¼šåˆ é™¤æ‰€æœ‰æ•°æ®ï¼
"""
import os
import sys
import sqlite3
import shutil
from datetime import datetime

# æ·»åŠ é¡¹ç›®è·¯å¾„åˆ° sys.path
project_root = os.path.dirname(os.path.abspath(__file__))
sys.path.insert(0, project_root)

# ç¡®ä¿å¯ä»¥å¯¼å…¥ app æ¨¡å—
from app.config import DB_PATH, DATA_DIR
from app.database import init_db, get_db_conn, get_cn_time

def backup_database():
    """å¤‡ä»½ç°æœ‰æ•°æ®åº“"""
    if os.path.exists(DB_PATH):
        backup_path = os.path.join(DATA_DIR, f'bot_backup_{datetime.now().strftime("%Y%m%d_%H%M%S")}.db')
        shutil.copy2(DB_PATH, backup_path)
        print(f"âœ… æ•°æ®åº“å·²å¤‡ä»½åˆ°: {backup_path}")
        return backup_path
    return None

def reset_database():
    """é‡ç½®æ•°æ®åº“"""
    print("=" * 60)
    print("ğŸ—‘ï¸  å¼€å§‹é‡ç½®æ•°æ®åº“...")
    print("=" * 60)
    
    # 1. å¤‡ä»½ç°æœ‰æ•°æ®åº“
    backup_path = backup_database()
    
    # 2. åˆ é™¤ç°æœ‰æ•°æ®åº“æ–‡ä»¶
    if os.path.exists(DB_PATH):
        os.remove(DB_PATH)
        print(f"âœ… å·²åˆ é™¤ç°æœ‰æ•°æ®åº“æ–‡ä»¶: {DB_PATH}")
    
    # 3. é‡æ–°åˆå§‹åŒ–æ•°æ®åº“
    print("\nğŸ“Š é‡æ–°åˆå§‹åŒ–æ•°æ®åº“...")
    init_db()
    print("âœ… æ•°æ®åº“åˆå§‹åŒ–å®Œæˆ")
    
    return backup_path

def add_fallback_accounts():
    """æ·»åŠ æ¡æ¼è´¦å·"""
    print("\n" + "=" * 60)
    print("â• æ·»åŠ æ¡æ¼è´¦å·...")
    print("=" * 60)
    
    # æ¡æ¼è´¦å·æ•°æ®
    fallback_accounts = [
        {'telegram_id': 8889990001, 'username': 'cslb0006', 'group_link': 'https://t.me/cslb0006'},
        {'telegram_id': 8889990002, 'username': 'cslb0007', 'group_link': 'https://t.me/cslb0007'},
        {'telegram_id': 8889990003, 'username': 'cslb0008', 'group_link': 'https://t.me/cslb0008'},
        {'telegram_id': 8889990004, 'username': 'cslb0009', 'group_link': 'https://t.me/cslb0009'},
        {'telegram_id': 8889990005, 'username': 'cslb00010', 'group_link': 'https://t.me/cslb00010'},
        {'telegram_id': 8889990006, 'username': 'cslb00011', 'group_link': 'https://t.me/cslb00011'},
        {'telegram_id': 8889990007, 'username': 'cslb00012', 'group_link': 'https://t.me/cslb00012'},
        {'telegram_id': 8889990008, 'username': 'cslb00013', 'group_link': 'https://t.me/cslb00013'},
        {'telegram_id': 8889990009, 'username': 'cslb00014', 'group_link': 'https://t.me/cslb00014'},
        {'telegram_id': 88899900010, 'username': 'cslb00015', 'group_link': 'https://t.me/cslb00015'},
    ]
    
    conn = get_db_conn()
    c = conn.cursor()
    
    added_count = 0
    for account in fallback_accounts:
        try:
            # æ’å…¥æ¡æ¼è´¦å·
            c.execute('''
                INSERT INTO fallback_accounts 
                (telegram_id, username, group_link, total_earned, is_active)
                VALUES (?, ?, ?, 0, 1)
            ''', (
                account['telegram_id'],
                account['username'],
                account['group_link']
            ))
            added_count += 1
            print(f"âœ… æ·»åŠ æ¡æ¼è´¦å·: {account['telegram_id']} (@{account['username']})")
        except sqlite3.IntegrityError:
            # å¦‚æœå·²å­˜åœ¨ï¼Œæ›´æ–°ä¿¡æ¯
            c.execute('''
                UPDATE fallback_accounts 
                SET username = ?, group_link = ?, is_active = 1
                WHERE telegram_id = ?
            ''', (
                account['username'],
                account['group_link'],
                account['telegram_id']
            ))
            print(f"ğŸ”„ æ›´æ–°æ¡æ¼è´¦å·: {account['telegram_id']} (@{account['username']})")
        except Exception as e:
            print(f"âŒ æ·»åŠ æ¡æ¼è´¦å·å¤±è´¥ {account['telegram_id']}: {e}")
    
    conn.commit()
    conn.close()
    
    print(f"\nâœ… æˆåŠŸå¤„ç† {added_count} ä¸ªæ¡æ¼è´¦å·")
    return added_count

def main():
    """ä¸»å‡½æ•°"""
    print("âš ï¸" * 30)
    print("âš ï¸  è­¦å‘Šï¼šæ­¤æ“ä½œå°†åˆ é™¤æ‰€æœ‰æ•°æ®åº“æ•°æ®ï¼")
    print("âš ï¸" * 30)
    print("\næ“ä½œæ­¥éª¤ï¼š")
    print("1. å¤‡ä»½ç°æœ‰æ•°æ®åº“")
    print("2. åˆ é™¤ç°æœ‰æ•°æ®åº“")
    print("3. é‡æ–°åˆå§‹åŒ–æ•°æ®åº“")
    print("4. æ·»åŠ 10ä¸ªæ¡æ¼è´¦å·")
    print()
    
    response = input("æ˜¯å¦ç»§ç»­ï¼Ÿ(yes/no): ").strip().lower()
    
    if response != 'yes':
        print("âŒ æ“ä½œå·²å–æ¶ˆ")
        return
    
    try:
        # é‡ç½®æ•°æ®åº“
        backup_path = reset_database()
        
        # æ·»åŠ æ¡æ¼è´¦å·
        add_fallback_accounts()
        
        print("\n" + "=" * 60)
        print("âœ… æ•°æ®åº“é‡ç½®å®Œæˆï¼")
        print("=" * 60)
        if backup_path:
            print(f"ğŸ“¦ å¤‡ä»½æ–‡ä»¶: {backup_path}")
        print("\nğŸ’¡ æç¤ºï¼š")
        print("   - æ•°æ®åº“å·²é‡ç½®å¹¶åˆå§‹åŒ–")
        print("   - å·²æ·»åŠ 10ä¸ªæ¡æ¼è´¦å·")
        print("   - é»˜è®¤ç®¡ç†å‘˜è´¦å·: admin / admin")
        print("   - è¯·é‡å¯åº”ç”¨ä»¥ç”Ÿæ•ˆ")
        print("=" * 60)
        
    except Exception as e:
        print(f"\nâŒ æ“ä½œå¤±è´¥: {e}")
        import traceback
        traceback.print_exc()
        if backup_path and os.path.exists(backup_path):
            print(f"\nğŸ’¡ å¯ä»¥ä»å¤‡ä»½æ¢å¤: {backup_path}")

if __name__ == '__main__':
    main()

-e 

--- File: ./add_fallback_accounts.py ---
#!/usr/bin/env python3
"""
æ·»åŠ æ¡æ¼è´¦å·è„šæœ¬ - ä»…æ·»åŠ æ¡æ¼è´¦å·ï¼Œä¸é‡ç½®æ•°æ®åº“
"""
import os
import sys
import sqlite3

# æ·»åŠ é¡¹ç›®è·¯å¾„åˆ° sys.path
project_root = os.path.dirname(os.path.abspath(__file__))
sys.path.insert(0, project_root)

# ç¡®ä¿å¯ä»¥å¯¼å…¥ app æ¨¡å—
from app.database import get_db_conn

def add_fallback_accounts():
    """æ·»åŠ æ¡æ¼è´¦å·"""
    print("=" * 60)
    print("â• æ·»åŠ æ¡æ¼è´¦å·...")
    print("=" * 60)
    
    # æ¡æ¼è´¦å·æ•°æ®
    fallback_accounts = [
        {'telegram_id': 8889990001, 'username': 'cslb0006', 'group_link': 'https://t.me/cslb0006'},
        {'telegram_id': 8889990002, 'username': 'cslb0007', 'group_link': 'https://t.me/cslb0007'},
        {'telegram_id': 8889990003, 'username': 'cslb0008', 'group_link': 'https://t.me/cslb0008'},
        {'telegram_id': 8889990004, 'username': 'cslb0009', 'group_link': 'https://t.me/cslb0009'},
        {'telegram_id': 8889990005, 'username': 'cslb00010', 'group_link': 'https://t.me/cslb00010'},
        {'telegram_id': 8889990006, 'username': 'cslb00011', 'group_link': 'https://t.me/cslb00011'},
        {'telegram_id': 8889990007, 'username': 'cslb00012', 'group_link': 'https://t.me/cslb00012'},
        {'telegram_id': 8889990008, 'username': 'cslb00013', 'group_link': 'https://t.me/cslb00013'},
        {'telegram_id': 8889990009, 'username': 'cslb00014', 'group_link': 'https://t.me/cslb00014'},
        {'telegram_id': 88899900010, 'username': 'cslb00015', 'group_link': 'https://t.me/cslb00015'},
    ]
    
    conn = get_db_conn()
    c = conn.cursor()
    
    added_count = 0
    updated_count = 0
    error_count = 0
    
    for account in fallback_accounts:
        try:
            # æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨
            c.execute('SELECT id FROM fallback_accounts WHERE telegram_id = ?', (account['telegram_id'],))
            existing = c.fetchone()
            
            if existing:
                # æ›´æ–°ç°æœ‰è´¦å·
                c.execute('''
                    UPDATE fallback_accounts 
                    SET username = ?, group_link = ?, is_active = 1
                    WHERE telegram_id = ?
                ''', (
                    account['username'],
                    account['group_link'],
                    account['telegram_id']
                ))
                updated_count += 1
                print(f"ğŸ”„ æ›´æ–°æ¡æ¼è´¦å·: {account['telegram_id']} (@{account['username']})")
            else:
                # æ’å…¥æ–°è´¦å·
                c.execute('''
                    INSERT INTO fallback_accounts 
                    (telegram_id, username, group_link, total_earned, is_active)
                    VALUES (?, ?, ?, 0, 1)
                ''', (
                    account['telegram_id'],
                    account['username'],
                    account['group_link']
                ))
                added_count += 1
                print(f"âœ… æ·»åŠ æ¡æ¼è´¦å·: {account['telegram_id']} (@{account['username']})")
        except Exception as e:
            error_count += 1
            print(f"âŒ å¤„ç†æ¡æ¼è´¦å·å¤±è´¥ {account['telegram_id']}: {e}")
    
    conn.commit()
    conn.close()
    
    print("\n" + "=" * 60)
    print(f"âœ… å®Œæˆï¼")
    print(f"   - æ–°å¢: {added_count} ä¸ª")
    print(f"   - æ›´æ–°: {updated_count} ä¸ª")
    print(f"   - å¤±è´¥: {error_count} ä¸ª")
    print("=" * 60)

if __name__ == '__main__':
    add_fallback_accounts()

-e 

--- File: ./scripts/deploy_check.py ---
#!/usr/bin/env python3
"""
éƒ¨ç½²ç¯å¢ƒæ£€æŸ¥è„šæœ¬
ç”¨äºæ£€æŸ¥éƒ¨ç½²ç¯å¢ƒæ˜¯å¦æ»¡è¶³è¦æ±‚
"""

import sys
import os
import subprocess

def check_python_version():
    """æ£€æŸ¥Pythonç‰ˆæœ¬"""
    print("=" * 60)
    print("ğŸ“¦ æ£€æŸ¥ Python ç‰ˆæœ¬...")
    version = sys.version_info
    if version.major >= 3 and version.minor >= 7:
        print(f"âœ… Python {version.major}.{version.minor}.{version.micro} - ç¬¦åˆè¦æ±‚")
        return True
    else:
        print(f"âŒ Python {version.major}.{version.minor}.{version.micro} - éœ€è¦ Python 3.7+")
        return False

def check_dependencies():
    """æ£€æŸ¥ä¾èµ–åŒ…"""
    print("\n" + "=" * 60)
    print("ğŸ“¦ æ£€æŸ¥ä¾èµ–åŒ…...")
    
    required_packages = {
        'flask': 'Flask',
        'telethon': 'Telethon',
        'requests': 'requests',
        'werkzeug': 'werkzeug',
        'qrcode': 'qrcode',
        'PIL': 'Pillow',
        'flask_login': 'flask-login'
    }
    
    missing = []
    for module, package in required_packages.items():
        try:
            __import__(module)
            print(f"âœ… {package} - å·²å®‰è£…")
        except ImportError:
            print(f"âŒ {package} - æœªå®‰è£…")
            missing.append(package)
    
    if missing:
        print(f"\nâš ï¸  ç¼ºå°‘ä»¥ä¸‹ä¾èµ–åŒ…: {', '.join(missing)}")
        print("   è¯·è¿è¡Œ: pip3 install -r requirements.txt")
        return False
    return True

def check_files():
    """æ£€æŸ¥å¿…éœ€æ–‡ä»¶"""
    print("\n" + "=" * 60)
    print("ğŸ“ æ£€æŸ¥é¡¹ç›®æ–‡ä»¶...")
    
    required_files = [
        'a.py',
        'requirements.txt',
        'start.sh',
        'stop.sh',
        'core_functions.py',
        'bot_commands_addon.py'
    ]
    
    missing = []
    for file in required_files:
        if os.path.exists(file):
            print(f"âœ… {file} - å­˜åœ¨")
        else:
            print(f"âŒ {file} - ä¸å­˜åœ¨")
            missing.append(file)
    
    if missing:
        print(f"\nâš ï¸  ç¼ºå°‘ä»¥ä¸‹æ–‡ä»¶: {', '.join(missing)}")
        return False
    return True

def check_directories():
    """æ£€æŸ¥å¿…éœ€ç›®å½•"""
    print("\n" + "=" * 60)
    print("ğŸ“‚ æ£€æŸ¥é¡¹ç›®ç›®å½•...")
    
    required_dirs = [
        'templates',
        'static'
    ]
    
    missing = []
    for dir_name in required_dirs:
        if os.path.exists(dir_name) and os.path.isdir(dir_name):
            print(f"âœ… {dir_name}/ - å­˜åœ¨")
        else:
            print(f"âŒ {dir_name}/ - ä¸å­˜åœ¨")
            missing.append(dir_name)
    
    if missing:
        print(f"\nâš ï¸  ç¼ºå°‘ä»¥ä¸‹ç›®å½•: {', '.join(missing)}")
        return False
    return True

def check_config():
    """æ£€æŸ¥é…ç½®æ–‡ä»¶"""
    print("\n" + "=" * 60)
    print("âš™ï¸  æ£€æŸ¥é…ç½®æ–‡ä»¶...")
    
    try:
        with open('a.py', 'r', encoding='utf-8') as f:
            content = f.read()
        
        checks = {
            'API_ID': 'API_ID = ' in content,
            'API_HASH': 'API_HASH = ' in content,
            'BOT_TOKEN': 'BOT_TOKEN = ' in content,
            'ADMIN_IDS': 'ADMIN_IDS = ' in content,
        }
        
        all_ok = True
        for key, exists in checks.items():
            if exists:
                # æ£€æŸ¥æ˜¯å¦ä¸ºé»˜è®¤å€¼ï¼ˆéœ€è¦ç”¨æˆ·ä¿®æ”¹ï¼‰
                if key == 'API_ID' and '21332425' in content:
                    print(f"âš ï¸  {key} - å­˜åœ¨ä½†å¯èƒ½æ˜¯é»˜è®¤å€¼ï¼Œè¯·ç¡®è®¤å·²ä¿®æ”¹")
                elif key == 'BOT_TOKEN' and '8282974213:AAEISGP5ijUbJSBMA9N5eoygWjAB266-1UE' in content:
                    print(f"âš ï¸  {key} - å­˜åœ¨ä½†å¯èƒ½æ˜¯é»˜è®¤å€¼ï¼Œè¯·ç¡®è®¤å·²ä¿®æ”¹")
                else:
                    print(f"âœ… {key} - å·²é…ç½®")
            else:
                print(f"âŒ {key} - æœªæ‰¾åˆ°")
                all_ok = False
        
        return all_ok
    except Exception as e:
        print(f"âŒ æ— æ³•è¯»å–é…ç½®æ–‡ä»¶: {e}")
        return False

def check_permissions():
    """æ£€æŸ¥æ–‡ä»¶æƒé™"""
    print("\n" + "=" * 60)
    print("ğŸ” æ£€æŸ¥æ–‡ä»¶æƒé™...")
    
    files_to_check = ['start.sh', 'stop.sh']
    all_ok = True
    
    for file in files_to_check:
        if os.path.exists(file):
            if os.access(file, os.X_OK):
                print(f"âœ… {file} - æœ‰æ‰§è¡Œæƒé™")
            else:
                print(f"âš ï¸  {file} - æ— æ‰§è¡Œæƒé™ï¼Œè¿è¡Œ: chmod +x {file}")
                all_ok = False
        else:
            print(f"âš ï¸  {file} - ä¸å­˜åœ¨")
    
    return all_ok

def check_database():
    """æ£€æŸ¥æ•°æ®åº“"""
    print("\n" + "=" * 60)
    print("ğŸ’¾ æ£€æŸ¥æ•°æ®åº“...")
    
    if os.path.exists('bot.db'):
        size = os.path.getsize('bot.db')
        print(f"âœ… bot.db - å­˜åœ¨ ({size} å­—èŠ‚)")
        
        # æ£€æŸ¥æ˜¯å¦å¯è¯»å†™
        try:
            import sqlite3
            conn = sqlite3.connect('bot.db')
            conn.execute('SELECT 1')
            conn.close()
            print("âœ… æ•°æ®åº“å¯æ­£å¸¸è®¿é—®")
            return True
        except Exception as e:
            print(f"âŒ æ•°æ®åº“æ— æ³•è®¿é—®: {e}")
            return False
    else:
        print("â„¹ï¸  bot.db - ä¸å­˜åœ¨ï¼ˆé¦–æ¬¡è¿è¡Œä¼šè‡ªåŠ¨åˆ›å»ºï¼‰")
        return True

def check_port():
    """æ£€æŸ¥ç«¯å£å ç”¨"""
    print("\n" + "=" * 60)
    print("ğŸ”Œ æ£€æŸ¥ç«¯å£ 5051...")
    
    try:
        import socket
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        result = sock.connect_ex(('127.0.0.1', 5051))
        sock.close()
        
        if result == 0:
            print("âš ï¸  ç«¯å£ 5051 å·²è¢«å ç”¨")
            print("   å¦‚æœæœåŠ¡æ­£åœ¨è¿è¡Œï¼Œè¿™æ˜¯æ­£å¸¸çš„")
            return True
        else:
            print("âœ… ç«¯å£ 5051 å¯ç”¨")
            return True
    except Exception as e:
        print(f"âš ï¸  æ— æ³•æ£€æŸ¥ç«¯å£: {e}")
        return True

def main():
    """ä¸»å‡½æ•°"""
    print("\n" + "=" * 60)
    print("ğŸ” è£‚å˜æ¨å¹¿æœºå™¨äºº - éƒ¨ç½²ç¯å¢ƒæ£€æŸ¥")
    print("=" * 60)
    
    results = []
    
    results.append(("Pythonç‰ˆæœ¬", check_python_version()))
    results.append(("ä¾èµ–åŒ…", check_dependencies()))
    results.append(("é¡¹ç›®æ–‡ä»¶", check_files()))
    results.append(("é¡¹ç›®ç›®å½•", check_directories()))
    results.append(("é…ç½®æ–‡ä»¶", check_config()))
    results.append(("æ–‡ä»¶æƒé™", check_permissions()))
    results.append(("æ•°æ®åº“", check_database()))
    results.append(("ç«¯å£", check_port()))
    
    # æ€»ç»“
    print("\n" + "=" * 60)
    print("ğŸ“Š æ£€æŸ¥ç»“æœæ€»ç»“")
    print("=" * 60)
    
    passed = sum(1 for _, result in results if result)
    total = len(results)
    
    for name, result in results:
        status = "âœ… é€šè¿‡" if result else "âŒ å¤±è´¥"
        print(f"{name}: {status}")
    
    print("\n" + "=" * 60)
    if passed == total:
        print("ğŸ‰ æ‰€æœ‰æ£€æŸ¥é€šè¿‡ï¼å¯ä»¥å¼€å§‹éƒ¨ç½²äº†ã€‚")
        print("\nä¸‹ä¸€æ­¥ï¼š")
        print("1. ç¡®è®¤ a.py ä¸­çš„é…ç½®å·²æ­£ç¡®ä¿®æ”¹")
        print("2. è¿è¡Œ: ./start.sh å¯åŠ¨æœåŠ¡")
        print("3. è®¿é—®: http://ä½ çš„IP:5051 ç™»å½•ç®¡ç†åå°")
    else:
        print(f"âš ï¸  æœ‰ {total - passed} é¡¹æ£€æŸ¥æœªé€šè¿‡ï¼Œè¯·å…ˆè§£å†³è¿™äº›é—®é¢˜ã€‚")
        print("\nè¯·å‚è€ƒ éƒ¨ç½²æŒ‡å—.md è·å–è¯¦ç»†å¸®åŠ©ã€‚")
    print("=" * 60 + "\n")
    
    return passed == total

if __name__ == '__main__':
    success = main()
    sys.exit(0 if success else 1)

-e 

--- File: ./cleanup_database.py ---
#!/usr/bin/env python3
"""
æ•°æ®åº“æ¸…ç†è„šæœ¬ - æ¸…ç†å¹½çµç”¨æˆ·å’Œæ— æ•ˆæ•°æ®
æ‰§è¡Œå‰è¯·å…ˆå¤‡ä»½æ•°æ®åº“ï¼
"""
import sqlite3
import sys
import os

# æ·»åŠ é¡¹ç›®è·¯å¾„
sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))
from app.config import DB_PATH

def cleanup_database():
    """æ¸…ç†æ•°æ®åº“ä¸­çš„è„æ•°æ®"""
    print("=" * 60)
    print("å¼€å§‹æ¸…ç†æ•°æ®åº“è„æ•°æ®...")
    print("=" * 60)
    
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    
    try:
        # 1. åˆ é™¤æ— æ•ˆçš„å¹½çµç”¨æˆ·
        print("\n1. åˆ é™¤æ— æ•ˆçš„å¹½çµç”¨æˆ·...")
        # å…ˆæŸ¥è¯¢ä¸€ä¸‹æœ‰å¤šå°‘æ— æ•ˆç”¨æˆ·
        c.execute("""
            SELECT COUNT(*) FROM members 
            WHERE telegram_id IS NULL 
               OR telegram_id = 'None' 
               OR CAST(telegram_id AS TEXT) = 'None'
               OR username = 'fallback_None'
               OR username LIKE 'fallback_%None%'
        """)
        count_before = c.fetchone()[0]
        print(f"   å‘ç° {count_before} ä¸ªå¯ç–‘çš„æ— æ•ˆç”¨æˆ·")
        
        c.execute("""
            DELETE FROM members 
            WHERE telegram_id IS NULL 
               OR telegram_id = 'None' 
               OR CAST(telegram_id AS TEXT) = 'None'
               OR username = 'fallback_None'
               OR username LIKE 'fallback_%None%'
        """)
        deleted_members = c.rowcount
        print(f"   å·²åˆ é™¤ {deleted_members} ä¸ªæ— æ•ˆç”¨æˆ·")
        
        # 2. åˆ é™¤å…³è”çš„é”™è¯¯æ”¶ç›Šè®°å½•
        print("\n2. åˆ é™¤å…³è”çš„é”™è¯¯æ”¶ç›Šè®°å½•...")
        c.execute("""
            DELETE FROM earnings_records 
            WHERE member_id IS NULL 
               OR member_id = 'None'
               OR CAST(member_id AS TEXT) = 'None'
        """)
        deleted_earnings = c.rowcount
        print(f"   å·²åˆ é™¤ {deleted_earnings} æ¡æ— æ•ˆæ”¶ç›Šè®°å½•")
        
        # 3. æ£€æŸ¥å¹¶æ¸…ç†æ— æ•ˆçš„å……å€¼è®°å½•
        print("\n3. æ£€æŸ¥æ— æ•ˆçš„å……å€¼è®°å½•...")
        c.execute("""
            DELETE FROM recharge_records 
            WHERE member_id IS NULL 
               OR member_id = 'None'
               OR CAST(member_id AS TEXT) = 'None'
        """)
        deleted_recharges = c.rowcount
        print(f"   å·²åˆ é™¤ {deleted_recharges} æ¡æ— æ•ˆå……å€¼è®°å½•")
        
        # 4. æ£€æŸ¥å¹¶æ¸…ç†æ— æ•ˆçš„æç°è®°å½•
        print("\n4. æ£€æŸ¥æ— æ•ˆçš„æç°è®°å½•...")
        # æ£€æŸ¥è¡¨æ˜¯å¦å­˜åœ¨
        c.execute("SELECT name FROM sqlite_master WHERE type='table' AND name='withdrawals'")
        table_exists = c.fetchone()
        if table_exists:
            c.execute("""
                DELETE FROM withdrawals 
                WHERE member_id IS NULL 
                   OR member_id = 'None'
                   OR CAST(member_id AS TEXT) = 'None'
            """)
            deleted_withdrawals = c.rowcount
            print(f"   å·²åˆ é™¤ {deleted_withdrawals} æ¡æ— æ•ˆæç°è®°å½•")
        else:
            print("   è¡¨ 'withdrawals' ä¸å­˜åœ¨ï¼Œè·³è¿‡")
            deleted_withdrawals = 0
        
        # æäº¤æ›´æ”¹
        conn.commit()
        
        print("\n" + "=" * 60)
        print("æ•°æ®åº“æ¸…ç†å®Œæˆï¼")
        print("=" * 60)
        print(f"æ€»è®¡åˆ é™¤:")
        print(f"  - æ— æ•ˆç”¨æˆ·: {deleted_members} ä¸ª")
        print(f"  - æ— æ•ˆæ”¶ç›Šè®°å½•: {deleted_earnings} æ¡")
        print(f"  - æ— æ•ˆå……å€¼è®°å½•: {deleted_recharges} æ¡")
        print(f"  - æ— æ•ˆæç°è®°å½•: {deleted_withdrawals} æ¡")
        print("=" * 60)
        
    except Exception as e:
        print(f"\nâŒ æ¸…ç†è¿‡ç¨‹ä¸­å‘ç”Ÿé”™è¯¯: {e}")
        import traceback
        traceback.print_exc()
        conn.rollback()
    finally:
        conn.close()

if __name__ == '__main__':
    print("âš ï¸  è­¦å‘Šï¼šæ­¤è„šæœ¬å°†åˆ é™¤æ•°æ®åº“ä¸­çš„æ— æ•ˆæ•°æ®ï¼")
    print("âš ï¸  è¯·ç¡®ä¿å·²å¤‡ä»½æ•°æ®åº“ï¼")
    response = input("\næ˜¯å¦ç»§ç»­ï¼Ÿ(yes/no): ")
    
    if response.lower() == 'yes':
        cleanup_database()
    else:
        print("å·²å–æ¶ˆæ“ä½œã€‚")

-e 

--- File: ./main.py ---
"""
å¯åŠ¨å…¥å£ - ç»Ÿä¸€å¯åŠ¨Botå’ŒWebåå°
"""
import threading
from app.database import init_db, sync_member_groups_from_members
from app.bot_logic import run_bot

def main():
    print("=" * 60)
    print("ğŸ¤– è£‚å˜æ¨å¹¿æœºå™¨äººç³»ç»Ÿå¯åŠ¨ä¸­...")
    print("=" * 60)
    print()
    
    # 1. åˆå§‹åŒ–æ•°æ®åº“
    print("ğŸ“Š åˆå§‹åŒ–æ•°æ®åº“...")
    init_db()
    print("âœ… æ•°æ®åº“åˆå§‹åŒ–å®Œæˆ")
    
    # åŒæ­¥å·²æœ‰ä¼šå‘˜ç¾¤é“¾æ¥åˆ° member_groups
    print("ğŸ”„ åŒæ­¥ä¼šå‘˜ç¾¤ç»„æ•°æ®...")
    try:
        sync_member_groups_from_members()
        print("âœ… ä¼šå‘˜ç¾¤ç»„æ•°æ®åŒæ­¥å®Œæˆ")
    except Exception as e:
        print(f"âš ï¸ ä¼šå‘˜ç¾¤ç»„æ•°æ®åŒæ­¥å¤±è´¥: {e}")
    print()
    
    # 2. å¯åŠ¨ Web åå° (åœ¨ç‹¬ç«‹çº¿ç¨‹ä¸­)
    print("ğŸŒ å¯åŠ¨Webç®¡ç†åå°...")
    try:
        from web_app import run_web
        web_thread = threading.Thread(target=run_web, daemon=True)
        web_thread.start()
        print("âœ… Webç®¡ç†åå°å·²å¯åŠ¨ (ç«¯å£: 5051)")
    except Exception as e:
        print(f"âš ï¸ Webåå°å¯åŠ¨å¤±è´¥: {e}")
        print("ç»§ç»­å¯åŠ¨Bot...")
    print()
    
    # 3. å¯åŠ¨ Bot (ä¸»çº¿ç¨‹)
    print("ğŸš€ Telegramæœºå™¨äººå¯åŠ¨ä¸­...")
    print()
    print("=" * 60)
    print("ğŸ“± è®¿é—®åœ°å€ï¼š")
    print("   Webåå°: http://localhost:5051")
    print("=" * 60)
    print()
    print("ğŸ’¡ æç¤ºï¼š")
    print("   - æ‰€æœ‰æœåŠ¡æ­£åœ¨è¿è¡Œä¸­...")
    print("   - æŒ‰ Ctrl+C åœæ­¢æ‰€æœ‰æœåŠ¡")
    print("=" * 60)
    print()
    
    try:
        run_bot()
    except KeyboardInterrupt:
        print("\nåœæ­¢æœåŠ¡...")
    except Exception as e:
        print(f"âŒ å¯åŠ¨å¤±è´¥: {e}")
        import traceback
        traceback.print_exc()

if __name__ == '__main__':
    main()

-e 

