--- File: ./app/bot_logic.py ---
"""
æœºå™¨äººé€»è¾‘å±‚ - ç»Ÿä¸€ç®¡ç†æ‰€æœ‰Telegramæœºå™¨äººäº¤äº’
ã€æ ¸å¿ƒä¿®å¤ã€‘æ”¯æŒå¤šæœºå™¨äººåŒæ—¶è¿è¡Œï¼Œåªè¯»å–æ•°æ®åº“é…ç½®çš„Bot
"""
import asyncio
import sqlite3
import time
import os
import json
import logging
from datetime import datetime, timedelta, timezone
from telethon import TelegramClient, events, Button
from telethon.sessions import MemorySession
from telethon.tl.types import ChannelParticipantsAdmins
from telethon.tl.functions.channels import GetParticipantRequest
import socks

# å¯¼å…¥é…ç½®å’Œä¾èµ–æ¨¡å—
import os
import sys

# æ·»åŠ é¡¹ç›®æ ¹ç›®å½•åˆ°Pythonè·¯å¾„
project_root = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
if project_root not in sys.path:
    sys.path.insert(0, project_root)

from app.config import (
    API_ID, API_HASH, ADMIN_IDS, USE_PROXY,
    PROXY_TYPE, PROXY_HOST, PROXY_PORT
)
from app.database import DB, get_cn_time, get_system_config, get_db_conn
from app.core_functions import (
    get_upline_chain, check_user_conditions, update_level_path,
    distribute_vip_rewards, check_user_in_group, check_bot_is_admin,
    verify_group_link
)
from app.bot_commands_addon import (
    handle_bind_group, handle_join_upline, handle_group_link_message,
    handle_check_status, handle_my_team
)

# é…ç½®æ—¥å¿—
logging.basicConfig(format='%(asctime)s - %(name)s - %(levelname)s - %(message)s', level=logging.INFO)
logger = logging.getLogger(__name__)

# å…¨å±€å˜é‡
active_clients = [] # å­˜å‚¨æ‰€æœ‰è¿è¡Œä¸­çš„å®¢æˆ·ç«¯
bot = None # ä¸»Botå¯¹è±¡ï¼ˆç”¨äºä¸»åŠ¨å‘é€æ¶ˆæ¯ï¼Œé»˜è®¤å–ç¬¬ä¸€ä¸ªï¼‰


def compute_vip_price_from_config(config):
    """Compute effective VIP price: if per-level amounts configured, sum them; else use vip_price"""
    try:
        # support config 'level_amounts' as list or JSON string
        level_count = int(config.get('level_count', 10))
        level_amounts = config.get('level_amounts')
        if level_amounts:
            import json
            if isinstance(level_amounts, str):
                try:
                    parsed = json.loads(level_amounts)
                except Exception:
                    parsed = None
            else:
                parsed = level_amounts

            if isinstance(parsed, list):
                # sum first level_count entries (pad with zeros)
                vals = [float(x) for x in parsed[:level_count]]
                if len(vals) < level_count:
                    vals += [0.0] * (level_count - len(vals))
                return sum(vals)
            elif isinstance(parsed, dict):
                total = 0.0
                for i in range(1, level_count + 1):
                    v = parsed.get(str(i)) or parsed.get(i) or 0
                    total += float(v)
                return total
    except Exception:
        pass
    # fallback to simple vip_price
    try:
        return float(config.get('vip_price', 10))
    except Exception:
        return 10.0

# æŒ‰é’®æ–‡å­—å¸¸é‡
BTN_PROFILE = 'ğŸ‘¤ ä¸ªäººä¸­å¿ƒ'
BTN_FISSION = 'ğŸ”— ç¾¤è£‚å˜åŠ å…¥'
BTN_VIEW_FISSION = 'ğŸ“Š æˆ‘çš„è£‚å˜'
BTN_RESOURCES = 'ğŸ“ è¡Œä¸šèµ„æº'
BTN_PROMOTE = 'ğŸ’° èµšé’±æ¨å¹¿'
BTN_SUPPORT = 'ğŸ‘©â€ğŸ’¼ åœ¨çº¿å®¢æœ'
BTN_BACK = 'ğŸ”™ è¿”å›ä¸»èœå•'
BTN_ADMIN = 'âš™ï¸ ç®¡ç†åå°'
BTN_VIP = 'ğŸ’ å¼€é€šä¼šå‘˜'
BTN_MY_PROMOTE = 'ğŸ’« æˆ‘çš„æ¨å¹¿'
BTN_EARNINGS = 'ğŸ“Š æ”¶ç›Šè®°å½•'

# å­èœå•æŒ‰é’®å¸¸é‡
BTN_SUB_VIEW_GROUPS = 'ğŸ“‹ æŸ¥çœ‹éœ€è¦åŠ å…¥çš„ç¾¤'
BTN_SUB_CHECK_STATUS = 'âœ… æ£€æŸ¥åŠ å…¥çŠ¶æ€'


async def send_vip_required_prompt(event_or_id, reply_method='respond'):
    """ç»™æœªå¼€é€šVIPçš„ç”¨æˆ·å‘é€ç»Ÿä¸€æç¤ºæ–‡æ¡ˆ"""
    try:
        if isinstance(event_or_id, int):
            telegram_id = event_or_id
            member = DB.get_member(telegram_id)
        else:
            original = event_or_id
            try:
                original_sender_id = original.sender_id
                original.sender_id = get_main_account_id(original_sender_id, getattr(original.sender, 'username', None))
            except Exception:
                pass
            member = DB.get_member(original.sender_id)
            telegram_id = original.sender_id

        config = get_system_config()
        vip_price = config.get('vip_price', 10)
        balance = member['balance'] if member else 0

        text = "æŠ±æ­‰ æ‚¨è¿˜ä¸æ˜¯VIP\n\n"
        text += "ä¸èƒ½ä½¿ç”¨æ­¤åŠŸèƒ½ è¯·å…ˆå¼€é€šVIP\n"
        text += "ç‚¹å‡»ä¸‹æ–¹ã€Œå¼€é€šVIPã€æŒ‰é’® å¼€é€šåœ¨æ¥å“¦\n\n"
        text += f"ğŸ’° VIPä»·æ ¼: {vip_price} U\n"
        text += f"ğŸ’µ å½“å‰ä½™é¢: {balance} U\n"

        buttons = []
        # å¦‚æœä½™é¢è¶³å¤Ÿï¼Œæä¾›ä½™é¢å¼€é€šæŒ‰é’®ï¼›å¦åˆ™æä¾›å……å€¼å…¥å£
        if balance >= vip_price:
            buttons = [[Button.inline('ğŸ’ ä½™é¢å¼€é€šVIP', b'confirm_vip')]]
        else:
            buttons = [[Button.inline('ğŸ’³ å……å€¼å¼€é€šVIP', b'recharge_for_vip')]]

        if isinstance(event_or_id, int):
            try:
                await bot.send_message(telegram_id, text, buttons=buttons)
            except Exception:
                pass
        else:
            # event-like
            try:
                if reply_method == 'respond':
                    await event_or_id.respond(text, buttons=buttons)
                else:
                    await event_or_id.answer(text, alert=True)
            except Exception:
                try:
                    await event_or_id.answer(text, alert=True)
                except Exception:
                    pass
    except Exception as e:
        print(f"[VIPæç¤º] å‘é€å¤±è´¥: {e}")

def get_active_bot_tokens():
    """è·å–æ‰€æœ‰æ´»è·ƒçš„æœºå™¨äººtoken"""
    try:
        conn = get_db_conn()
        c = conn.cursor()
        c.execute('SELECT bot_token FROM bot_configs WHERE is_active = 1 ORDER BY id ASC')
        rows = c.fetchall()
        conn.close()
        tokens = [row[0] for row in rows if row[0]]
        print(f"[æœºå™¨äººåˆå§‹åŒ–] æ‰¾åˆ° {len(tokens)} ä¸ªæ´»è·ƒæœºå™¨äººtoken")
        return tokens
    except Exception as e:
        print(f"[æœºå™¨äººåˆå§‹åŒ–] è·å–æ´»è·ƒtokenå¤±è´¥: {e}")
        return []

# ==================== æœºå™¨äººåˆå§‹åŒ–é€»è¾‘ ====================

def init_bots():
    """åˆå§‹åŒ–å¹¶å¯åŠ¨æ‰€æœ‰é…ç½®çš„æœºå™¨äºº"""
    global bot, active_clients

    tokens = get_active_bot_tokens()

    if not tokens:
        logger.error("âŒ é”™è¯¯ï¼šæ•°æ®åº“ä¸­æ²¡æœ‰æ´»è·ƒçš„æœºå™¨äººTokenï¼è¯·å…ˆåœ¨åå°æ·»åŠ æœºå™¨äººã€‚")
        return []

    # ä»£ç†é…ç½®
    proxy = None
    if USE_PROXY:
        if PROXY_TYPE.lower() == 'socks5':
            proxy = (socks.SOCKS5, PROXY_HOST, PROXY_PORT)
        elif PROXY_TYPE.lower() == 'socks4':
            proxy = (socks.SOCKS4, PROXY_HOST, PROXY_PORT)
        elif PROXY_TYPE.lower() == 'http':
            proxy = (socks.HTTP, PROXY_HOST, PROXY_PORT)
        else:
            proxy = (socks.SOCKS5, PROXY_HOST, PROXY_PORT)

    active_clients = []

    for idx, token in enumerate(tokens):
        try:
            session_name = f'bot_session_{idx}'
            client = TelegramClient(session_name, API_ID, API_HASH, proxy=proxy)
            client.start(bot_token=token)

            # æ³¨å†Œæ‰€æœ‰äº‹ä»¶å¤„ç†å™¨
            register_handlers(client)

            active_clients.append(client)
            logger.info(f"âœ… æœºå™¨äºº #{idx+1} å¯åŠ¨æˆåŠŸ (Token: {token[:10]}...)")

        except Exception as e:
            logger.error(f"âŒ æœºå™¨äºº #{idx+1} å¯åŠ¨å¤±è´¥: {e}")

    if active_clients:
        bot = active_clients[0]
        logger.info(f"âœ… æ€»è®¡å¯åŠ¨ {len(active_clients)} ä¸ªæœºå™¨äººï¼Œä¸»Botå·²å°±ç»ª")
    else:
        logger.error("âŒ æ²¡æœ‰æœºå™¨äººå¯åŠ¨æˆåŠŸ")

    return active_clients

# å…¨å±€é˜Ÿåˆ—
pending_broadcasts = []
notify_queue = []
process_recharge_queue = []
# å…¶ä»–å…¨å±€å˜é‡...


# å¯¼å…¥æ”¯ä»˜æ¨¡å—
from app.payment import create_recharge_order


# ==================== è´¦å·å…³è”é€»è¾‘ ====================

def get_main_account_id(telegram_id, username=None):
    """è·å–ä¸»è´¦å·IDï¼ˆç²¾å‡†IDåŒ¹é…ç‰ˆï¼‰"""
    try:
        target_id_str = str(telegram_id).strip()
        clean_username = (username or '').strip().lstrip('@')

        conn = get_db_conn()
        c = conn.cursor()

        query = "SELECT telegram_id FROM members WHERE backup_account = ?"
        c.execute(query, (target_id_str,))
        row = c.fetchone()

        if not row and clean_username:
            c.execute(
                'SELECT telegram_id FROM members WHERE backup_account = ? OR backup_account = ?',
                (clean_username, f"@{clean_username}")
            )
            row = c.fetchone()

        if not row:
            c.execute(
                'SELECT main_account_id FROM fallback_accounts '
                'WHERE telegram_id = ? AND main_account_id IS NOT NULL LIMIT 1',
                (telegram_id,)
            )
            fallback_result = c.fetchone()
            if fallback_result and fallback_result[0]:
                conn.close()
                return fallback_result[0]

        conn.close()

        if row:
            print(f"âœ… [è´¦å·åŠ«æŒæˆåŠŸ] å¤‡ç”¨å· {target_id_str} æ­£åœ¨ç™»å½• -> åˆ‡æ¢ä¸ºä¸»è´¦å· {row[0]}")
            return row[0]

        return telegram_id
    except Exception as e:
        print(f"[å…³è”æŸ¥è¯¢å‡ºé”™] {e}")
        return telegram_id

def get_main_keyboard(user_id=None):
    """ä¸»èœå•é”®ç›˜"""
    keyboard = [
        [Button.text(BTN_VIP, resize=True), Button.text(BTN_VIEW_FISSION, resize=True), Button.text(BTN_MY_PROMOTE, resize=True)],
        [Button.text(BTN_RESOURCES, resize=True), Button.text(BTN_FISSION, resize=True), Button.text(BTN_PROFILE, resize=True)],
        [Button.text(BTN_SUPPORT, resize=True)]
    ]
    if user_id and user_id in ADMIN_IDS:
        keyboard[-1].append(Button.text(BTN_ADMIN, resize=True))
    return keyboard

# ==================== VIPå¤„ç†é€»è¾‘ ====================

async def process_vip_upgrade(telegram_id, vip_price, config, deduct_balance=True):
    """ç»Ÿä¸€çš„VIPå¼€é€šå¤„ç†å‡½æ•°"""
    member = DB.get_member(telegram_id)
    if not member:
        return False, "ç”¨æˆ·ä¸å­˜åœ¨"

    if member.get('is_vip'):
        return False, "ç”¨æˆ·å·²æ˜¯VIP"

    if deduct_balance:
        if member['balance'] < vip_price:
            return False, "ä½™é¢ä¸è¶³"
        new_balance = member['balance'] - vip_price
        DB.update_member(telegram_id, balance=new_balance, is_vip=1, vip_time=get_cn_time())
    else:
        new_balance = member['balance']
        DB.update_member(telegram_id, is_vip=1, vip_time=get_cn_time())

    update_level_path(telegram_id)
    stats = await distribute_vip_rewards(bot, telegram_id, vip_price, config)

    return True, {
        'new_balance': new_balance,
        'stats': stats
    }

async def process_recharge(telegram_id, amount, is_vip_order=False):
    """å¤„ç†å……å€¼åˆ°è´¦é€»è¾‘ï¼ˆåŒ…æ‹¬VIPè‡ªåŠ¨å¼€é€šï¼‰"""
    try:
        conn = get_db_conn()
        c = conn.cursor()
        c.execute('SELECT balance, is_vip FROM members WHERE telegram_id = ?', (telegram_id,))
        row = c.fetchone()
        conn.close()

        if not row:
            print(f"[Recharge] ç”¨æˆ· {telegram_id} ä¸å­˜åœ¨")
            return

        current_balance = row[0]
        is_vip = row[1]

        # å‘é€åˆ°è´¦é€šçŸ¥
        try:
            await bot.send_message(telegram_id, f"ğŸ’° å……å€¼åˆ°è´¦: {amount} U\nå½“å‰ä½™é¢: {current_balance} U")
        except: pass

        # å°è¯•è‡ªåŠ¨å¼€é€šVIP
        config = get_system_config()
        vip_price = compute_vip_price_from_config(config)

        if is_vip_order and not is_vip and current_balance >= vip_price:
            print(f"[Recharge] è‡ªåŠ¨å¼€é€šVIP: {telegram_id}")
            success, result = await process_vip_upgrade(telegram_id, vip_price, config, deduct_balance=True)
            if success:
                try:
                    await bot.send_message(telegram_id, f"ğŸ’ VIPè‡ªåŠ¨å¼€é€šæˆåŠŸï¼\næ‰£é™¤ä½™é¢: {vip_price} U")
                except: pass
    except Exception as e:
        print(f"[Recharge Process Error] {e}")

async def admin_manual_vip_handler(telegram_id, config):
    """ç®¡ç†å‘˜æ‰‹åŠ¨å¼€é€šVIPçš„åå°ä»»åŠ¡"""
    vip_price = compute_vip_price_from_config(config)
    await process_vip_upgrade(telegram_id, vip_price, config, deduct_balance=False)

# ==================== äº‹ä»¶å¤„ç†å™¨æ³¨å†Œ ====================

def register_handlers(client):
    """ä¸ºå•ä¸ªå®¢æˆ·ç«¯æ³¨å†Œæ‰€æœ‰äº‹ä»¶å¤„ç†å™¨"""

    @client.on(events.NewMessage(pattern='/start'))
    async def start_handler(event):
        """å¯åŠ¨å‘½ä»¤"""
        original_sender_id = event.sender_id
        telegram_id = get_main_account_id(original_sender_id, getattr(event.sender, 'username', None))

        referrer_id = None
        if event.message.text and len(event.message.text.split()) > 1:
            try:
                referrer_id = int(event.message.text.split()[1])
            except: pass

        member = DB.get_member(telegram_id)

        if not member:
            username = event.sender.username or f'user_{telegram_id}'
            DB.create_member(telegram_id, username, referrer_id)
            member = DB.get_member(telegram_id)

            if referrer_id:
                try:
                    await client.send_message(referrer_id, f'ğŸ‰ æ–°æˆå‘˜åŠ å…¥! ID: {telegram_id}')
                except: pass

        sys_config = get_system_config()
        display_id = original_sender_id
        vip_status = "âœ… å·²å¼€é€š" if member.get('is_vip') else "âŒ æœªå¼€é€š"

        welcome_text = f'ğŸ‘‹ æ¬¢è¿ä½¿ç”¨è£‚å˜æ¨å¹¿æœºå™¨äºº!\nğŸ‘¤ å½“å‰æ˜¾ç¤ºèº«ä»½ID: `{display_id}`\nğŸ’ VIPçŠ¶æ€: {vip_status}\nğŸ’° ä½™é¢: {member["balance"]} U\n\nè¯·é€‰æ‹©åŠŸèƒ½:'
        if sys_config.get('pinned_ad'):
            welcome_text += f'\n\nğŸ“¢ {sys_config["pinned_ad"]}'

        await event.respond(welcome_text, buttons=get_main_keyboard(telegram_id))

    # VIP å¼€é€šå¤„ç†
    @client.on(events.NewMessage(pattern=BTN_VIP))
    async def vip_handler(event):
        telegram_id = get_main_account_id(event.sender_id)
        member = DB.get_member(telegram_id)

        if not member: return

        if member['is_vip']:
            await event.respond(f'ğŸ’ æ‚¨å·²ç»æ˜¯VIPä¼šå‘˜!\nå¼€é€šæ—¶é—´: {member["vip_time"][:10]}')
            return

        config = get_system_config()
        vip_price = compute_vip_price_from_config(config)

        text = f'ğŸ’ å¼€é€šVIPä¼šå‘˜\nVIPä»·æ ¼: {vip_price} U\nå½“å‰ä½™é¢: {member["balance"]} U'
        buttons = []
        if member['balance'] >= vip_price:
            text += '\nâœ… ä½™é¢å……è¶³ï¼Œå¯ä»¥ç›´æ¥å¼€é€š'
            buttons = [[Button.inline('ğŸ’ ä½™é¢å¼€é€šVIP', b'confirm_vip')]]
        else:
            text += f'\nâŒ ä½™é¢ä¸è¶³ï¼Œè¿˜éœ€ {vip_price - member["balance"]} U'
            buttons = [[Button.inline('ğŸ’³ å……å€¼å¼€é€šVIP', b'recharge_for_vip')]]

        await event.respond(text, buttons=buttons)

    @client.on(events.CallbackQuery(pattern=b'confirm_vip'))
    async def cb_confirm_vip(event):
        telegram_id = get_main_account_id(event.sender_id)
        config = get_system_config()
        vip_price = compute_vip_price_from_config(config)
        success, result = await process_vip_upgrade(telegram_id, vip_price, config)
        if success:
            await event.answer("ğŸ‰ VIPå¼€é€šæˆåŠŸï¼", alert=True)
            await event.respond("ğŸ‰ æ­å–œ! æ‚¨å·²æˆä¸ºVIPä¼šå‘˜ï¼Œç°åœ¨å¯ä»¥äº«å—æ‰€æœ‰æƒç›Šï¼", buttons=[[Button.inline('ğŸ”™ è¿”å›', b'back_to_profile')]])
        else:
            await event.answer(f"âŒ å¼€é€šå¤±è´¥: {result}", alert=True)

    @client.on(events.CallbackQuery(pattern=b'recharge_for_vip'))
    async def cb_recharge_for_vip(event):
        telegram_id = get_main_account_id(event.sender_id)
        config = get_system_config()
        vip_price = compute_vip_price_from_config(config)

        # åˆ›å»ºå……å€¼è®¢å•ï¼Œé‡‘é¢ä¸ºVIPä»·æ ¼
        try:
            await create_recharge_order(client, event, vip_price, is_vip_order=True)
        except Exception as e:
            await event.answer("åˆ›å»ºå……å€¼è®¢å•å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•", alert=True)

    # ä¸ªäººä¸­å¿ƒ
    @client.on(events.NewMessage(pattern=BTN_PROFILE))
    async def profile_handler(event):
        telegram_id = get_main_account_id(event.sender_id)
        member = DB.get_member(telegram_id)
        if not member:
            await event.respond('è¯·å…ˆå‘é€ /start æ³¨å†Œ')
            return

        config = get_system_config()
        vip_price = compute_vip_price_from_config(config)

        from app.core_functions import calculate_team_stats
        team_stats = calculate_team_stats(telegram_id, 10)

        text = f'ğŸ‘¤ ä¸ªäººä¸­å¿ƒ\n\n'
        text += f'ğŸ†” ç”¨æˆ·ID: `{telegram_id}`\n'
        text += f'ğŸ’° å½“å‰ä½™é¢: {member["balance"]} U\n'
        text += f'ğŸ’ VIPçŠ¶æ€: {"âœ… å·²å¼€é€š" if member["is_vip"] else "âŒ æœªå¼€é€š"}\n'
        if member["is_vip"]:
            text += f'ğŸ“… å¼€é€šæ—¶é—´: {member["vip_time"][:10] if member["vip_time"] else "æœªçŸ¥"}\n'
        text += f'ğŸ¯ VIPä»·æ ¼: {vip_price} U\n\n'
        text += f'ğŸ‘¥ å›¢é˜Ÿç»Ÿè®¡:\n'
        text += f'   ç›´æ¨äººæ•°: {team_stats["direct_count"]}\n'
        text += f'   å›¢é˜Ÿæ€»äººæ•°: {team_stats["team_count"]}\n'
        text += f'   VIPäººæ•°: {team_stats["vip_count"]}\n'
        text += f'ğŸ’¸ ç´¯è®¡æ”¶ç›Š: {member.get("total_earned", 0)} U\n'
        text += f'âš ï¸ ç´¯è®¡é”™è¿‡: {member["missed_balance"]} U\n'

        await event.respond(text, buttons=[[Button.text(BTN_BACK, resize=True)]])

    # åœ¨çº¿å®¢æœ
    @client.on(events.NewMessage(pattern=BTN_SUPPORT))
    async def support_handler(event):
        telegram_id = get_main_account_id(event.sender_id)
        config = get_system_config()
        support_text = config.get('support_text', 'ğŸ‘©â€ğŸ’¼ åœ¨çº¿å®¢æœ\n\næš‚æ— å®¢æœä¿¡æ¯ï¼Œè¯·è”ç³»ç®¡ç†å‘˜')
        customer_services = DB.get_customer_services()

        text = support_text
        if customer_services:
            text = 'ğŸ‘©â€ğŸ’¼ åœ¨çº¿å®¢æœ\n\n'
            for service in customer_services:
                text += f'ğŸ“ {service["name"]}\n'
                if service["link"]:
                    text += f'ğŸ”— {service["link"]}\n\n'

        await event.respond(text, buttons=[[Button.text(BTN_BACK, resize=True)]])

    # ç®¡ç†åå°
    @client.on(events.NewMessage(pattern=BTN_ADMIN))
    async def admin_handler(event):
        if event.sender_id not in ADMIN_IDS:
            await event.respond('âŒ æ‚¨ä¸æ˜¯ç®¡ç†å‘˜ï¼Œæ— æ³•è®¿é—®ç®¡ç†åå°')
            return
        text = 'âš™ï¸ ç®¡ç†åå°\n\n'
        text += 'ğŸŒ è®¿é—®åœ°å€:\nhttp://ä½ çš„æœåŠ¡å™¨IP:5051\n\n'
        text += 'ğŸ“‹ é»˜è®¤è´¦å·:\nç”¨æˆ·å: admin\nå¯†ç : admin\n\n'
        text += 'âš ï¸ è¯·åŠæ—¶ä¿®æ”¹é»˜è®¤å¯†ç '
        await event.respond(text, buttons=[[Button.text(BTN_BACK, resize=True)]])

    # æˆ‘çš„æ¨å¹¿
    @client.on(events.NewMessage(pattern=BTN_MY_PROMOTE))
    async def my_promote_handler(event):
        telegram_id = get_main_account_id(event.sender_id)
        member = DB.get_member(telegram_id)
        if not member:
            await event.respond('è¯·å…ˆå‘é€ /start æ³¨å†Œ')
            return
        if not member['is_vip']:
            await send_vip_required_prompt(event, 'respond')
            return

        bot_username = None
        try:
            me = await client.get_me()
            bot_username = me.username
        except: pass

        invite_link = f'https://t.me/{bot_username}?start={telegram_id}' if bot_username else 'æœªçŸ¥'

        from app.core_functions import calculate_team_stats
        team_stats = calculate_team_stats(telegram_id, 10)

        text = f'ğŸ’« æˆ‘çš„æ¨å¹¿\n\n'
        text += f'ğŸ”— æ¨å¹¿é“¾æ¥:\n{invite_link}\n\n'
        text += f'ğŸ“Š æ¨å¹¿ç»Ÿè®¡:\n'
        text += f'ğŸ‘¥ ç›´æ¨äººæ•°: {team_stats["direct_count"]}\n'
        text += f'ğŸ‘¨â€ğŸ‘©â€ğŸ‘§â€ğŸ‘¦ å›¢é˜Ÿæ€»äººæ•°: {team_stats["team_count"]}\n'
        text += f'ğŸ’ VIPäººæ•°: {team_stats["vip_count"]}\n'
        text += f'ğŸ’° ç´¯è®¡æ”¶ç›Š: {member.get("total_earned", 0)} U\n\n'
        text += 'ğŸ“¢ é‚€è¯·å¥½å‹åŠ å…¥å³å¯è·å¾—å¥–åŠ±!'

        await event.respond(text, buttons=[[Button.text(BTN_BACK, resize=True)]])

    # ç¾¤è£‚å˜åŠ å…¥ - æ˜¾ç¤ºå­èœå•
    @client.on(events.NewMessage(pattern=BTN_FISSION))
    async def fission_handler(event):
        telegram_id = get_main_account_id(event.sender_id)
        member = DB.get_member(telegram_id)
        if not member:
            await event.respond('è¯·å…ˆå‘é€ /start æ³¨å†Œ')
            return
        if not member['is_vip']:
            await send_vip_required_prompt(event, 'respond')
            return

        text = 'ğŸ”— ç¾¤è£‚å˜åŠ å…¥\n\n'
        text += 'ğŸ“‹ åŠ å…¥ä¸Šå±‚ç¾¤ç»„å¯ä»¥è·å¾—åˆ†çº¢å¥–åŠ±\n\n'
        text += 'è¯·é€‰æ‹©æ“ä½œ:'

        buttons = [
            [Button.text(BTN_SUB_VIEW_GROUPS, resize=True)],
            [Button.text(BTN_SUB_CHECK_STATUS, resize=True)],
            [Button.text(BTN_BACK, resize=True)]
        ]
        await event.respond(text, buttons=buttons)

    # ç›‘å¬å­èœå•ï¼šæŸ¥çœ‹éœ€è¦åŠ å…¥çš„ç¾¤
    @client.on(events.NewMessage(pattern=BTN_SUB_VIEW_GROUPS))
    async def sub_view_groups_handler(event):
        # è°ƒç”¨ addon ä¸­çš„é€»è¾‘
        await handle_join_upline(event, client, DB, get_system_config)

    # ç›‘å¬å­èœå•ï¼šæ£€æŸ¥åŠ å…¥çŠ¶æ€
    @client.on(events.NewMessage(pattern=BTN_SUB_CHECK_STATUS))
    async def sub_check_status_handler(event):
        # è°ƒç”¨ addon ä¸­çš„é€»è¾‘
        await handle_check_status(event, client, DB)

    # æˆ‘çš„è£‚å˜
    @client.on(events.NewMessage(pattern=BTN_VIEW_FISSION))
    async def view_fission_handler(event):
        telegram_id = get_main_account_id(event.sender_id)
        member = DB.get_member(telegram_id)
        if not member:
            await event.respond('è¯·å…ˆå‘é€ /start æ³¨å†Œ')
            return
        if not member['is_vip']:
            await send_vip_required_prompt(event, 'respond')
            return

        text = 'ğŸ“Š æˆ‘çš„è£‚å˜\n\n'
        text += f'ğŸ‘¤ ç¾¤ç»„çŠ¶æ€: {"âœ… å·²ç»‘å®š" if member.get("is_group_bound") else "âŒ æœªç»‘å®š"}\n'
        if member.get('group_link'):
            text += f'ğŸ”— ç¾¤é“¾æ¥: {member["group_link"]}\n'

        text += f'ğŸ¤– ç®¡ç†å‘˜æƒé™: {"âœ… å·²è®¾ç½®" if member.get("is_bot_admin") else "âŒ æœªè®¾ç½®"}\n'
        text += f'ğŸ‘¥ åŠ å…¥ä¸Šå±‚ç¾¤: {"âœ… å·²å®Œæˆ" if member.get("is_joined_upline") else "âŒ æœªå®Œæˆ"}\n\n'

        # æ˜¾ç¤ºç®€å•çš„å±‚çº§ç»Ÿè®¡
        from app.core_functions import get_downline_tree
        downline_tree = get_downline_tree(telegram_id, 5)
        if downline_tree:
            text += 'ğŸ“ˆ å›¢é˜Ÿå±‚çº§åˆ†å¸ƒ:\n'
            for level in range(1, 6):
                if level in downline_tree:
                    members_in_level = downline_tree[level]
                    vip_count = sum(1 for m in members_in_level if m['is_vip'])
                    text += f'   ç¬¬{level}å±‚: {len(members_in_level)}äºº (VIP: {vip_count}äºº)\n'

        # æç¤ºç”¨æˆ·å¦‚ä½•ç»‘å®šç¾¤ç»„
        text += '\nğŸ’¡ å¦‚éœ€ç»‘å®šæˆ–æ›´æ”¹ç¾¤ç»„ï¼Œè¯·ç›´æ¥å‘é€ç¾¤é“¾æ¥ï¼ˆå¦‚ https://t.me/+xxxï¼‰ç»™æˆ‘'

        await event.respond(text, buttons=[[Button.text(BTN_BACK, resize=True)]])

    # ç›‘å¬ç¾¤ç»„é“¾æ¥æ¶ˆæ¯ï¼ˆç”¨äºç»‘å®šç¾¤ç»„ï¼‰
    @client.on(events.NewMessage)
    async def group_link_listener(event):
        text = event.message.text
        # å¿½ç•¥å‘½ä»¤å’ŒæŒ‰é’®ç‚¹å‡»
        if text.startswith('/') or text in [BTN_PROFILE, BTN_FISSION, BTN_VIEW_FISSION, BTN_RESOURCES, BTN_PROMOTE, BTN_SUPPORT, BTN_BACK, BTN_ADMIN, BTN_VIP, BTN_MY_PROMOTE, BTN_SUB_VIEW_GROUPS, BTN_SUB_CHECK_STATUS]:
            return

        # ç®€å•æ­£åˆ™åˆ¤æ–­é“¾æ¥
        if 't.me/' in text or text.startswith('@'):
            await handle_group_link_message(event, client, DB)

    # è¿”å›ä¸»èœå•
    @client.on(events.NewMessage(pattern=BTN_BACK))
    async def back_handler(event):
        telegram_id = get_main_account_id(event.sender_id)
        member = DB.get_member(telegram_id)
        if member:
            config = get_system_config()
            vip_status = "âœ… å·²å¼€é€š" if member.get('is_vip') else "âŒ æœªå¼€é€š"
            welcome_text = f'ğŸ‘‹ æ¬¢è¿ä½¿ç”¨è£‚å˜æ¨å¹¿æœºå™¨äºº!\nğŸ‘¤ å½“å‰æ˜¾ç¤ºèº«ä»½ID: `{event.sender_id}`\nğŸ’ VIPçŠ¶æ€: {vip_status}\nğŸ’° ä½™é¢: {member["balance"]} U\n\nè¯·é€‰æ‹©åŠŸèƒ½:'
            if config.get('pinned_ad'):
                welcome_text += f'\n\nğŸ“¢ {config["pinned_ad"]}'
            await event.respond(welcome_text, buttons=get_main_keyboard(telegram_id))
        else:
            await event.respond('è¯·å…ˆå‘é€ /start æ³¨å†Œ', buttons=get_main_keyboard(telegram_id))


def run_bot():
    """Bot å¯åŠ¨å…¥å£"""
    print("ğŸš€ æ­£åœ¨å¯åŠ¨æ‰€æœ‰é…ç½®çš„ Telegram Bot...")

    loop = asyncio.new_event_loop()
    asyncio.set_event_loop(loop)

    clients = init_bots()
    if not clients:
        print("âŒ æ²¡æœ‰å¯ç”¨çš„æœºå™¨äººï¼Œç¨‹åºé€€å‡º")
        return

    # åå°ä»»åŠ¡ï¼šå¤„ç†å……å€¼é˜Ÿåˆ—
    async def _process_recharge_queue_worker():
        while True:
            try:
                if process_recharge_queue:
                    item = process_recharge_queue.pop(0)
                    await process_recharge(item['member_id'], item['amount'], item.get('is_vip_order', False))
                await asyncio.sleep(1)
            except Exception as e:
                logger.error(f"[å……å€¼é˜Ÿåˆ—] é”™è¯¯: {e}")
                await asyncio.sleep(1)

    loop.create_task(_process_recharge_queue_worker())

    print("âœ… æ‰€æœ‰æœºå™¨äººå·²å¯åŠ¨ï¼Œå¼€å§‹ç›‘å¬æ¶ˆæ¯...")

    try:
        loop.run_forever()
    except KeyboardInterrupt:
        pass
    finally:
        for c in clients:
            if c.is_connected():
                c.disconnect()


# å¯¼å‡ºbotå®ä¾‹ä¾›å…¶ä»–æ¨¡å—ä½¿ç”¨
__all__ = [
    'bot',
    'process_vip_upgrade',
    'process_recharge',
    'admin_manual_vip_handler',
    'get_main_account_id',
    'run_bot',
    'pending_broadcasts',
    'notify_queue',
    'process_recharge_queue'
]
-e 

--- File: ./app/run.py ---
"""
å¯åŠ¨å…¥å£ - ç»Ÿä¸€å¯åŠ¨Botå’ŒWebåå°
"""
import threading
from database import init_db, sync_member_groups_from_members
from bot_logic import run_bot

def main():
    print("=" * 60)
    print("ğŸ¤– è£‚å˜æ¨å¹¿æœºå™¨äººç³»ç»Ÿå¯åŠ¨ä¸­...")
    print("=" * 60)
    print()
    
    # 1. åˆå§‹åŒ–æ•°æ®åº“
    print("ğŸ“Š åˆå§‹åŒ–æ•°æ®åº“...")
    init_db()
    print("âœ… æ•°æ®åº“åˆå§‹åŒ–å®Œæˆ")
    
    # åŒæ­¥å·²æœ‰ä¼šå‘˜ç¾¤é“¾æ¥åˆ° member_groups
    print("ğŸ”„ åŒæ­¥ä¼šå‘˜ç¾¤ç»„æ•°æ®...")
    try:
        sync_member_groups_from_members()
        print("âœ… ä¼šå‘˜ç¾¤ç»„æ•°æ®åŒæ­¥å®Œæˆ")
    except Exception as e:
        print(f"âš ï¸ ä¼šå‘˜ç¾¤ç»„æ•°æ®åŒæ­¥å¤±è´¥: {e}")
    print()
    
    # 2. å¯åŠ¨ Web åå° (åœ¨ç‹¬ç«‹çº¿ç¨‹ä¸­)
    print("ğŸŒ å¯åŠ¨Webç®¡ç†åå°...")
    try:
        from web_app import run_web
        web_thread = threading.Thread(target=run_web, daemon=True)
        web_thread.start()
        print("âœ… Webç®¡ç†åå°å·²å¯åŠ¨ (ç«¯å£: 5051)")
    except Exception as e:
        print(f"âš ï¸ Webåå°å¯åŠ¨å¤±è´¥: {e}")
        print("ç»§ç»­å¯åŠ¨Bot...")
    print()
    
    # 3. å¯åŠ¨ Bot (ä¸»çº¿ç¨‹)
    print("ğŸš€ Telegramæœºå™¨äººå¯åŠ¨ä¸­...")
    print()
    print("=" * 60)
    print("ğŸ“± è®¿é—®åœ°å€ï¼š")
    print("   Webåå°: http://localhost:5051")
    print("=" * 60)
    print()
    print("ğŸ’¡ æç¤ºï¼š")
    print("   - æ‰€æœ‰æœåŠ¡æ­£åœ¨è¿è¡Œä¸­...")
    print("   - æŒ‰ Ctrl+C åœæ­¢æ‰€æœ‰æœåŠ¡")
    print("=" * 60)
    print()
    
    try:
        run_bot()
    except KeyboardInterrupt:
        print("\nåœæ­¢æœåŠ¡...")
    except Exception as e:
        print(f"âŒ å¯åŠ¨å¤±è´¥: {e}")
        import traceback
        traceback.print_exc()

if __name__ == '__main__':
    main()

-e 

--- File: ./app/web_app.py ---
"""
Webåå°å±‚ - ç»Ÿä¸€ç®¡ç†æ‰€æœ‰Flaskè·¯ç”±
æ‰€æœ‰è·¯ç”±éƒ½åœ¨æ­¤æ–‡ä»¶ä¸­ç›´æ¥å®šä¹‰ï¼Œä¸å†ä¾èµ–å¤–éƒ¨è·¯ç”±æ–‡ä»¶
"""
import os
import uuid
from datetime import datetime, timedelta
from flask import Flask, render_template, jsonify, request, redirect, url_for
from flask_login import LoginManager, login_required, logout_user, current_user
from werkzeug.security import generate_password_hash, check_password_hash

from database import DB, WebDB, AdminUser, get_system_config, get_db_conn, get_cn_time
from config import UPLOAD_DIR, BASE_DIR

# å»¶è¿Ÿå¯¼å…¥botï¼Œé¿å…å¾ªç¯ä¾èµ–
try:
    from bot_logic import bot, process_recharge, admin_manual_vip_handler, notify_queue, pending_broadcasts
except ImportError:
    # å¦‚æœå¯¼å…¥å¤±è´¥ï¼Œè®¾ç½®ä¸ºNoneï¼Œåç»­ä½¿ç”¨æ—¶å†å¯¼å…¥
    bot = None
    process_recharge = None
    admin_manual_vip_handler = None
    notify_queue = []
    # æ³¨æ„ï¼šè¿™é‡Œä¸åº”è¯¥é‡æ–°èµ‹å€¼pending_broadcastsï¼Œå¦åˆ™ä¼šè¦†ç›–å¯¼å…¥çš„å˜é‡
    if 'pending_broadcasts' not in globals():
        pending_broadcasts = []

# åˆå§‹åŒ–Flask
template_dir = os.path.join(os.path.dirname(os.path.dirname(__file__)), 'templates')
static_dir = os.path.join(os.path.dirname(os.path.dirname(__file__)), 'static')
app = Flask(__name__, template_folder=template_dir, static_folder=static_dir)
app.secret_key = 'fission-bot-secret-key-2025'
app.config['REMEMBER_COOKIE_DURATION'] = timedelta(days=90)
app.config['TEMPLATES_AUTO_RELOAD'] = True
app.jinja_env.auto_reload = True

login_manager = LoginManager()
login_manager.init_app(app)
login_manager.login_view = 'login'

@login_manager.user_loader
def load_user(user_id):
    return WebDB.get_user_by_id(int(user_id))

# For API routes, return JSON 401 instead of redirecting to login page (prevents HTML responses on fetch)
@app.before_request
def api_require_login_for_api():
    try:
        # ã€æ ¸å¿ƒä¿®å¤ã€‘å®šä¹‰ç™½åå•ï¼Œå…è®¸æ”¯ä»˜å›è°ƒä¸ç™»å½•ä¹Ÿèƒ½è®¿é—®
        whitelist = [
            '/api/payment/notify',     # æ”¯ä»˜å›è°ƒ
            '/api/payment/test',       # æµ‹è¯•æ¥å£
            '/login'                   # ç™»å½•æ¥å£
        ]

        # å¦‚æœè¯·æ±‚è·¯å¾„å®Œå…¨åŒ¹é…ç™½åå•ï¼Œç›´æ¥æ”¾è¡Œ
        if request.path in whitelist:
            return None

        # å¦‚æœæ˜¯APIè¯·æ±‚ä¸”ä¸åœ¨ç™½åå•å†…ï¼Œæ‰æ£€æŸ¥ç™»å½•çŠ¶æ€
        if request.path.startswith('/api/') and not current_user.is_authenticated:
            return jsonify({'success': False, 'message': 'æœªç™»å½•'}), 401
    except Exception:
        pass

# ==================== æ”¯ä»˜ç³»ç»Ÿé…ç½® ====================
PAYMENT_CONFIG = {
    'api_url': 'https://usdt.qxzy7888.org/pay/',
    'partner_id': '15',
    'key': '5c9dd0b054b184f964',
    'notify_url': 'http://154.201.68.178:5051/api/payment/notify',
    'return_url': 'http://154.201.68.178:5051/payment/success',
    'pay_type': 'trc20',
    'version': '1.0'
}

# æ·»åŠ ä¸€ä¸ªç®€å•çš„æµ‹è¯•ç«¯ç‚¹æ¥éªŒè¯å›è°ƒURLæ˜¯å¦å¯è®¿é—®
@app.route('/api/payment/test', methods=['GET'])
def test_payment_callback():
    """æµ‹è¯•æ”¯ä»˜å›è°ƒURLæ˜¯å¦å¯è®¿é—®"""
    return jsonify({
        'status': 'ok',
        'message': 'æ”¯ä»˜å›è°ƒURLå¯æ­£å¸¸è®¿é—®',
        'timestamp': get_cn_time(),
        'config': {
            'notify_url': PAYMENT_CONFIG.get('notify_url'),
            'has_key': bool(PAYMENT_CONFIG.get('key'))
        }
    })

import hashlib
import requests as req

def process_vip_upgrade_sync(telegram_id, vip_price, config, deduct_balance=True):
    """åŒæ­¥ç‰ˆæœ¬çš„VIPå¼€é€šå¤„ç†ï¼ˆç”¨äºæ”¯ä»˜å›è°ƒï¼‰"""
    try:
        from bot_logic import DB, distribute_vip_rewards, get_system_config

        member = DB.get_member(telegram_id)
        if not member:
            print(f"[VIPå¼€é€šåŒæ­¥] ç”¨æˆ·ä¸å­˜åœ¨: {telegram_id}")
            return False, "ç”¨æˆ·ä¸å­˜åœ¨"

        if member.get('is_vip'):
            print(f"[VIPå¼€é€šåŒæ­¥] ç”¨æˆ·å·²æ˜¯VIP: {telegram_id}")
            return False, "ç”¨æˆ·å·²æ˜¯VIP"

        print(f"[VIPå¼€é€šåŒæ­¥] ç”¨æˆ·ä¿¡æ¯: telegram_id={telegram_id}, å½“å‰ä½™é¢={member.get('balance', 0)}, VIPä»·æ ¼={vip_price}, éœ€è¦æ‰£è´¹={deduct_balance}")

        # æ£€æŸ¥ä½™é¢ï¼ˆå¦‚æœéœ€è¦æ‰£è´¹ï¼‰
        if deduct_balance:
            if member.get('balance', 0) < vip_price:
                print(f"[VIPå¼€é€šåŒæ­¥] ä½™é¢ä¸è¶³: éœ€è¦{vip_price}, å½“å‰{member.get('balance', 0)}")
                return False, "ä½™é¢ä¸è¶³"
            # æ‰£é™¤VIPè´¹ç”¨
            new_balance = member['balance'] - vip_price
            print(f"[VIPå¼€é€šåŒæ­¥] æ‰£è´¹å‰ä½™é¢: {member['balance']}, æ‰£è´¹åä½™é¢: {new_balance}")
            DB.update_member(telegram_id, balance=new_balance, is_vip=1, vip_time=get_cn_time())
            print(f"[VIPå¼€é€šåŒæ­¥] æ•°æ®åº“æ›´æ–°å®Œæˆ: balance={new_balance}, is_vip=1")
        else:
            # ä¸æ‰£è´¹ï¼Œç›´æ¥å¼€é€š
            DB.update_member(telegram_id, is_vip=1, vip_time=get_cn_time())
            print(f"[VIPå¼€é€šåŒæ­¥] ä¸æ‰£è´¹å¼€é€šVIPå®Œæˆ")

        # åˆ†å‘VIPå¥–åŠ±
        print(f"[VIPå¼€é€šåŒæ­¥] å¼€å§‹åˆ†å‘å¥–åŠ±")
        distribute_vip_rewards(telegram_id, vip_price)
        print(f"[VIPå¼€é€šåŒæ­¥] å¥–åŠ±åˆ†å‘å®Œæˆ")

        return True, {'new_balance': member.get('balance', 0) if not deduct_balance else new_balance}
    except Exception as e:
        print(f"[VIPå¼€é€šåŒæ­¥] é”™è¯¯: {e}")
        import traceback
        traceback.print_exc()
        return False, str(e)

def generate_payment_sign(params, key):
    """ç”Ÿæˆæ”¯ä»˜ç­¾å"""
    sorted_params = sorted([(k, v) for k, v in params.items() if v is not None and v != ''])
    sign_str = '&'.join([f'{k}={v}' for k, v in sorted_params])
    sign_str += f'&key={key}'
    return hashlib.md5(sign_str.encode()).hexdigest().upper()

# ==================== ç™»å½•è®¤è¯ ====================

@app.route('/login', methods=['GET', 'POST'])
def login():
    if request.method == 'POST':
        data = request.json
        username = data.get('username')
        password = data.get('password')
        remember = data.get('remember', False)
        
        user = WebDB.get_user_by_username(username)
        if user and check_password_hash(user.password_hash, password):
            from flask_login import login_user
            login_user(user, remember=remember)
            return jsonify({'success': True, 'message': 'ç™»å½•æˆåŠŸ'})
        
        return jsonify({'success': False, 'message': 'ç”¨æˆ·åæˆ–å¯†ç é”™è¯¯'}), 401
        
    if current_user.is_authenticated:
        return redirect(url_for('index'))
    return render_template('login.html')

@app.route('/logout')
@login_required
def logout():
    logout_user()
    return redirect(url_for('login'))

@app.route('/api/change_password', methods=['POST'])
@login_required
def api_change_password():
    data = request.json
    old_password = data.get('old_password')
    new_password = data.get('new_password')
    
    user = WebDB.get_user_by_id(current_user.id)
    
    if not check_password_hash(user.password_hash, old_password):
        return jsonify({'success': False, 'message': 'æ—§å¯†ç é”™è¯¯'}), 400
        
    WebDB.update_password(user.id, new_password)
    return jsonify({'success': True, 'message': 'å¯†ç ä¿®æ”¹æˆåŠŸ'})

# ==================== åŸºç¡€é¡µé¢è·¯ç”± ====================

@app.route('/')
@login_required
def index():
    """ä¸»é¡µ - æ•°æ®ç»Ÿè®¡"""
    return render_template('dashboard.html', active_page='dashboard')

@app.route('/members')
@login_required
def members_page():
    """ä¼šå‘˜ç®¡ç†é¡µé¢"""
    return render_template('members.html', active_page='members')

@app.route('/settings')
@login_required
def settings_page():
    """è®¾ç½®é¡µé¢"""
    return render_template('settings.html', active_page='settings')

@app.route('/statistics')
@login_required
def statistics_page():
    """ç»Ÿè®¡æŠ¥è¡¨é¡µé¢"""
    return render_template('statistics.html', active_page='statistics')

@app.route('/withdrawals')
@login_required
def withdrawals_page():
    """æç°ç®¡ç†é¡µé¢"""
    return render_template('withdrawals.html', active_page='withdrawals')

@app.route('/recharges')
@login_required
def recharges():
    """å……å€¼è®¢å•ç®¡ç†é¡µé¢"""
    return render_template('recharges.html')

@app.route('/earnings')
@login_required
def earnings_page():
    """æ”¶ç›Šè®°å½•ç®¡ç†é¡µé¢"""
    return render_template('earnings.html', active_page='earnings')

@app.route('/resources')
@login_required
def resources_page():
    """è¡Œä¸šèµ„æºç®¡ç†é¡µé¢"""
    return render_template('resources.html', active_page='resources')

@app.route('/customer-service')
@login_required
def customer_service_page():
    """å®¢æœç®¡ç†é¡µé¢"""
    return render_template('customer_service.html', active_page='customer_service')

@app.route('/broadcast')
@login_required
def broadcast_page():
    """ç¾¤å‘ç®¡ç†é¡µé¢"""
    return render_template('broadcast.html', active_page='broadcast')

@app.route('/bot-settings')
@login_required
def bot_settings_page():
    """æœºå™¨äººè®¾ç½®é¡µé¢"""
    return render_template('bot_settings.html', active_page='bot_settings')

@app.route('/level-settings')
@login_required
def level_settings_page():
    """å±‚çº§è®¾ç½®é¡µé¢"""
    return render_template('level_settings.html', active_page='level_settings')

@app.route('/member-groups')
@login_required
def member_groups_page():
    """ä¼šå‘˜ç¾¤ç®¡ç†é¡µé¢"""
    return render_template('member_groups.html', active_page='member_groups')

@app.route('/fallback-accounts')
@login_required
def fallback_accounts_page():
    """æ¡æ¼è´¦å·ç®¡ç†é¡µé¢"""
    return render_template('fallback_accounts.html', active_page='fallback_accounts')

@app.route('/team-graph')
@login_required
def team_graph_index():
    """å›¢é˜Ÿå›¾è°±å…¥å£é¡µ"""
    return render_template('team_graph_all.html', active_page='team_graph')

@app.route('/team-graph/<int:telegram_id>')
@login_required
def team_graph_page(telegram_id):
    """å›¢é˜Ÿå›¾è°±è¯¦æƒ…é¡µé¢"""
    return render_template('team_graph.html', telegram_id=telegram_id, active_page='team_graph')

# ==================== æ”¯ä»˜å›è°ƒ ====================

@app.route('/api/payment/notify', methods=['POST'])
def payment_notify():
    global notify_queue
    try:
        # 1. è·å–å’Œè§£ææ•°æ®
        raw_data = request.form.to_dict()
        if not raw_data:
            raw_data = request.get_json() or {}

        print(f'[æ”¯ä»˜å›è°ƒ] æ”¶åˆ°æ•°æ®: {raw_data}')

        # 2. ç­¾åéªŒè¯ (æ’é™¤ sign, remark, ç©ºå€¼)
        sign_received = ''
        filtered_params = {}
        for k, v in raw_data.items():
            val_str = str(v)
            if k.lower() == 'sign':
                sign_received = val_str
                continue
            if k.lower() == 'remark':
                continue
            if val_str == '':
                continue
            filtered_params[k] = val_str

        my_key = PAYMENT_CONFIG.get('key', '')
        sorted_keys = sorted(filtered_params.keys())
        sign_str = '&'.join([f'{k}={filtered_params[k]}' for k in sorted_keys])
        sign_str_with_key = f"{sign_str}&key={my_key}"
        calc_sign = hashlib.md5(sign_str_with_key.encode('utf-8')).hexdigest().upper()

        if sign_received.upper() != calc_sign:
            print('[æ”¯ä»˜å›è°ƒ] ç­¾åéªŒè¯å¤±è´¥')
            return 'fail'
        
        # 3. ä¸šåŠ¡å¤„ç†
        status = str(raw_data.get('status'))
        out_trade_no = raw_data.get('out_trade_no')
        amount = float(raw_data.get('amount', 0))

        # status=4 ä»£è¡¨æˆåŠŸ
        if status == '4':
            conn = get_db_conn()
            c = conn.cursor()

            # è§£æç”¨æˆ·ID
            telegram_id = 0
            if out_trade_no and out_trade_no.startswith('RCH_'):
                parts = out_trade_no.split('_')
                if len(parts) >= 2:
                    telegram_id = int(parts[1])

            # æŸ¥é‡
            c.execute('SELECT status, remark FROM recharge_records WHERE order_id = ?', (out_trade_no,))
            existing = c.fetchone()

            if existing and existing[0] != 'completed':
                # A. æ ‡è®°è®¢å•å®Œæˆ
                c.execute('UPDATE recharge_records SET status = ? WHERE order_id = ?', ('completed', out_trade_no))

                # B. å¢åŠ ç”¨æˆ·ä½™é¢ (åªåŠ ä½™é¢ï¼Œåƒä¸‡åˆ«åœ¨è¿™é‡Œæ‰£è´¹å¼€VIPï¼)
                c.execute('UPDATE members SET balance = balance + ? WHERE telegram_id = ?', (amount, telegram_id))
                conn.commit()

                # C. åˆ¤æ–­æ˜¯å¦ä¸º VIP è®¢å•
                # é€»è¾‘ï¼šå¤‡æ³¨æ˜¯"å¼€é€š"ï¼Œæˆ–è€…å……å€¼é‡‘é¢ >= VIPä»·æ ¼
                is_vip_order = False
                if existing[1] == 'å¼€é€š':
                    is_vip_order = True
                else:
                    # è¡¥å……æ£€æµ‹ï¼šå¦‚æœæ²¡å¤‡æ³¨ï¼Œä½†é‡‘é¢è¶³å¤Ÿï¼Œä¹Ÿè§†ä¸ºVIPæ„å‘(å¯é€‰ï¼Œæ ¹æ®æ‚¨çš„éœ€æ±‚)
                    config = get_system_config()
                    vip_price = float(config.get('vip_price', 10))
                    if amount >= vip_price:
                        is_vip_order = True

                print(f"[æ”¯ä»˜å›è°ƒ] è®¢å• {out_trade_no} å¤„ç†å®Œæ¯•ï¼Œä½™é¢å·²åŠ ã€‚VIPè®¢å•æ ‡è®°: {is_vip_order}")

                # D. ã€å…³é”®ã€‘æ¨å…¥é˜Ÿåˆ—ï¼Œè®© Bot çº¿ç¨‹å»å¤„ç†æ‰£è´¹ã€å¼€é€šå’Œåˆ†çº¢
                # è¿™æ ·å¯ä»¥é¿å… Web çº¿ç¨‹å’Œ Bot çº¿ç¨‹çš„çŠ¶æ€å†²çª
                try:
                    import bot_logic
                    if hasattr(bot_logic, 'process_recharge_queue'):
                        bot_logic.process_recharge_queue.append({
                            'member_id': telegram_id,
                            'amount': amount,
                            'is_vip_order': is_vip_order
                        })
                        print(f"[æ”¯ä»˜å›è°ƒ] å·²å°†ä»»åŠ¡æ¨å…¥ Bot é˜Ÿåˆ—ï¼Œç­‰å¾… Bot å¤„ç† VIP é€»è¾‘")
                except Exception as q_err:
                    print(f"[æ”¯ä»˜å›è°ƒ] æ¨é€é˜Ÿåˆ—å¤±è´¥: {q_err}")

                conn.close()
                return 'success'
        
        return 'success'
    except Exception as e:
        print(f'[æ”¯ä»˜å›è°ƒ] å¼‚å¸¸: {e}')
        import traceback
        traceback.print_exc()
        return 'fail'

@app.route('/payment/success')
def payment_success():
    return '<html><head><meta charset=utf-8><title>æ”¯ä»˜æˆåŠŸ</title></head><body style=text-align:center;padding:50px><h1>æ”¯ä»˜æˆåŠŸ</h1><p>å……å€¼è®¢å•å·²æäº¤</p></body></html>'

# ==================== å†…éƒ¨API ====================

@app.route('/internal/notify', methods=['POST'])
def internal_notify():
    """å†…éƒ¨APIï¼šå‘é€é€šçŸ¥ç»™ç”¨æˆ·"""
    try:
        data = request.json
        member_id = data['member_id']
        message = data['message']
        notify_queue.append({'member_id': member_id, 'message': message})
        print(f"âœ… é€šçŸ¥å·²åŠ å…¥é˜Ÿåˆ—: ç”¨æˆ·{member_id}")
        return jsonify({'success': True})
    except Exception as e:
        print(f"å†…éƒ¨APIå¤±è´¥: {e}")
        return jsonify({'success': False, 'error': str(e)})

# ==================== å…³é”®APIè·¯ç”± =====================

@app.route('/api/members')
@login_required
def api_members():
    """è·å–ä¼šå‘˜åˆ—è¡¨API"""
    page = request.args.get('page', 1, type=int)
    per_page = request.args.get('per_page', 20, type=int)
    search = request.args.get('search', '', type=str)
    filter_type = request.args.get('filter', 'all', type=str)
    
    # ä½¿ç”¨WebDBçš„å®Œæ•´æ–¹æ³•ï¼ˆéœ€è¦ä»main.pyè¿ç§»å®Œæ•´å®ç°ï¼‰
    # è¿™é‡Œç®€åŒ–å¤„ç†ï¼Œå®é™…åº”è¯¥è°ƒç”¨å®Œæ•´çš„ get_all_members
    data = WebDB.get_all_members(page, per_page, search, filter_type)
    return jsonify(data)

@app.route('/api/member/<int:telegram_id>')
@login_required
def api_member_detail(telegram_id):
    """è·å–ä¼šå‘˜è¯¦æƒ…API"""
    member = WebDB.get_member_detail(telegram_id)
    if member:
        # è¿”å›ä¸å‰ç«¯æœŸæœ›ä¸€è‡´çš„çº¯ member å¯¹è±¡ï¼ˆå…¼å®¹æ—§å‰ç«¯ï¼‰
        return jsonify(member)
    return jsonify({'error': 'ä¼šå‘˜ä¸å­˜åœ¨'}), 404

@app.route('/api/member/<int:telegram_id>', methods=['PUT'])
@login_required
def api_update_member(telegram_id):
    """æ›´æ–°ä¼šå‘˜ä¿¡æ¯API"""
    data = request.json
    WebDB.update_member(telegram_id, data)
    return jsonify({'success': True, 'message': 'æ›´æ–°æˆåŠŸ'})

@app.route('/api/member/<int:telegram_id>', methods=['DELETE'])
@login_required
def api_delete_member(telegram_id):
    """åˆ é™¤ä¼šå‘˜API"""
    WebDB.delete_member(telegram_id)
    return jsonify({'success': True, 'message': 'åˆ é™¤æˆåŠŸ'})

@app.route('/api/member/add', methods=['POST'])
@login_required
def api_add_member():
    """æ·»åŠ ä¼šå‘˜API"""
    try:
        data = request.json
        telegram_id = data.get('telegram_id')
        username = data.get('username', '')
        referrer_id = data.get('referrer_id')
        
        if not telegram_id:
            return jsonify({'success': False, 'message': 'telegram_idä¸èƒ½ä¸ºç©º'}), 400
        
        # æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨
        existing = DB.get_member(telegram_id)
        if existing:
            return jsonify({'success': False, 'message': 'ä¼šå‘˜å·²å­˜åœ¨'}), 400
        
        # åˆ›å»ºä¼šå‘˜
        DB.create_member(telegram_id, username, referrer_id)
        return jsonify({'success': True, 'message': 'æ·»åŠ æˆåŠŸ'})
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500

@app.route('/api/member-groups/<int:group_id>/broadcasts', methods=['GET'])
@login_required
def api_get_group_broadcasts(group_id):
    """è·å–æŸä¸ªç¾¤å¯ç”¨çš„ç¾¤å‘åˆ—è¡¨ä»¥åŠè¯¥ç¾¤å·²åˆ†é…çš„æ¡ç›®çŠ¶æ€"""
    try:
        conn = get_db_conn()
        c = conn.cursor()
        # è·å–æ‰€æœ‰ç¾¤å‘æ¶ˆæ¯
        c.execute("""SELECT id, title, content, image_url, video_url, buttons, buttons_per_row, broadcast_interval, is_active, create_time
                     FROM broadcast_messages WHERE is_active = 1 ORDER BY id ASC""")
        msgs = c.fetchall()

        # è·å–è¯¥ç¾¤çš„åˆ†é…è®°å½•
        c.execute("SELECT message_id, is_active, last_sent_time FROM broadcast_assignments WHERE group_id = ?", (group_id,))
        assigns = {r[0]: {'is_active': r[1], 'last_sent_time': r[2]} for r in c.fetchall()}
        conn.close()

        messages = []
        for row in msgs:
            mid = row[0]
            messages.append({
                'id': mid,
                'title': row[1],
                'content': row[2],
                'image_url': row[3] or '',
                'video_url': row[4] or '',
                'buttons': row[5] or '[]',
                'buttons_per_row': row[6] or 2,
                'broadcast_interval': row[7] or 120,
                'is_active': row[8],
                'create_time': row[9] or '',
                'assigned': mid in assigns,
                'assignment': assigns.get(mid)
            })

        return jsonify({'success': True, 'messages': messages})
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500


@app.route('/api/member-groups/<int:group_id>/broadcasts', methods=['POST'])
@login_required
def api_assign_broadcast_to_group(group_id):
    """ä¸ºæŸä¸ªç¾¤åˆ†é…ä¸€æ¡ç¾¤å‘æ¶ˆæ¯ï¼ˆæˆ–æ›´æ–°æ¿€æ´»çŠ¶æ€ï¼‰"""
    try:
        data = request.get_json() or {}
        message_id = int(data.get('message_id') or 0)
        is_active = 1 if data.get('is_active') else 0
        if not message_id:
            return jsonify({'success': False, 'message': 'message_id å¿…å¡«'}), 400

        conn = get_db_conn()
        c = conn.cursor()
        # æ£€æŸ¥ç¾¤æ˜¯å¦å­˜åœ¨
        c.execute('SELECT id, group_link FROM member_groups WHERE id = ?', (group_id,))
        g = c.fetchone()
        if not g:
            conn.close()
            return jsonify({'success': False, 'message': 'ç¾¤ç»„ä¸å­˜åœ¨'}), 404

        # æ’å…¥æˆ–æ›´æ–° assignment
        c.execute('SELECT id FROM broadcast_assignments WHERE group_id = ? AND message_id = ?', (group_id, message_id))
        row = c.fetchone()
        now = get_cn_time()
        if row:
            c.execute('UPDATE broadcast_assignments SET is_active = ?, create_time = ? WHERE id = ?', (is_active, now, row[0]))
        else:
            c.execute('INSERT INTO broadcast_assignments (group_id, message_id, is_active, create_time) VALUES (?, ?, ?, ?)',
                      (group_id, message_id, is_active, now))
        conn.commit()
        conn.close()
        return jsonify({'success': True, 'message': 'åˆ†é…å·²ä¿å­˜'})
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500


@app.route('/api/member-groups/<int:group_id>/broadcasts/<int:message_id>', methods=['DELETE'])
@login_required
def api_unassign_broadcast_from_group(group_id, message_id):
    """å–æ¶ˆæŸæ¡æ¶ˆæ¯å¯¹æŸç¾¤çš„åˆ†é…"""
    try:
        conn = get_db_conn()
        c = conn.cursor()
        c.execute('DELETE FROM broadcast_assignments WHERE group_id = ? AND message_id = ?', (group_id, message_id))
        conn.commit()
        conn.close()
        return jsonify({'success': True, 'message': 'å·²å–æ¶ˆåˆ†é…'})
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500


@app.route('/api/member-groups/<int:group_id>/broadcast/send', methods=['POST'])
@login_required
def api_group_send_broadcasts(group_id):
    """ç«‹å³å‘æŸä¸ªç¾¤å‘é€é€‰ä¸­çš„ç¾¤å‘å†…å®¹ï¼›å¦‚æœæœªæŒ‡å®š message_idsï¼Œåˆ™å‘é€è¯¥ç¾¤å·²åˆ†é…ä¸”å¯ç”¨çš„æ‰€æœ‰æ¶ˆæ¯"""
    try:
        data = request.get_json() or {}
        message_ids = data.get('message_ids') or []

        conn = get_db_conn()
        c = conn.cursor()
        c.execute('SELECT group_link, group_name FROM member_groups WHERE id = ?', (group_id,))
        g = c.fetchone()
        if not g:
            conn.close()
            return jsonify({'success': False, 'message': 'ç¾¤ç»„ä¸å­˜åœ¨'}), 404
        group_link, group_name = g[0], g[1]

        if not message_ids:
            # å–è¯¥ç¾¤å·²åˆ†é…ä¸”å¯ç”¨çš„æ¶ˆæ¯
            c.execute('SELECT message_id FROM broadcast_assignments WHERE group_id = ? AND is_active = 1 ORDER BY id ASC', (group_id,))
            message_ids = [r[0] for r in c.fetchall()]

        if not message_ids:
            conn.close()
            return jsonify({'success': False, 'message': 'æ²¡æœ‰å¯å‘é€çš„ç¾¤å‘å†…å®¹'}), 400

        # è·å–å¾…å‘é€æ¶ˆæ¯å†…å®¹å¹¶å†™å…¥ broadcast_queue
        placeholders = ','.join(['?' for _ in message_ids])
        c.execute(f'SELECT id, title, content, image_url, video_url, buttons FROM broadcast_messages WHERE id IN ({placeholders}) ORDER BY id ASC', message_ids)
        rows = c.fetchall()
        now = get_cn_time()
        for row in rows:
            # build a JSON payload containing content and media
            msg_obj = {
                'content': row[2] or '',
                'image_url': row[3] or '',
                'video_url': row[4] or '',
                'buttons': row[5] or '',
            }
            import json
            msg_json = json.dumps(msg_obj, ensure_ascii=False)
            # å†™å…¥é˜Ÿåˆ—ï¼›Bot çº¿ç¨‹ä¼šè§£æ JSON å¹¶å‘é€åª’ä½“/æŒ‰é’®ç­‰
            c.execute('INSERT INTO broadcast_queue (group_link, group_name, message, status, create_time) VALUES (?, ?, ?, ?, ?)',
                      (group_link, group_name, msg_json, 'pending', now))

        conn.commit()
        conn.close()
        return jsonify({'success': True, 'message': f'å·²å°† {len(rows)} æ¡æ¶ˆæ¯åŠ å…¥ç¾¤ {group_name} çš„å‘é€é˜Ÿåˆ—'})
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500

@app.route('/api/member/<int:telegram_id>/graph')
@login_required
def api_member_graph(telegram_id):
    """è·å–ä¼šå‘˜å…³ç³»å›¾è°±"""
    conn = get_db_conn()
    c = conn.cursor()
    
    # è·å–å½“å‰ä¼šå‘˜
    c.execute("""SELECT telegram_id, username, balance, is_vip, referrer_id,
        is_group_bound, is_bot_admin, is_joined_upline, direct_count, team_count
        FROM members WHERE telegram_id = ?""", (telegram_id,))
    row = c.fetchone()
    if not row:
        conn.close()
        return jsonify({'error': 'ä¼šå‘˜ä¸å­˜åœ¨'}), 404
    
    current = {
        'telegram_id': row[0], 'username': row[1], 'balance': row[2],
        'is_vip': row[3], 'referrer_id': row[4], 'is_group_bound': row[5],
        'is_bot_admin': row[6], 'is_joined_upline': row[7],
        'direct_count': row[8] or 0, 'team_count': row[9] or 0
    }
    
    # è·å–ä¸Šçº§é“¾
    upline = []
    current_ref = row[4]
    while current_ref and len(upline) < 10:
        c.execute("""SELECT telegram_id, username, is_vip, referrer_id,
            is_group_bound, is_bot_admin, is_joined_upline, direct_count, team_count
            FROM members WHERE telegram_id = ?""", (current_ref,))
        ref_row = c.fetchone()
        if not ref_row:
            break
        is_valid = ref_row[4] and ref_row[5] and ref_row[6]
        upline.append({
            'telegram_id': ref_row[0], 'username': ref_row[1], 'is_vip': ref_row[2],
            'is_group_bound': ref_row[4], 'is_bot_admin': ref_row[5], 'is_joined_upline': ref_row[6],
            'direct_count': ref_row[7] or 0, 'team_count': ref_row[8] or 0, 'is_valid': is_valid
        })
        current_ref = ref_row[3]
    
    # é€’å½’è·å–å¤šå±‚çº§ä¸‹çº§
    def get_downline_recursive(parent_id, max_level=10):
        result = {}
        for level in range(1, max_level + 1):
            if level == 1:
                c.execute("""SELECT telegram_id, username, is_vip,
                    is_group_bound, is_bot_admin, is_joined_upline
                    FROM members WHERE referrer_id = ? LIMIT 100""", (parent_id,))
            else:
                if level - 1 not in result or not result[level - 1]:
                    break
                parent_ids = [m['telegram_id'] for m in result[level - 1]]
                if not parent_ids:
                    break
                placeholders = ','.join('?' * len(parent_ids))
                c.execute(f"""SELECT telegram_id, username, is_vip,
                    is_group_bound, is_bot_admin, is_joined_upline
                    FROM members WHERE referrer_id IN ({placeholders}) LIMIT 100""", parent_ids)
            
            level_members = []
            for d in c.fetchall():
                c.execute('SELECT COUNT(*) FROM members WHERE referrer_id = ?', (d[0],))
                d_direct = c.fetchone()[0]
                c.execute("SELECT COUNT(*) FROM members WHERE level_path LIKE ? AND telegram_id != ?", (f'%/{d[0]}/%', d[0]))
                d_team = c.fetchone()[0]
                level_members.append({
                    'telegram_id': d[0], 'username': d[1], 'is_vip': d[2],
                    'is_group_bound': d[3], 'is_bot_admin': d[4], 'is_joined_upline': d[5],
                    'direct_count': d_direct, 'team_count': d_team
                })
            if level_members:
                result[level] = level_members
            else:
                break
        return result
    
    downline_by_level = get_downline_recursive(telegram_id)
    
    conn.close()
    return jsonify({'current': current, 'upline': upline, 'downline_by_level': downline_by_level})

@app.route('/api/statistics')
@login_required
def api_statistics():
    """è·å–ç»Ÿè®¡æ•°æ®API"""
    stats = WebDB.get_statistics()
    return jsonify(stats)

@app.route('/api/statistics/chart')
@login_required
def api_chart_data():
    """è·å–å›¾è¡¨æ•°æ®API"""
    chart_data = WebDB.get_chart_data()
    return jsonify(chart_data)

@app.route('/api/dashboard/stats')
@login_required
def api_dashboard_stats():
    """è·å–ä»ªè¡¨ç›˜ç»Ÿè®¡æ•°æ®"""
    try:
        from datetime import datetime, timedelta
        conn = get_db_conn()
        c = conn.cursor()
        
        today = datetime.now().strftime('%Y-%m-%d')
        yesterday = (datetime.now() - timedelta(days=1)).strftime('%Y-%m-%d')
        month_start = datetime.now().strftime('%Y-%m-01')
        
        c.execute('SELECT COUNT(*) FROM members')
        total_members = c.fetchone()[0]
        
        c.execute('SELECT COUNT(*) FROM members WHERE is_vip = 1')
        vip_members = c.fetchone()[0]
        
        c.execute('SELECT COUNT(*) FROM members WHERE DATE(register_time) = ?', (today,))
        today_register = c.fetchone()[0]
        
        c.execute('SELECT COUNT(*) FROM members WHERE DATE(register_time) = ?', (yesterday,))
        yesterday_register = c.fetchone()[0]
        
        c.execute('SELECT COUNT(*) FROM members WHERE DATE(register_time) >= ?', (month_start,))
        month_register = c.fetchone()[0]
        
        c.execute('SELECT COUNT(*) FROM members WHERE is_vip = 1 AND DATE(vip_time) = ?', (today,))
        today_vip = c.fetchone()[0]
        
        c.execute('SELECT COUNT(*) FROM members WHERE is_vip = 1 AND DATE(vip_time) = ?', (yesterday,))
        yesterday_vip = c.fetchone()[0]
        
        c.execute('SELECT COUNT(*) FROM members WHERE is_vip = 1 AND DATE(vip_time) >= ?', (month_start,))
        month_vip = c.fetchone()[0]
        
        c.execute("SELECT telegram_id, username, total_earned FROM fallback_accounts ORDER BY total_earned DESC LIMIT 10")
        fallback_rows = c.fetchall()
        
        fallback_accounts = []
        total_income = 0
        
        for row in fallback_rows:
            total_income += row[2] or 0
            fallback_accounts.append({
                "telegram_id": row[0],
                "username": row[1],
                "balance": row[2] or 0,
                "total_earned": row[2] or 0,
                "is_vip": 1
            })
        
        today_income = total_income
        yesterday_income = 0
        month_income = total_income
        
        trend_labels = []
        trend_register = []
        trend_vip = []
        for i in range(6, -1, -1):
            date = (datetime.now() - timedelta(days=i)).strftime('%Y-%m-%d')
            trend_labels.append((datetime.now() - timedelta(days=i)).strftime('%m-%d'))
            
            c.execute('SELECT COUNT(*) FROM members WHERE DATE(register_time) = ?', (date,))
            trend_register.append(c.fetchone()[0])
            
            c.execute('SELECT COUNT(*) FROM members WHERE is_vip = 1 AND DATE(vip_time) = ?', (date,))
            trend_vip.append(c.fetchone()[0])
        
        conn.close()
        
        return jsonify({
            'success': True,
            'data': {
                'total_members': total_members,
                'vip_members': vip_members,
                'today_register': today_register,
                'yesterday_register': yesterday_register,
                'month_register': month_register,
                'today_vip': today_vip,
                'yesterday_vip': yesterday_vip,
                'month_vip': month_vip,
                'today_income': round(today_income, 2),
                'yesterday_income': round(yesterday_income, 2),
                'month_income': round(month_income, 2),
                'total_income': round(total_income, 2),
                'fallback_accounts': fallback_accounts,
                'trend_data': {
                    'labels': trend_labels,
                    'register_counts': trend_register,
                    'vip_counts': trend_vip
                }
            }
        })
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500

@app.route('/api/member-groups')
@login_required
def api_get_member_groups():
    """è·å–ä¼šå‘˜ç¾¤åˆ—è¡¨"""
    try:
        search = request.args.get('search', '').strip()
        conn = get_db_conn()
        c = conn.cursor()
        
        if search:
            c.execute('''
                SELECT 
                    mg.id, mg.telegram_id, mg.group_id, mg.group_name,
                    mg.group_link, mg.member_count, mg.bot_id, mg.is_bot_admin,
                    mg.create_time, m.username
                FROM member_groups mg
                LEFT JOIN members m ON mg.telegram_id = m.telegram_id
                WHERE mg.group_name LIKE ? OR mg.group_link LIKE ? OR m.username LIKE ?
                ORDER BY mg.id DESC
            ''', (f'%{search}%', f'%{search}%', f'%{search}%'))
        else:
            c.execute('''
                SELECT 
                    mg.id, mg.telegram_id, mg.group_id, mg.group_name,
                    mg.group_link, mg.member_count, mg.bot_id, mg.is_bot_admin,
                    mg.create_time, m.username
                FROM member_groups mg
                LEFT JOIN members m ON mg.telegram_id = m.telegram_id
                ORDER BY mg.id DESC
            ''')
        
        rows = c.fetchall()
        groups = []
        for row in rows:
            groups.append({
                'id': row[0],
                'telegram_id': row[1],
                'group_id': row[2],
                'group_name': row[3] or '',
                'group_link': row[4] or '',
                'member_count': row[5] or 0,
                'bot_id': row[6],
                'is_bot_admin': row[7],
                'create_time': row[8][:19] if row[8] else '',
                'owner_username': row[9] or ''
            })
        
        conn.close()
        return jsonify({'success': True, 'groups': groups})
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/api/member-groups/<int:id>', methods=['PUT'])
@login_required
def api_update_member_group(id):
    """æ›´æ–°ä¼šå‘˜ç¾¤ç»„ä¿¡æ¯"""
    try:
        data = request.json or {}
        group_name = data.get('group_name')
        group_link = data.get('group_link')

        conn = get_db_conn()
        c = conn.cursor()

        updates = []
        params = []
        if group_name is not None:
            updates.append("group_name = ?")
            params.append(group_name)
        if group_link is not None:
            updates.append("group_link = ?")
            params.append(group_link)

        if not updates:
            conn.close()
            return jsonify({'success': False, 'message': 'æ²¡æœ‰è¦æ›´æ–°çš„å†…å®¹'})

        params.append(id)
        c.execute(f"UPDATE member_groups SET {', '.join(updates)} WHERE id = ?", params)
        conn.commit()
        conn.close()

        return jsonify({'success': True, 'message': 'æ›´æ–°æˆåŠŸ'})
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500


@app.route('/api/member-groups/<int:id>/verify', methods=['POST'])
@login_required
def api_verify_member_group(id):
    """éªŒè¯ç¾¤ç»„çŠ¶æ€ (è§¦å‘Botæ£€æµ‹)"""
    try:
        conn = get_db_conn()
        c = conn.cursor()
        c.execute("SELECT group_link FROM member_groups WHERE id = ?", (id,))
        row = c.fetchone()
        conn.close()

        if not row or not row[0]:
            return jsonify({'success': False, 'message': 'ç¾¤ç»„ä¸å­˜åœ¨æˆ–æ— é“¾æ¥'}), 404

        group_link = row[0]

        # å°è¯•è°ƒç”¨ Bot éªŒè¯ (è¿™æ˜¯ä¸€ä¸ªå¼‚æ­¥æ“ä½œï¼ŒWebç«¯åªèƒ½è¿”å›å·²æäº¤)
        # è¿™é‡Œç®€å•è¿”å›æˆåŠŸï¼Œå®é™…éªŒè¯ä¾èµ–åå° check_member_status_task ä»»åŠ¡
        # æˆ–è€…å¯ä»¥æ‰‹åŠ¨è§¦å‘ä¸€æ¬¡æ£€æµ‹é€»è¾‘

        return jsonify({
            'success': True,
            'message': 'éªŒè¯è¯·æ±‚å·²æäº¤ï¼Œè¯·ç¨ååˆ·æ–°æŸ¥çœ‹çŠ¶æ€ (ç³»ç»Ÿåå°ä¼šè‡ªåŠ¨å®šæ—¶æ£€æµ‹)'
        })
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500

@app.route('/api/member-groups/broadcast', methods=['POST'])
@login_required
def api_broadcast_to_groups():
    """å‘é€‰ä¸­çš„ä¼šå‘˜ç¾¤ç»„å‘é€å¹¿æ’­æ¶ˆæ¯"""
    try:
        data = request.get_json() or {}
        group_ids = data.get('group_ids', [])
        message = (data.get('message', '')).strip()

        if not message:
            return jsonify({'success': False, 'message': 'æ¶ˆæ¯å†…å®¹ä¸èƒ½ä¸ºç©º'}), 400

        if not group_ids:
            return jsonify({'success': False, 'message': 'è¯·é€‰æ‹©è¦å‘é€çš„ç¾¤ç»„'}), 400

        conn = get_db_conn()
        c = conn.cursor()

        # è·å–é€‰ä¸­çš„ç¾¤ç»„ä¿¡æ¯
        placeholders = ','.join(['?' for _ in group_ids])
        c.execute(f'SELECT id, group_link, group_name FROM member_groups WHERE id IN ({placeholders})', group_ids)
        groups = c.fetchall()
        conn.close()

        if not groups:
            return jsonify({'success': False, 'message': 'æœªæ‰¾åˆ°å¯¹åº”çš„ç¾¤ç»„'}), 404

        # ã€ä¿®å¤ç‚¹ã€‘æ­£ç¡®å¼•ç”¨ bot_logic ä¸­çš„å˜é‡
        import bot_logic
        # ç¡®ä¿åˆ—è¡¨å­˜åœ¨
        if not hasattr(bot_logic, 'pending_broadcasts'):
            bot_logic.pending_broadcasts = []

        sent_count = 0
        for group in groups:
            group_link = group[1]
            if group_link and 't.me/' in group_link:
                try:
                    # ç›´æ¥è¿½åŠ åˆ° bot_logic æ¨¡å—çš„åˆ—è¡¨ä¸­
                    bot_logic.pending_broadcasts.append({
                        'type': 'broadcast',
                        'group_links': [group_link],
                        'message_content': message
                    })
                    sent_count += 1
                except Exception as e:
                    print(f'[ç¾¤å‘API] æ·»åŠ ç¾¤ç»„ {group[0]} å¤±è´¥: {e}')
                    continue

        if sent_count == 0:
            return jsonify({'success': False, 'message': 'æ²¡æœ‰æœ‰æ•ˆçš„ç¾¤ç»„é“¾æ¥å¯ä»¥å‘é€'}), 400

        return jsonify({
            'success': True,
            'sent_count': sent_count,
            'message': f'å·²å°†ç¾¤å‘ä»»åŠ¡æ·»åŠ åˆ°é˜Ÿåˆ—ï¼Œå°†å‘é€åˆ° {sent_count} ä¸ªç¾¤ç»„'
        })

    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500

@app.route('/api/fallback-accounts', methods=['GET', 'POST'])
@login_required
def api_fallback_accounts():
    """è·å–æ¡æ¼è´¦å·åˆ—è¡¨æˆ–æ·»åŠ æ–°è´¦å·"""
    try:
        conn = get_db_conn()
        c = conn.cursor()

        if request.method == 'GET':
            # è·å–æ¡æ¼è´¦å·åˆ—è¡¨
            c.execute('''
                SELECT fa.id, fa.telegram_id, fa.username, fa.group_link, fa.total_earned, fa.is_active,
                       m.is_vip, m.balance
                FROM fallback_accounts fa
                LEFT JOIN members m ON fa.telegram_id = m.telegram_id
                ORDER BY fa.id ASC
            ''')
            accounts = []
            for row in c.fetchall():
                telegram_id = row[1]
                # é‡æ–°è®¡ç®—ï¼šç»Ÿè®¡ earnings_records ä¸­ï¼Œç»™è¯¥æ¡æ¼è´¦å·çš„æ‰€æœ‰å«"æ¡æ¼"è¯´æ˜çš„æ”¶ç›Š
                c2 = conn.cursor()
                c2.execute('''
                    SELECT COALESCE(SUM(amount), 0)
                    FROM earnings_records
                    WHERE earning_user = ? AND description LIKE '%æ¡æ¼%'
                ''', (telegram_id,))
                calculated_total = c2.fetchone()[0] or 0

                stored_total = row[4] or 0
                if abs(calculated_total - stored_total) > 0.01:
                    c.execute('UPDATE fallback_accounts SET total_earned = ? WHERE telegram_id = ?',
                             (calculated_total, telegram_id))
                    conn.commit()
                    stored_total = calculated_total

                accounts.append({
                    'id': row[0],
                    'telegram_id': telegram_id,
                    'username': row[2] or str(telegram_id),
                    'group_link': row[3] or '',
                    'total_earned': stored_total,
                    'is_active': row[5] if row[5] is not None else 1,
                    'is_vip': row[6] if row[6] is not None else 0,
                    'balance': row[7] if row[7] is not None else 0
                })
            conn.close()
            return jsonify({'success': True, 'accounts': accounts})

        elif request.method == 'POST':
            # æ·»åŠ æ–°æ¡æ¼è´¦å·
            data = request.json or {}
            username = data.get('username', '').strip()
            group_link = data.get('group_link', '').strip()

            if not username:
                conn.close()
                return jsonify({'success': False, 'message': 'è¯·è¾“å…¥Telegramç”¨æˆ·å'}), 400

            # å¤„ç†ç”¨æˆ·åæ ¼å¼
            if username.startswith('@'):
                username = username[1:]

            # å°è¯•è§£ætelegram_idï¼ˆå¦‚æœæ˜¯æ•°å­—ï¼‰
            telegram_id = None
            if username.isdigit():
                telegram_id = int(username)
            # å¦‚æœä¸æ˜¯æ•°å­—ï¼Œå°±å½“ä½œç”¨æˆ·åå¤„ç†ï¼Œtelegram_idè®¾ä¸ºNone

            # æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨ï¼ˆé€šè¿‡ç”¨æˆ·åæˆ–telegram_idï¼‰
            if telegram_id:
                c.execute('SELECT id FROM fallback_accounts WHERE telegram_id = ? OR username = ?', (telegram_id, username))
            else:
                c.execute('SELECT id FROM fallback_accounts WHERE username = ?', (username,))

            if c.fetchone():
                conn.close()
                return jsonify({'success': False, 'message': 'è¯¥è´¦å·å·²å­˜åœ¨'}), 400

            # å¦‚æœæœ‰telegram_idï¼Œæ£€æŸ¥æ˜¯å¦å­˜åœ¨å¯¹åº”çš„membersè®°å½•
            if telegram_id:
                c.execute('SELECT telegram_id FROM members WHERE telegram_id = ?', (telegram_id,))
                member_exists = c.fetchone() is not None

                if not member_exists:
                    # å¦‚æœmembersè¡¨ä¸­æ²¡æœ‰ï¼Œå…ˆåˆ›å»ºmembersè®°å½•
                    c.execute('''
                        INSERT INTO members (telegram_id, username, register_time)
                        VALUES (?, ?, ?)
                    ''', (telegram_id, username, get_cn_time()))

            # æ·»åŠ åˆ°fallback_accounts
            c.execute('''
                INSERT INTO fallback_accounts (telegram_id, username, group_link, is_active, main_account_id)
                VALUES (?, ?, ?, 1, ?)
            ''', (telegram_id, username, group_link if group_link else None, telegram_id))

            conn.commit()
            conn.close()

            return jsonify({'success': True, 'message': 'æ¡æ¼è´¦å·æ·»åŠ æˆåŠŸ'})

    except Exception as e:
        try:
            conn.close()
        except:
            pass
        return jsonify({'success': False, 'message': str(e)}), 500

@app.route('/api/earnings')
@login_required
def api_get_earnings():
    """è·å–æ”¶ç›Šè®°å½•åˆ—è¡¨"""
    try:
        page = request.args.get('page', 1, type=int)
        per_page = request.args.get('per_page', 20, type=int)
        search = request.args.get('search', '').strip()
        
        conn = get_db_conn()
        c = conn.cursor()
        offset = (page - 1) * per_page
        
        where_clause = ''
        params = []
        
        if search:
            if search.isdigit():
                where_clause = 'WHERE er.earning_user = ?'
                params = [int(search)]
            else:
                where_clause = 'WHERE (m.username LIKE ? OR fa.username LIKE ?)'
                params = [f'%{search}%', f'%{search}%']
        
        count_query = f'''
            SELECT COUNT(*) FROM earnings_records er
            LEFT JOIN members m ON er.earning_user = m.telegram_id
            LEFT JOIN fallback_accounts fa ON er.earning_user = fa.telegram_id
            {where_clause}
        '''
        c.execute(count_query, params)
        total = c.fetchone()[0]
        
        query = f'''
            SELECT er.id, er.earning_user as member_id,
                   COALESCE(m.username, fa.username, '') as username,
                   er.amount, er.upgraded_user, er.description, er.create_time
            FROM earnings_records er
            LEFT JOIN members m ON er.earning_user = m.telegram_id
            LEFT JOIN fallback_accounts fa ON er.earning_user = fa.telegram_id
            {where_clause}
            ORDER BY er.create_time DESC
            LIMIT ? OFFSET ?
        '''
        c.execute(query, params + [per_page, offset])
        
        records = []
        for row in c.fetchall():
            member_id = row[1]
            username = row[2] or ''
            upgraded_user_id = row[4] if len(row) > 4 else None
            
            if member_id and not username:
                c2 = conn.cursor()
                c2.execute('SELECT username, telegram_id FROM fallback_accounts WHERE telegram_id = ?', (member_id,))
                fb_row = c2.fetchone()
                if fb_row:
                    username = fb_row[0] or ''
                    if not username:
                        username = str(fb_row[1]) if fb_row[1] else str(member_id)
                else:
                    c2.execute('SELECT username FROM members WHERE telegram_id = ?', (member_id,))
                    m_row = c2.fetchone()
                    if m_row and m_row[0]:
                        username = m_row[0]
                    else:
                        username = str(member_id)
            # ç›´æ¥è¯»å–æ•°æ®åº“ä¸­çš„ description
            detailed_description = row[5] or ''

            # å¦‚æœæ˜¯æ—§æ•°æ®ï¼ˆæ²¡æœ‰è¯¦ç»†è¯´æ˜ï¼‰ï¼Œå¯ä»¥ä¿ç•™ä¸€ç‚¹ç®€å•çš„å…¼å®¹é€»è¾‘ï¼Œæˆ–è€…ç›´æ¥æ˜¾ç¤º
            if not detailed_description:
                detailed_description = "æ”¶ç›Šè®°å½•"

            try:
                if upgraded_user_id:
                    upm = DB.get_member(upgraded_user_id)
                    upgraded_name = f"@{upm['username']}" if upm and upm.get('username') else str(upgraded_user_id)
                else:
                    upgraded_name = '-'
            except:
                upgraded_name = str(upgraded_user_id) if upgraded_user_id else '-'
            
            records.append({
                'id': row[0],
                'member_id': member_id if member_id is not None else 0,
                'username': username or (str(member_id) if member_id else 'N/A'),
                'amount': row[3],
                'upgraded_user_id': upgraded_user_id or 0,
                'upgraded_user_name': upgraded_name,
                'description': detailed_description,  # ä½¿ç”¨è¯¦ç»†è¯´æ˜
                'create_time': row[6][:19] if row[6] else ''
            })
        
        conn.close()
        
        return jsonify({
            'success': True,
            'records': records,
            'total': total,
            'page': page,
            'pages': (total + per_page - 1) // per_page if total > 0 else 1,
            'per_page': per_page
        })
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500

@app.route('/api/resource_categories')
@login_required
def api_get_resource_categories():
    """è·å–èµ„æºåˆ†ç±»åˆ—è¡¨"""
    try:
        categories = DB.get_resource_categories(0)
        return jsonify({'success': True, 'categories': categories})
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500


@app.route('/api/resource_categories/<int:id>')
@login_required
def api_get_resource_category(id):
    """è·å–å•ä¸ªèµ„æºåˆ†ç±»"""
    try:
        conn = get_db_conn()
        c = conn.cursor()
        c.execute('SELECT id, name, parent_id FROM resource_categories WHERE id = ?', (id,))
        row = c.fetchone()
        conn.close()
        if row:
            return jsonify({'id': row[0], 'name': row[1], 'parent_id': row[2]})
        return jsonify({'success': False, 'message': 'åˆ†ç±»ä¸å­˜åœ¨'}), 404
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500


@app.route('/api/resource_categories', methods=['POST'])
@login_required
def api_create_resource_category():
    """åˆ›å»ºèµ„æºåˆ†ç±»"""
    try:
        data = request.json or {}
        name = (data.get('name') or '').strip()
        parent_id = int(data.get('parent_id', 0) or 0)
        if not name:
            return jsonify({'success': False, 'message': 'åˆ†ç±»åç§°ä¸èƒ½ä¸ºç©º'}), 400
        conn = get_db_conn()
        c = conn.cursor()
        c.execute('INSERT INTO resource_categories (name, parent_id) VALUES (?, ?)', (name, parent_id))
        conn.commit()
        conn.close()
        return jsonify({'success': True, 'message': 'åˆ›å»ºæˆåŠŸ'})
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500


@app.route('/api/resource_categories/<int:id>', methods=['PUT'])
@login_required
def api_update_resource_category(id):
    """æ›´æ–°èµ„æºåˆ†ç±»"""
    try:
        data = request.json or {}
        name = (data.get('name') or '').strip()
        parent_id = int(data.get('parent_id', 0) or 0)
        if not name:
            return jsonify({'success': False, 'message': 'åˆ†ç±»åç§°ä¸èƒ½ä¸ºç©º'}), 400
        conn = get_db_conn()
        c = conn.cursor()
        c.execute('UPDATE resource_categories SET name = ?, parent_id = ? WHERE id = ?', (name, parent_id, id))
        conn.commit()
        conn.close()
        return jsonify({'success': True, 'message': 'æ›´æ–°æˆåŠŸ'})
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500


@app.route('/api/resource_categories/<int:id>', methods=['DELETE'])
@login_required
def api_delete_resource_category(id):
    """åˆ é™¤èµ„æºåˆ†ç±»"""
    try:
        conn = get_db_conn()
        c = conn.cursor()
        c.execute('SELECT COUNT(*) FROM resource_categories WHERE parent_id = ?', (id,))
        if c.fetchone()[0] > 0:
            conn.close()
            return jsonify({'success': False, 'message': 'è¯¥åˆ†ç±»ä¸‹æœ‰å­åˆ†ç±»ï¼Œæ— æ³•åˆ é™¤'}), 400
        c.execute('SELECT COUNT(*) FROM resources WHERE category_id = ?', (id,))
        if c.fetchone()[0] > 0:
            conn.close()
            return jsonify({'success': False, 'message': 'è¯¥åˆ†ç±»ä¸‹æœ‰èµ„æºï¼Œæ— æ³•åˆ é™¤'}), 400
        c.execute('DELETE FROM resource_categories WHERE id = ?', (id,))
        conn.commit()
        conn.close()
        return jsonify({'success': True, 'message': 'åˆ é™¤æˆåŠŸ'})
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500


@app.route('/api/resources')
@login_required
def api_get_resources():
    """è·å–èµ„æºåˆ—è¡¨"""
    try:
        category_id = request.args.get('category_id', type=int)
        conn = get_db_conn()
        c = conn.cursor()
        if category_id:
            c.execute('''
                SELECT r.id, r.name, r.link, r.type, r.member_count, r.category_id, rc.name
                FROM resources r
                LEFT JOIN resource_categories rc ON r.category_id = rc.id
                WHERE r.category_id = ?
                ORDER BY r.id DESC
            ''', (category_id,))
        else:
            c.execute('''
                SELECT r.id, r.name, r.link, r.type, r.member_count, r.category_id, rc.name
                FROM resources r
                LEFT JOIN resource_categories rc ON r.category_id = rc.id
                ORDER BY r.id DESC
            ''')
        rows = c.fetchall()
        resources = []
        for row in rows:
            resources.append({
                'id': row[0],
                'name': row[1],
                'link': row[2],
                'type': row[3],
                'member_count': row[4],
                'category_id': row[5],
                'category_name': row[6] or ''
            })
        conn.close()
        return jsonify({'success': True, 'resources': resources})
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500


@app.route('/api/resources/<int:id>')
@login_required
def api_get_resource(id):
    """è·å–å•ä¸ªèµ„æº"""
    try:
        conn = get_db_conn()
        c = conn.cursor()
        c.execute('SELECT id, name, link, type, member_count, category_id FROM resources WHERE id = ?', (id,))
        row = c.fetchone()
        conn.close()
        if row:
            return jsonify({
                'id': row[0],
                'name': row[1],
                'link': row[2],
                'type': row[3],
                'member_count': row[4],
                'category_id': row[5]
            })
        return jsonify({'success': False, 'message': 'èµ„æºä¸å­˜åœ¨'}), 404
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500


@app.route('/api/resources', methods=['POST'])
@login_required
def api_create_resource():
    """åˆ›å»ºèµ„æº"""
    try:
        data = request.json or {}
        name = (data.get('name') or '').strip()
        link = (data.get('link') or '').strip()
        rtype = (data.get('type') or '').strip()
        category_id = int(data.get('category_id', 0) or 0)
        member_count = int(data.get('member_count', 0) or 0)
        if not name or not link or not rtype:
            return jsonify({'success': False, 'message': 'å¿…å¡«å­—æ®µä¸èƒ½ä¸ºç©º'}), 400
        if rtype not in ['group', 'channel']:
            return jsonify({'success': False, 'message': 'èµ„æºç±»å‹ä¸æ­£ç¡®'}), 400
        if not (link.startswith('https://t.me/') or link.startswith('t.me/') or link.startswith('@')):
            return jsonify({'success': False, 'message': 'Telegramé“¾æ¥æ ¼å¼ä¸æ­£ç¡®'}), 400
        conn = get_db_conn()
        c = conn.cursor()
        c.execute('INSERT INTO resources (category_id, name, link, type, member_count) VALUES (?, ?, ?, ?, ?)',
                  (category_id, name, link, rtype, member_count))
        conn.commit()
        conn.close()
        return jsonify({'success': True, 'message': 'åˆ›å»ºæˆåŠŸ'})
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500


@app.route('/api/resources/<int:id>', methods=['PUT'])
@login_required
def api_update_resource(id):
    """æ›´æ–°èµ„æº"""
    try:
        data = request.json or {}
        category_id = int(data.get('category_id', 0) or 0)
        name = (data.get('name') or '').strip()
        link = (data.get('link') or '').strip()
        rtype = (data.get('type') or '').strip()
        member_count = int(data.get('member_count', 0) or 0)
        conn = get_db_conn()
        c = conn.cursor()
        c.execute('''
            UPDATE resources 
            SET category_id = ?, name = ?, link = ?, type = ?, member_count = ?
            WHERE id = ?
        ''', (category_id, name, link, rtype, member_count, id))
        conn.commit()
        conn.close()
        return jsonify({'success': True, 'message': 'æ›´æ–°æˆåŠŸ'})
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500


@app.route('/api/resources/<int:id>', methods=['DELETE'])
@login_required
def api_delete_resource(id):
    """åˆ é™¤èµ„æº"""
    try:
        conn = get_db_conn()
        c = conn.cursor()
        c.execute('DELETE FROM resources WHERE id = ?', (id,))
        conn.commit()
        conn.close()
        return jsonify({'success': True, 'message': 'åˆ é™¤æˆåŠŸ'})
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500

@app.route('/api/broadcast/messages')
@login_required
def api_get_broadcast_messages():
    """è·å–ç¾¤å‘å†…å®¹åˆ—è¡¨"""
    try:
        conn = get_db_conn()
        c = conn.cursor()
        c.execute("""SELECT id, title, content, media_type, media_url, is_active, create_time,
                    image_url, video_url, buttons, buttons_per_row, broadcast_interval
                    FROM broadcast_messages ORDER BY id DESC""")
        rows = c.fetchall()
        messages = []
        for row in rows:
            messages.append({
                'id': row[0],
                'title': row[1],
                'content': row[2],
                'media_type': row[3],
                'media_url': row[4],
                'is_active': row[5],
                'create_time': row[6],
                'image_url': row[7] or '',
                'video_url': row[8] or '',
                'buttons': row[9] or '[]',
                'buttons_per_row': row[10] or 2,
                'broadcast_interval': row[11] or 120
            })
        conn.close()
        return jsonify({'success': True, 'messages': messages})
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/broadcast/send', methods=['POST'])
@login_required
def api_broadcast_send():
    """æ‰‹åŠ¨ç¾¤å‘æ¶ˆæ¯åˆ°æŒ‡å®šç¾¤ç»„"""
    try:
        data = request.get_json() or {}
        message = data.get('message', '')
        group_ids = data.get('group_ids', [])
        send_all = data.get('all', False)

        if not message:
            return jsonify({'success': False, 'message': 'æ¶ˆæ¯å†…å®¹ä¸èƒ½ä¸ºç©º'}), 400

        conn = get_db_conn()
        c = conn.cursor()

        if send_all:
            c.execute('SELECT id, group_link, group_name FROM member_groups')
        else:
            if not group_ids:
                conn.close()
                return jsonify({'success': False, 'message': 'è¯·é€‰æ‹©ç¾¤ç»„'}), 400
            placeholders = ','.join(['?' for _ in group_ids])
            c.execute(f'SELECT id, group_link, group_name FROM member_groups WHERE id IN ({placeholders})', group_ids)

        groups = c.fetchall()
        conn.close()

        if not groups:
            return jsonify({'success': False, 'message': 'æ²¡æœ‰æ‰¾åˆ°ç¾¤ç»„'}), 400

        # åŠ å…¥å‘é€é˜Ÿåˆ—
        sent = 0
        for g in groups:
            group_link = g[1]
            if group_link and 't.me/' in group_link:
                try:
                    pending_broadcasts.append({
                        'type': 'broadcast',
                        'group_links': [group_link],
                        'message_content': message
                    })
                    sent += 1
                except Exception:
                    pass

        return jsonify({'success': True, 'sent': sent, 'message': f'å·²åŠ å…¥å‘é€é˜Ÿåˆ—: {sent}ä¸ªç¾¤ç»„'})
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500

@app.route('/api/bot-configs')
@login_required
def api_bot_configs():
    """è·å–Boté…ç½®åˆ—è¡¨ (ä¿®å¤ç‰ˆ: è¿”å›å®Œæ•´å¯¹è±¡ç»“æ„)"""
    try:
        conn = get_db_conn()
        c = conn.cursor()
        # ä» bot_configs è¡¨è¯»å–è¯¦ç»†ä¿¡æ¯ï¼Œè€Œä¸æ˜¯ä» system_config è¯»å–ç®€å•å­—ç¬¦ä¸²
        c.execute("SELECT id, bot_token, bot_username, is_active, create_time FROM bot_configs ORDER BY id DESC")
        rows = c.fetchall()
        conn.close()

        configs = []
        for row in rows:
            configs.append({
                'id': row[0],
                'bot_token': row[1],
                'bot_username': row[2] or 'æœªçŸ¥',
                'is_active': row[3],
                'create_time': row[4] or ''
            })

        # è¿”å› configs å­—æ®µï¼Œå‰ç«¯è¡¨æ ¼æ‰èƒ½æ­£ç¡®æ¸²æŸ“
        return jsonify({'success': True, 'configs': configs, 'tokens': configs})
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500


@app.route('/api/bot-config', methods=['POST'])
@login_required
def api_create_bot_config():
    """æ·»åŠ æœºå™¨äººé…ç½®"""
    try:
        data = request.json or {}
        token = (data.get('bot_token') or '').strip()
        username = (data.get('bot_username') or '').strip()
        if not token:
            return jsonify({'success': False, 'message': 'Bot Token ä¸èƒ½ä¸ºç©º'}), 400
        conn = get_db_conn()
        c = conn.cursor()
        now = get_cn_time()
        c.execute('INSERT INTO bot_configs (bot_token, bot_username, is_active, create_time) VALUES (?, ?, ?, ?)',
                  (token, username, 1, now))
        conn.commit()
        conn.close()
        return jsonify({'success': True, 'message': 'æœºå™¨äººå·²æ·»åŠ '})
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500


@app.route('/api/bot-config/<int:id>', methods=['DELETE'])
@login_required
def api_delete_bot_config(id):
    """åˆ é™¤æœºå™¨äººé…ç½®"""
    try:
        conn = get_db_conn()
        c = conn.cursor()
        c.execute('DELETE FROM bot_configs WHERE id = ?', (id,))
        conn.commit()
        conn.close()
        return jsonify({'success': True, 'message': 'å·²åˆ é™¤'})
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500


# ============ ç¾¤å‘æ¶ˆæ¯å¢åˆ æ”¹æŸ¥ APIï¼ˆä¸å‰ç«¯æ¨¡æ¿åŒ¹é…ï¼‰ ============
@app.route('/api/broadcast/message', methods=['POST'])
@login_required
def api_create_broadcast_message():
    """åˆ›å»ºç¾¤å‘æ¶ˆæ¯ï¼ˆä¾›å‰ç«¯ templates/broadcast.html ä½¿ç”¨ï¼‰"""
    try:
        data = request.get_json() or {}
        title = (data.get('title') or '')[:200]
        content = data.get('content') or ''
        image_url = data.get('image_url') or ''
        video_url = data.get('video_url') or ''
        buttons = data.get('buttons') or '[]'
        buttons_per_row = int(data.get('buttons_per_row', 2) or 2)
        broadcast_interval = int(data.get('broadcast_interval', 120) or 120)
        now = get_cn_time()

        conn = get_db_conn()
        c = conn.cursor()
        c.execute('''
            INSERT INTO broadcast_messages
            (title, content, media_type, media_url, is_active, create_time, image_url, video_url, buttons, buttons_per_row, broadcast_interval)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        ''', (title, content, None, None, 1, now, image_url, video_url, buttons, buttons_per_row, broadcast_interval))
        conn.commit()
        conn.close()
        return jsonify({'success': True, 'message': 'åˆ›å»ºæˆåŠŸ'})
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500


@app.route('/api/broadcast/message/<int:id>', methods=['GET'])
@login_required
def api_get_broadcast_message(id):
    try:
        conn = get_db_conn()
        c = conn.cursor()
        c.execute('SELECT id, title, content, image_url, video_url, buttons, buttons_per_row, is_active, broadcast_interval, create_time FROM broadcast_messages WHERE id = ?', (id,))
        row = c.fetchone()
        conn.close()
        if not row:
            return jsonify({'success': False, 'message': 'æœªæ‰¾åˆ°è¯¥æ¶ˆæ¯'}), 404
        msg = {
            'id': row[0],
            'title': row[1],
            'content': row[2],
            'image_url': row[3] or '',
            'video_url': row[4] or '',
            'buttons': row[5] or '[]',
            'buttons_per_row': row[6] or 2,
            'is_active': row[7],
            'broadcast_interval': row[8] or 120,
            'create_time': row[9] or ''
        }
        return jsonify({'success': True, 'message': msg})
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500


@app.route('/api/broadcast/message/<int:id>', methods=['PUT'])
@login_required
def api_update_broadcast_message(id):
    try:
        data = request.get_json() or {}
        title = (data.get('title') or '')[:200]
        content = data.get('content') or ''
        image_url = data.get('image_url') or ''
        video_url = data.get('video_url') or ''
        buttons = data.get('buttons') or '[]'
        buttons_per_row = int(data.get('buttons_per_row', 2) or 2)
        broadcast_interval = int(data.get('broadcast_interval', 120) or 120)
        is_active = 1 if data.get('is_active', True) else 0

        conn = get_db_conn()
        c = conn.cursor()
        c.execute('''
            UPDATE broadcast_messages
            SET title = ?, content = ?, image_url = ?, video_url = ?, buttons = ?, buttons_per_row = ?, broadcast_interval = ?, is_active = ?
            WHERE id = ?
        ''', (title, content, image_url, video_url, buttons, buttons_per_row, broadcast_interval, is_active, id))
        conn.commit()
        conn.close()
        return jsonify({'success': True, 'message': 'æ›´æ–°æˆåŠŸ'})
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500


@app.route('/api/broadcast/message/<int:id>', methods=['DELETE'])
@login_required
def api_delete_broadcast_message(id):
    try:
        conn = get_db_conn()
        c = conn.cursor()
        c.execute('DELETE FROM broadcast_messages WHERE id = ?', (id,))
        conn.commit()
        conn.close()
        return jsonify({'success': True, 'message': 'åˆ é™¤æˆåŠŸ'})
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500

@app.route('/api/upload', methods=['POST'])
@login_required
def api_upload_file():
    """ä¸Šä¼ æ–‡ä»¶API"""
    try:
        file = request.files.get('file')
        if not file:
            return jsonify({'success': False, 'message': 'æ²¡æœ‰æ–‡ä»¶'}), 400

        # æ£€æŸ¥æ–‡ä»¶å¤§å°ï¼ˆ50MBï¼‰
        if file.content_length and file.content_length > 50 * 1024 * 1024:
            return jsonify({'success': False, 'message': 'æ–‡ä»¶å¤§å°è¶…è¿‡50MB'}), 400

        # æ£€æŸ¥æ–‡ä»¶ç±»å‹
        allowed_types = ['image/jpeg', 'image/png', 'image/gif', 'image/webp', 'video/mp4', 'video/avi', 'video/mov']
        if file.content_type not in allowed_types:
            return jsonify({'success': False, 'message': 'ä¸æ”¯æŒçš„æ–‡ä»¶ç±»å‹'}), 400

        # ç”Ÿæˆæ–‡ä»¶å
        import uuid
        filename = f"{uuid.uuid4().hex}_{file.filename}"
        # ä½¿ç”¨é…ç½®ä¸­çš„ UPLOAD_DIRï¼ˆé€šå¸¸ä¸º <BASE_DIR>/static/uploadsï¼‰
        file_path = os.path.join(UPLOAD_DIR, filename)

        # ç¡®ä¿ä¸Šä¼ ç›®å½•å­˜åœ¨
        os.makedirs(os.path.dirname(file_path), exist_ok=True)

        # ä¿å­˜æ–‡ä»¶
        file.save(file_path)

        # è¿”å›æ–‡ä»¶URL
        file_url = f"/static/uploads/{filename}"
        return jsonify({'success': True, 'url': file_url, 'message': 'ä¸Šä¼ æˆåŠŸ'})

    except Exception as e:
        print(f"ä¸Šä¼ æ–‡ä»¶é”™è¯¯: {e}")
        return jsonify({'success': False, 'message': 'ä¸Šä¼ å¤±è´¥'}), 500

@app.route('/api/welcome-messages')
@login_required
def api_welcome_messages():
    """è·å–æ¬¢è¿æ¶ˆæ¯åˆ—è¡¨"""
    try:
        config = get_system_config()
        return jsonify({
            'success': True,
            'welcome_enabled': config.get('welcome_enabled', '0'),
            'welcome_message': config.get('welcome_message', '')
        })
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500

@app.route('/api/advertisements')
@login_required
def api_advertisements():
    """è·å–å¹¿å‘Šåˆ—è¡¨"""
    try:
        conn = get_db_conn()
        c = conn.cursor()
        c.execute("SELECT id, content, is_active, create_time FROM broadcast_messages WHERE media_type = 'ad' ORDER BY id DESC")
        rows = c.fetchall()
        ads = []
        for row in rows:
            ads.append({
                'id': row[0],
                'content': row[1],
                'is_active': row[2],
                'create_time': row[3]
            })
        conn.close()
        return jsonify({'success': True, 'advertisements': ads})
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500

@app.route('/api/level-settings')
@login_required
def api_level_settings():
    """è·å–å±‚çº§è®¾ç½®"""
    try:
        config = get_system_config()
        # level_amounts: per-level reward amounts (list or dict). If missing, generate defaults.
        level_count = int(config.get('level_count', 10))
        level_reward = float(config.get('level_reward', 1.0))
        level_amounts = config.get('level_amounts')
        if not level_amounts:
            # default: same reward for each level
            level_amounts = [level_reward for _ in range(level_count)]
        else:
            try:
                # ensure it's a list of length level_count (if dict convert)
                import json
                if isinstance(level_amounts, str):
                    parsed = json.loads(level_amounts)
                else:
                    parsed = level_amounts
                if isinstance(parsed, dict):
                    # convert dict {1: amt,...} to list
                    amounts = []
                    for i in range(1, level_count + 1):
                        amounts.append(float(parsed.get(str(i)) or parsed.get(i) or level_reward))
                    level_amounts = amounts
                elif isinstance(parsed, list):
                    # pad or trim
                    parsed = [float(x) for x in parsed]
                    if len(parsed) < level_count:
                        parsed += [level_reward] * (level_count - len(parsed))
                    else:
                        parsed = parsed[:level_count]
                    level_amounts = parsed
                else:
                    level_amounts = [level_reward for _ in range(level_count)]
            except Exception:
                level_amounts = [level_reward for _ in range(level_count)]

        return jsonify({
            'success': True,
            'level_count': level_count,
            'level_reward': level_reward,
            'level_amounts': level_amounts
        })
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500


@app.route('/api/level-settings', methods=['POST'])
@login_required
def api_update_level_settings():
    """ä¿å­˜å±‚çº§è®¾ç½®ï¼ˆä¿®å¤ç‰ˆï¼šå¼ºåˆ¶ä¿å­˜ä¸ºJSONåˆ—è¡¨ï¼‰"""
    try:
        data = request.json or {}
        level_count = int(data.get('level_count', 10))
        level_amounts_raw = data.get('level_amounts') # å‰ç«¯å‘æ¥çš„æ˜¯åˆ—è¡¨æˆ–å­—å…¸
        from database import update_system_config
        import json

        # 1. å¼ºåˆ¶è½¬æ¢ä¸ºæµ®ç‚¹æ•°åˆ—è¡¨ [10.0, 5.0, ...]
        final_amounts = []
        if level_amounts_raw:
            if isinstance(level_amounts_raw, dict):
                # å¦‚æœæ˜¯å­—å…¸ {"1": 10, "2": 5}ï¼ŒæŒ‰keyé¡ºåºè½¬åˆ—è¡¨
                # æ‰¾å‡ºæœ€å¤§çš„keyï¼Œç¡®ä¿åˆ—è¡¨é•¿åº¦è¶³å¤Ÿ
                max_key = 0
                for k in level_amounts_raw.keys():
                    try:
                        ik = int(k)
                        if ik > max_key: max_key = ik
                    except: pass

                # å¡«å……åˆ—è¡¨
                for i in range(1, max_key + 1):
                    v = level_amounts_raw.get(str(i)) or level_amounts_raw.get(i) or 0
                    final_amounts.append(float(v))
            elif isinstance(level_amounts_raw, list):
                final_amounts = [float(x) for x in level_amounts_raw]

        # ç¡®ä¿åˆ—è¡¨é•¿åº¦è‡³å°‘ä¸º level_countï¼Œä¸è¶³è¡¥0
        if len(final_amounts) < level_count:
            final_amounts += [0.0] * (level_count - len(final_amounts))

        # 2. ä¿å­˜é…ç½®
        # å…³é”®ç‚¹ï¼šjson.dumps ç¡®ä¿å®ƒæ˜¯å­—ç¬¦ä¸²æ ¼å¼çš„ JSON æ•°ç»„
            update_system_config('level_amounts', json.dumps(final_amounts))
        update_system_config('level_count', level_count)

        return jsonify({'success': True, 'message': 'å±‚çº§è®¾ç½®å·²ä¿å­˜'})
    except Exception as e:
        print(f"ä¿å­˜è®¾ç½®å‡ºé”™: {e}")
        import traceback
        traceback.print_exc()
        return jsonify({'success': False, 'message': str(e)}), 500

@app.route('/api/withdrawals')
@login_required
def api_withdrawals():
    """è·å–æç°åˆ—è¡¨API"""
    page = request.args.get('page', 1, type=int)
    per_page = request.args.get('per_page', 20, type=int)
    status = request.args.get('status', 'all')
    search = request.args.get('search', '').strip()
    
    data = WebDB.get_withdrawals(page, per_page, status, search)
    return jsonify(data)

@app.route('/api/withdrawals/<int:id>/process', methods=['POST'])
@login_required
def api_process_withdrawal(id):
    """å¤„ç†æç°API"""
    data = request.json
    action = data.get('action')
    
    success, message = WebDB.process_withdrawal(id, action)
    if success:
        return jsonify({'success': True, 'message': message})
    return jsonify({'success': False, 'message': message}), 400

@app.route('/api/recharges/stats')
@login_required
def api_recharges_stats():
    """è·å–å……å€¼ç»Ÿè®¡æ•°æ®"""
    try:
        conn = get_db_conn()
        c = conn.cursor()

        # æ€»å……å€¼é‡‘é¢
        c.execute('SELECT COALESCE(SUM(amount), 0) FROM recharge_records')
        total_amount = c.fetchone()[0]

        # æˆåŠŸå……å€¼é‡‘é¢
        c.execute('SELECT COALESCE(SUM(amount), 0) FROM recharge_records WHERE status = "completed"')
        success_amount = c.fetchone()[0]

        # å¤±è´¥å……å€¼é‡‘é¢
        c.execute('SELECT COALESCE(SUM(amount), 0) FROM recharge_records WHERE status = "failed"')
        failed_amount = c.fetchone()[0]

        # æ€»æäº¤ç¬”æ•°
        c.execute('SELECT COUNT(*) FROM recharge_records')
        total_count = c.fetchone()[0]

        # æˆåŠŸç¬”æ•°
        c.execute('SELECT COUNT(*) FROM recharge_records WHERE status = "completed"')
        success_count = c.fetchone()[0]

        # å¤±è´¥ç¬”æ•°
        c.execute('SELECT COUNT(*) FROM recharge_records WHERE status = "failed"')
        failed_count = c.fetchone()[0]

        # å¾…å¤„ç†ç¬”æ•°
        c.execute('SELECT COUNT(*) FROM recharge_records WHERE status = "pending"')
        pending_count = c.fetchone()[0]

        conn.close()

        return jsonify({
            'success': True,
            'stats': {
                'total_amount': float(total_amount),
                'success_amount': float(success_amount),
                'failed_amount': float(failed_amount),
                'total_count': total_count,
                'success_count': success_count,
                'failed_count': failed_count,
                'pending_count': pending_count
            }
        })

    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500

@app.route('/api/recharges')
@login_required
def api_recharges():
    """è·å–å……å€¼è®¢å•åˆ—è¡¨"""
    try:
        page = int(request.args.get('page', 1))
        per_page = int(request.args.get('per_page', 20))
        search = request.args.get('search', '').lstrip('@').strip()
        
        conn = get_db_conn()
        c = conn.cursor()
        
        where_clause = ''
        params = []
        if search:
            where_clause = 'WHERE r.member_id LIKE ? OR r.order_id LIKE ? OR m.username LIKE ?'
            search_param = f'%{search}%'
            params = [search_param, search_param, search_param]
        
        count_query = f'SELECT COUNT(*) FROM recharge_records r LEFT JOIN members m ON r.member_id = m.telegram_id {where_clause}'
        c.execute(count_query, params)
        total = c.fetchone()[0]
        
        offset = (page - 1) * per_page

        # æ£€æŸ¥ recharge_records è¡¨ä¸­æ˜¯å¦å­˜åœ¨ remark å­—æ®µ
        c.execute("PRAGMA table_info(recharge_records)")
        cols = [r[1] for r in c.fetchall()]
        remark_present = 'remark' in cols

        if remark_present:
            query = f'''
                SELECT r.id, r.member_id, m.username, r.amount, r.order_id,
                       r.status, r.create_time, r.payment_method, r.remark
                FROM recharge_records r
                LEFT JOIN members m ON r.member_id = m.telegram_id
                {where_clause}
                ORDER BY r.create_time DESC
                LIMIT ? OFFSET ?
            '''
        else:
            query = f'''
                SELECT r.id, r.member_id, m.username, r.amount, r.order_id,
                       r.status, r.create_time, r.payment_method
                FROM recharge_records r
                LEFT JOIN members m ON r.member_id = m.telegram_id
                {where_clause}
                ORDER BY r.create_time DESC
                LIMIT ? OFFSET ?
            '''
        c.execute(query, params + [per_page, offset])

        recharges = []
        for row in c.fetchall():
            # æ ¹æ®remarkåˆ¤æ–­å……å€¼ç±»å‹
            remark = row[8] if remark_present and len(row) > 8 else ''
            recharge_type = 'å¼€é€šVIP' if remark == 'å¼€é€š' else 'å……å€¼'

            item = {
                'id': row[0],
                'telegram_id': row[1],
                'username': row[2] or '',
                'amount': row[3],
                'order_number': row[4] or '',
                'status': row[5],
                'create_time': row[6][:19] if row[6] else '',
                'payment_method': row[7] or '',
                'type': recharge_type  # æ–°å¢ç±»å‹å­—æ®µ
            }
            if remark_present:
                item['remark'] = remark
            else:
                item['remark'] = ''
            recharges.append(item)
        
        conn.close()
        
        return jsonify({
            'success': True,
            'records': recharges,
            'total': total,
            'page': page,
            'per_page': per_page
        })
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500

@app.route('/api/recharges/<int:recharge_id>/status', methods=['POST'])
@login_required
def api_update_recharge_status(recharge_id):
    """ã€æ ¸å¿ƒä¿®å¤ã€‘åå°æ‰‹åŠ¨ä¿®æ”¹å……å€¼è®¢å•çŠ¶æ€ - ç»Ÿä¸€è°ƒç”¨ process_recharge"""
    try:
        data = request.get_json() or {}
        new_status = (data.get('status') or '').strip()
        if not new_status:
            return jsonify({'success': False, 'message': 'ç¼ºå°‘çŠ¶æ€å‚æ•°'})

        conn = get_db_conn()
        c = conn.cursor()
        c.execute('SELECT member_id, amount, status, order_id FROM recharge_records WHERE id = ?', (recharge_id,))
        row = c.fetchone()
        if not row:
            conn.close()
            return jsonify({'success': False, 'message': 'è®¢å•ä¸å­˜åœ¨'})

        member_id, amount, old_status, order_id = row
        
        if new_status != 'completed':
            c.execute('UPDATE recharge_records SET status = ? WHERE id = ?', (new_status, recharge_id))
            conn.commit()
            conn.close()
            return jsonify({'success': True, 'message': 'è®¢å•çŠ¶æ€å·²æ›´æ–°'})

        if old_status == 'completed':
            conn.close()
            return jsonify({'success': True, 'message': 'è¯¥è®¢å•å·²æ˜¯å·²æ”¯ä»˜çŠ¶æ€ï¼Œæ— éœ€é‡å¤å¤„ç†'})

        # 1. æ ‡è®°æ•°æ®åº“çŠ¶æ€
        # ã€ä¿®å¤ç‚¹ã€‘æ ¹æ®é‡‘é¢åˆ¤æ–­æ˜¯å¦æ ‡è®°ä¸º"å¼€é€š"
        config = get_system_config()
        vip_price = float(config.get('vip_price', 10))
        remark_text = 'ç®¡ç†å‘˜æ‰‹åŠ¨é€šè¿‡'

        # æ£€æŸ¥æ˜¯å¦æ˜¯VIPè®¢å•ï¼ˆåŸºäºé‡‘é¢åˆ¤æ–­ï¼‰
        is_vip_order = False
        if amount >= vip_price:
            is_vip_order = True
            remark_text = 'å¼€é€š'  # å…³é”®ï¼šè¿™å°±æŠŠç±»å‹æ”¹æˆäº†"å¼€é€šVIP"

        c.execute('UPDATE recharge_records SET status = ?, remark = ? WHERE id = ?',
                 ('completed', remark_text, recharge_id))

        # 2. ç»™ç”¨æˆ·åŠ ä½™é¢ (é‡è¦ï¼)
        c.execute('UPDATE members SET balance = balance + ? WHERE telegram_id = ?', (amount, member_id))
        conn.commit()
        conn.close()

        # 3. ã€æ ¸å¿ƒã€‘å‘Šè¯‰æœºå™¨äººå»å¤„ç†ä¸šåŠ¡ï¼ˆå¼€VIPã€åˆ†çº¢ã€å‘é€šçŸ¥ï¼‰
        # è¿™ä¼šè§¦å‘ bot_logic.process_rechargeï¼Œå®ƒä¼šè‡ªåŠ¨è¯†åˆ«ä½™é¢æ˜¯å¦è¶³å¤Ÿå¼€VIP
        try:
            import bot_logic
            if hasattr(bot_logic, 'process_recharge_queue'):
                # æ¨å…¥é˜Ÿåˆ—ï¼Œè®©æœºå™¨äººçº¿ç¨‹å»æ‰£æ¬¾ã€å¼€é€šVIPã€å‘åˆ†çº¢
                bot_logic.process_recharge_queue.append({
                    'member_id': member_id,
                    'amount': amount,
                    'is_vip_order': is_vip_order  # ä¼ é€’æ­£ç¡®çš„æ ‡å¿—
                })
                print(f"[Webåå°æ‰‹åŠ¨é€šè¿‡] å·²å°†è®¢å• {order_id} æ¨é€ç»™æœºå™¨äººå¤„ç†VIPé€»è¾‘ï¼ŒVIPè®¢å•: {is_vip_order}")
        except Exception as e:
            print(f"[Webåå°æ‰‹åŠ¨é€šè¿‡] æ¨é€æœºå™¨äººé˜Ÿåˆ—å¤±è´¥: {e}")

        return jsonify({'success': True, 'message': 'å·²æ‰‹åŠ¨é€šè¿‡ï¼ŒVIPå¼€é€šå’Œåˆ†çº¢å°†åœ¨å‡ ç§’å†…è‡ªåŠ¨å¤„ç†'})
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500

@app.route('/api/members/broadcast', methods=['POST'])
@login_required
def api_members_broadcast():
    global notify_queue
    """å‘ä¼šå‘˜å‘é€ç¾¤å‘æ¶ˆæ¯"""
    try:
        data = request.get_json() or {}
        message = (data.get('message') or '').strip()
        member_ids = data.get('member_ids') or []
        send_all = bool(data.get('all'))

        if not message:
            return jsonify({'success': False, 'message': 'æ¶ˆæ¯å†…å®¹ä¸èƒ½ä¸ºç©º'})

        conn = get_db_conn()
        c = conn.cursor()

        targets = []
        if send_all:
            c.execute('SELECT telegram_id FROM members')
            targets = [row[0] for row in c.fetchall()]
        else:
            ids = []
            for mid in member_ids:
                try:
                    ids.append(int(mid))
                except (TypeError, ValueError):
                    continue
            if not ids:
                conn.close()
                return jsonify({'success': False, 'message': 'è¯·é€‰æ‹©è¦å‘é€çš„ä¼šå‘˜'})
            placeholders = ','.join(['?' for _ in ids])
            c.execute(f'SELECT telegram_id FROM members WHERE telegram_id IN ({placeholders})', ids)
            targets = [row[0] for row in c.fetchall()]

        conn.close()

        if not targets:
            return jsonify({'success': False, 'message': 'æœªæ‰¾åˆ°å¯¹åº”çš„ä¼šå‘˜'})

        # ç¡®ä¿notify_queueå·²åˆå§‹åŒ–
        if not notify_queue:
            from bot_logic import notify_queue
        
        for mid in targets:
            notify_queue.append({'member_id': mid, 'message': message})

        count = len(targets)
        return jsonify({'success': True, 'count': count, 'message': f'å·²åŠ å…¥å‘é€é˜Ÿåˆ—ï¼Œå°†å‘ {count} ä½ä¼šå‘˜å‘é€'})
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500

@app.route('/api/settings', methods=['GET'])
@login_required
def api_get_settings():
    """è·å–ç³»ç»Ÿè®¾ç½®API"""
    try:
        config = get_system_config()
        return jsonify({
            'success': True,
            'settings': {
                'levels': config.get('level_count', 10),
                'reward_per_level': config.get('level_reward', 1),
                'vip_price': config.get('vip_price', 10),
                'withdraw_threshold': config.get('withdraw_threshold', 50),
                'usdt_address': config.get('usdt_address', ''),
                'service_text': config.get('support_text', ''),
                'pinned_ad': config.get('pinned_ad', ''),
                'welcome_message': config.get('welcome_message', ''),
                'welcome_enabled': config.get('welcome_enabled', '1'),
                'auto_register_enabled': config.get('auto_register_enabled', '0')
            }
        })
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500

@app.route('/api/settings', methods=['POST'])
@login_required
def api_update_settings():
    """æ›´æ–°ç³»ç»Ÿè®¾ç½®API"""
    try:
        data = request.json
        key = data.get('key')
        value = data.get('value')
        
        if not key:
            return jsonify({'success': False, 'message': 'ç¼ºå°‘keyå‚æ•°'}), 400
        
        from database import update_system_config
        update_system_config(key, value)
        
        return jsonify({'success': True, 'message': 'è®¾ç½®å·²æ›´æ–°'})
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500

# ==================== è¡¥å…¨é—æ¼çš„ API è·¯ç”± ====================

@app.route('/api/settings/fallback-accounts')
@login_required
def api_settings_fallback_accounts():
    """æ¡æ¼è´¦å·è®¾ç½® API (å…¼å®¹æ—§å‰ç«¯)"""
    return api_fallback_accounts()

@app.route('/api/customer_services')
@login_required
def api_get_customer_services():
    """è·å–å®¢æœåˆ—è¡¨API"""
    try:
        services = DB.get_customer_services()
        # Return as an array for frontend templates that expect a plain list
        return jsonify(services)
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500


@app.route('/api/customer_services', methods=['POST'])
@login_required
def api_create_customer_service():
    """åˆ›å»ºå®¢æœ"""
    try:
        data = request.json or {}
        name = (data.get('name') or '').strip()
        link = (data.get('link') or '').strip()
        if not name or not link:
            return jsonify({'success': False, 'message': 'åç§°å’Œé“¾æ¥ä¸èƒ½ä¸ºç©º'}), 400
        conn = get_db_conn()
        c = conn.cursor()
        c.execute('INSERT INTO customer_service (name, link) VALUES (?, ?)', (name, link))
        conn.commit()
        new_id = c.lastrowid
        conn.close()
        return jsonify({'success': True, 'id': new_id})
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500


@app.route('/api/customer_services/<int:id>', methods=['GET'])
@login_required
def api_get_customer_service(id):
    """è·å–å•ä¸ªå®¢æœ"""
    try:
        conn = get_db_conn()
        c = conn.cursor()
        c.execute('SELECT id, name, link FROM customer_service WHERE id = ?', (id,))
        row = c.fetchone()
        conn.close()
        if not row:
            return jsonify({'success': False, 'message': 'å®¢æœä¸å­˜åœ¨'}), 404
        return jsonify({'id': row[0], 'name': row[1], 'link': row[2]})
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500


@app.route('/api/customer_services/<int:id>', methods=['PUT'])
@login_required
def api_update_customer_service(id):
    """æ›´æ–°å®¢æœ"""
    try:
        data = request.json or {}
        name = data.get('name')
        link = data.get('link')
        if not name and not link:
            return jsonify({'success': False, 'message': 'æ— æ›´æ–°å­—æ®µ'}), 400
        conn = get_db_conn()
        c = conn.cursor()
        if name:
            c.execute('UPDATE customer_service SET name = ? WHERE id = ?', (name, id))
        if link:
            c.execute('UPDATE customer_service SET link = ? WHERE id = ?', (link, id))
        conn.commit()
        conn.close()
        return jsonify({'success': True, 'message': 'æ›´æ–°æˆåŠŸ'})
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500


@app.route('/api/customer_services/<int:id>', methods=['DELETE'])
@login_required
def api_delete_customer_service(id):
    """åˆ é™¤å®¢æœ"""
    try:
        conn = get_db_conn()
        c = conn.cursor()
        c.execute('DELETE FROM customer_service WHERE id = ?', (id,))
        conn.commit()
        conn.close()
        return jsonify({'success': True, 'message': 'åˆ é™¤æˆåŠŸ'})
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500

@app.route('/api/payment-config', methods=['GET'])
@login_required
def api_get_payment_config():
    """è·å–æ”¯ä»˜é…ç½®API"""
    try:
        # Return payload compatible with frontend field names
        return jsonify({
            'success': True,
            'config': {
                'payment_url': PAYMENT_CONFIG.get('api_url', ''),
                'payment_token': PAYMENT_CONFIG.get('key', ''),
                'payment_rate': PAYMENT_CONFIG.get('payment_rate', 1.00),
                'payment_channel': PAYMENT_CONFIG.get('pay_type', 'trc20'),
                'payment_user_id': PAYMENT_CONFIG.get('partner_id', '')
            }
        })
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500


@app.route('/api/payment-config', methods=['POST'])
@login_required
def api_update_payment_config():
    """æ›´æ–°æ”¯ä»˜é…ç½®ï¼ˆå‰ç«¯ä¿å­˜ï¼‰"""
    try:
        data = request.json or {}
        # write to system_config and update in-memory PAYMENT_CONFIG
        from database import update_system_config
        # Support both frontend keys and alternative keys
        url = data.get('payment_url') or data.get('api_url') or data.get('paymentUrl')
        token = data.get('payment_token') or data.get('paymentToken') or data.get('key')
        rate = data.get('payment_rate') or data.get('paymentRate')
        channel = data.get('payment_channel') or data.get('paymentChannel') or data.get('pay_type')
        user_id = data.get('payment_user_id') or data.get('paymentUserId') or data.get('partner_id')

        if url is not None:
            update_system_config('payment_url', url)
            PAYMENT_CONFIG['api_url'] = url
        if token is not None:
            update_system_config('payment_token', token)
            PAYMENT_CONFIG['key'] = token
        if rate is not None:
            update_system_config('payment_rate', str(rate))
            PAYMENT_CONFIG['payment_rate'] = float(rate)
        if channel is not None:
            update_system_config('payment_channel', channel)
            PAYMENT_CONFIG['pay_type'] = channel
        if user_id is not None:
            update_system_config('payment_user_id', str(user_id))
            PAYMENT_CONFIG['partner_id'] = str(user_id)

        return jsonify({'success': True, 'message': 'æ”¯ä»˜é…ç½®å·²ä¿å­˜'})
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500

@app.route('/api/settings/bot-tokens')
@login_required
def api_bot_tokens_alias():
    """Bot Tokenåˆ—è¡¨ (å…¼å®¹æ—§å‰ç«¯)"""
    return api_bot_configs()


@app.route('/api/settings/bot-tokens', methods=['POST'])
@login_required
def api_add_bot_token_alias():
    """æ·»åŠ Bot Token (å…¼å®¹æ—§å‰ç«¯)"""
    try:
        data = request.json or {}
        token = (data.get('token') or '').strip()
        if not token:
            return jsonify({'success': False, 'message': 'Tokenä¸èƒ½ä¸ºç©º'}), 400
        conn = get_db_conn()
        c = conn.cursor()
        c.execute("SELECT COUNT(*) FROM system_config WHERE key LIKE 'bot_token_%'")
        count = c.fetchone()[0]
        key = f'bot_token_{count + 1}'
        c.execute('INSERT INTO system_config (key, value) VALUES (?, ?)', (key, token))
        conn.commit()
        conn.close()
        return jsonify({'success': True, 'message': 'Tokenå·²æ·»åŠ '})
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500


@app.route('/api/settings/bot-tokens/<int:index>', methods=['DELETE'])
@login_required
def api_delete_bot_token_alias(index):
    """åˆ é™¤Bot Token (å…¼å®¹æ—§å‰ç«¯)"""
    try:
        conn = get_db_conn()
        c = conn.cursor()
        # keys are 1-based in UI mapping to bot_token_{n}
        key = f'bot_token_{index + 1}'
        c.execute("DELETE FROM system_config WHERE key = ?", (key,))
        conn.commit()
        conn.close()
        return jsonify({'success': True, 'message': 'Tokenå·²åˆ é™¤'})
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500

@app.route('/api/fallback-accounts/<int:id>', methods=['DELETE'])
@login_required
def api_delete_fallback_account(id):
    """åˆ é™¤æ¡æ¼è´¦å·"""
    try:
        conn = get_db_conn()
        c = conn.cursor()
        c.execute('DELETE FROM fallback_accounts WHERE id = ?', (id,))
        conn.commit()
        conn.close()
        return jsonify({'success': True, 'message': 'åˆ é™¤æˆåŠŸ'})
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500

@app.route('/api/fallback-accounts/<int:id>', methods=['PUT'])
@login_required
def api_update_fallback_account(id):
    """æ›´æ–°æ¡æ¼è´¦å·"""
    try:
        data = request.json
        conn = get_db_conn()
        c = conn.cursor()
        
        updates = []
        params = []
        
        if 'username' in data:
            updates.append('username = ?')
            params.append(data['username'])
        if 'group_link' in data:
            updates.append('group_link = ?')
            params.append(data['group_link'])
        if 'is_active' in data:
            updates.append('is_active = ?')
            params.append(1 if data['is_active'] else 0)
        
        if updates:
            params.append(id)
            c.execute(f'UPDATE fallback_accounts SET {", ".join(updates)} WHERE id = ?', params)
            conn.commit()
        
        conn.close()
        return jsonify({'success': True, 'message': 'æ›´æ–°æˆåŠŸ'})
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500

# ==================== ç®¡ç†å‘˜æ‰‹åŠ¨å¼€é€šVIP API ====================

@app.route('/api/member/<int:telegram_id>/manual-vip', methods=['POST'])
@login_required
def api_manual_vip(telegram_id):
    """
    ã€æ ¸å¿ƒä¿®å¤ã€‘ç®¡ç†å‘˜æ‰‹åŠ¨å¼€é€šVIP - ç»Ÿä¸€è°ƒç”¨ distribute_vip_rewards
    åˆ é™¤æ‰€æœ‰æ‰‹å†™åˆ†çº¢é€»è¾‘
    """
    try:
        config = get_system_config()
        
        # ã€æ ¸å¿ƒä¿®å¤ã€‘ä½¿ç”¨botçš„äº‹ä»¶å¾ªç¯åˆ›å»ºå¼‚æ­¥ä»»åŠ¡
        # Flaskæ˜¯åŒæ­¥çš„ï¼Œæ‰€ä»¥é€šè¿‡äº‹ä»¶å¾ªç¯åˆ›å»ºä»»åŠ¡ï¼Œä¸ç­‰å¾…ç»“æœ
        if bot:
            bot.loop.create_task(admin_manual_vip_handler(telegram_id, config))
        else:
            # å¦‚æœbotæœªåˆå§‹åŒ–ï¼Œå»¶è¿Ÿå¯¼å…¥
            from bot_logic import bot, admin_manual_vip_handler
            bot.loop.create_task(admin_manual_vip_handler(telegram_id, config))
        
        return jsonify({
            'success': True,
            'message': 'VIPå¼€é€šä»»åŠ¡å·²æäº¤ï¼Œæ­£åœ¨åå°å¤„ç†ä¸­...'
        })
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500

def run_web():
    """Web å¯åŠ¨å…¥å£"""
    global PAYMENT_CONFIG

    # Load payment config from database
    try:
        config = get_system_config()
        PAYMENT_CONFIG.update({
            'api_url': config.get('payment_url', PAYMENT_CONFIG.get('api_url', '')),
            'partner_id': str(config.get('payment_user_id', PAYMENT_CONFIG.get('partner_id', ''))),
            'key': config.get('payment_token', PAYMENT_CONFIG.get('key', '')),
            'pay_type': config.get('payment_channel', PAYMENT_CONFIG.get('pay_type', 'trc20')),
            'payment_rate': float(config.get('payment_rate', PAYMENT_CONFIG.get('payment_rate', 1.0))),
        })
        print(f"[Webå¯åŠ¨] å·²åŠ è½½æ”¯ä»˜é…ç½®: URL={PAYMENT_CONFIG['api_url']}, PartnerID={PAYMENT_CONFIG['partner_id']}")
    except Exception as e:
        print(f"[Webå¯åŠ¨] åŠ è½½æ”¯ä»˜é…ç½®å¤±è´¥: {e}")

    # Ensure recharge_records has a remark column for admin notes
    try:
        conn = get_db_conn()
        c = conn.cursor()
        c.execute("PRAGMA table_info(recharge_records)")
        cols = [r[1] for r in c.fetchall()]
        if 'remark' not in cols:
            try:
                c.execute("ALTER TABLE recharge_records ADD COLUMN remark TEXT")
                conn.commit()
            except Exception:
                pass
        conn.close()
    except Exception:
        pass

    print("ğŸŒ Webç®¡ç†åå°å¯åŠ¨ä¸­...")
    app.run(debug=False, host='0.0.0.0', port=5051, use_reloader=False)

__all__ = ['app', 'run_web']

-e 

--- File: ./app/config.py ---
"""
é…ç½®æ–‡ä»¶
ç»Ÿä¸€ç®¡ç†é¡¹ç›®è·¯å¾„å’Œé…ç½®
"""
import os
from pathlib import Path

# é¡¹ç›®æ ¹ç›®å½•
BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))

# æ•°æ®ç›®å½•
DATA_DIR = os.path.join(BASE_DIR, 'data')

# æ•°æ®åº“è·¯å¾„
DB_PATH = os.path.join(DATA_DIR, 'bot.db')

# æ—¥å¿—è·¯å¾„
LOG_PATH = os.path.join(DATA_DIR, 'bot.log')

# PIDæ–‡ä»¶è·¯å¾„
PID_PATH = os.path.join(DATA_DIR, 'bot.pid')

# Sessionæ–‡ä»¶è·¯å¾„
SESSION_PATH = os.path.join(DATA_DIR, 'bot.session')

# é™æ€æ–‡ä»¶ä¸Šä¼ ç›®å½•
UPLOAD_DIR = os.path.join(BASE_DIR, 'static', 'uploads')

# ç¡®ä¿æ•°æ®ç›®å½•å­˜åœ¨
os.makedirs(DATA_DIR, exist_ok=True)
os.makedirs(UPLOAD_DIR, exist_ok=True)

# ==================== Telegram Bot é…ç½® ====================
# ä» .env æ–‡ä»¶æˆ–ç¯å¢ƒå˜é‡è¯»å–é…ç½®

def load_env_config():
    """ä» .env æ–‡ä»¶åŠ è½½é…ç½®"""
    env_file = os.path.join(BASE_DIR, '.env')
    config = {}
    
    # å¦‚æœå­˜åœ¨ .env æ–‡ä»¶ï¼Œè¯»å–é…ç½®
    if os.path.exists(env_file):
        with open(env_file, 'r', encoding='utf-8') as f:
            for line in f:
                line = line.strip()
                # è·³è¿‡ç©ºè¡Œå’Œæ³¨é‡Š
                if not line or line.startswith('#'):
                    continue
                # è§£æ key=value
                if '=' in line:
                    key, value = line.split('=', 1)
                    key = key.strip()
                    value = value.strip().strip('"').strip("'")
                    config[key] = value
    
    return config

# åŠ è½½ç¯å¢ƒé…ç½®
_env_config = load_env_config()

# Telegram API é…ç½®
# ä¼˜å…ˆä»ç¯å¢ƒå˜é‡è¯»å–ï¼Œå…¶æ¬¡ä» .env æ–‡ä»¶è¯»å–ï¼Œæœ€åä½¿ç”¨é»˜è®¤å€¼
API_ID = int(os.getenv('API_ID') or _env_config.get('API_ID', '21332425'))
API_HASH = os.getenv('API_HASH') or _env_config.get('API_HASH', 'f5d0cddc784e3a7a09ea9714ed01f238')
BOT_TOKEN = os.getenv('BOT_TOKEN') or _env_config.get('BOT_TOKEN', '8520376411:AAHGZMmI-oROPyrxBmDTo7_OCtpy8kHWORc')

# ç®¡ç†å‘˜ ID åˆ—è¡¨
_admin_ids_str = os.getenv('ADMIN_IDS') or _env_config.get('ADMIN_IDS', '7935612165')
ADMIN_IDS = [int(uid.strip()) for uid in _admin_ids_str.split(',') if uid.strip()]

# ä»£ç†é…ç½®
USE_PROXY = (os.getenv('USE_PROXY') or _env_config.get('USE_PROXY', 'False')).lower() == 'true'
PROXY_TYPE = os.getenv('PROXY_TYPE') or _env_config.get('PROXY_TYPE', 'socks5')
PROXY_HOST = os.getenv('PROXY_HOST') or _env_config.get('PROXY_HOST', '127.0.0.1')
PROXY_PORT = int(os.getenv('PROXY_PORT') or _env_config.get('PROXY_PORT', '7897'))

-e 

--- File: ./app/core_functions.py ---
"""
æ ¸å¿ƒåŠŸèƒ½æ¨¡å—
åŒ…å«ç¾¤ç»„æ£€æµ‹ã€å±‚çº§è®¡ç®—ã€åˆ†çº¢åˆ†é…ç­‰æ ¸å¿ƒé€»è¾‘
"""
import sqlite3
import os
import sys
from datetime import datetime, timedelta, timezone
from telethon import TelegramClient
from telethon.tl.functions.channels import GetParticipantRequest
from telethon.tl.types import ChannelParticipantAdmin, ChannelParticipantCreator

# å¯¼å…¥é…ç½®
BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
sys.path.insert(0, BASE_DIR)
from app.config import DB_PATH

# å®šä¹‰ä¸­å›½æ—¶åŒº
CN_TIMEZONE = timezone(timedelta(hours=8))

def get_cn_time():
    """è·å–ä¸­å›½æ—¶é—´å­—ç¬¦ä¸²"""
    return datetime.now(CN_TIMEZONE).isoformat()

async def verify_group_link(bot, link):
    """éªŒè¯ç¾¤é“¾æ¥ï¼Œæ£€æŸ¥æœºå™¨äººæ˜¯å¦åœ¨ç¾¤å†…ä¸”ä¸ºç®¡ç†å‘˜
    
    æ”¯æŒï¼š
    - http://t.me/ç¾¤ç”¨æˆ·å / https://t.me/ç¾¤ç”¨æˆ·å ï¼ˆå…¬å¼€ç¾¤ï¼Œæ”¯æŒè‡ªåŠ¨æ£€æµ‹ç®¡ç†å‘˜ï¼‰
    - http://t.me/+xxxx / https://t.me/+xxxx / https://t.me/joinchat/xxxx ï¼ˆç§æœ‰é‚€è¯·é“¾æ¥ï¼Œåªèƒ½è®°å½•ï¼Œæ— æ³•è‡ªåŠ¨æ£€æµ‹ç®¡ç†å‘˜ï¼‰
    
    è¿”å›ç¤ºä¾‹ï¼š
    - {'success': True, 'message': 'xxx', 'admin_checked': True/False}
    """
    try:
        # å¿…é¡»æ˜¯ http(s)://t.me/ å¼€å¤´
        if link.startswith('http://t.me/'):
            tail = link.replace('http://t.me/', '').split('?')[0]
        elif link.startswith('https://t.me/'):
            tail = link.replace('https://t.me/', '').split('?')[0]
        else:
            return {'success': False, 'message': 'é“¾æ¥æ ¼å¼ä¸æ­£ç¡®ï¼Œè¯·ä½¿ç”¨ http://t.me/ å¼€å¤´çš„é“¾æ¥', 'admin_checked': False}
        
        # 1) ç§æœ‰é‚€è¯·é“¾æ¥: +hash æˆ– joinchat/hash -> æ— æ³•ç”¨ Bot æ£€æµ‹ç®¡ç†å‘˜ï¼Œåªèƒ½è®°å½•
        if tail.startswith('+') or tail.startswith('joinchat/'):
            return {
                'success': True,
                'message': 'ç§æœ‰é‚€è¯·é“¾æ¥å·²è®°å½•ï¼ŒTelegram é™åˆ¶æ— æ³•è‡ªåŠ¨æ£€æµ‹ç®¡ç†å‘˜ï¼Œè¯·ç¡®ä¿æœºå™¨äººå·²åœ¨ç¾¤ä¸”ä¸ºç®¡ç†å‘˜',
                'admin_checked': False
            }
        
        # 2) æ™®é€šå…¬å¼€ç¾¤ç”¨æˆ·åï¼šå¯ä»¥æ£€æµ‹æ˜¯å¦ä¸ºç®¡ç†å‘˜
        username = tail
        try:
            # å°è¯•è·å–å®ä½“
            entity = await bot.get_entity(username)
        except Exception as e:
            print(f'è·å–å®ä½“å¤±è´¥: {e}')
            return {'success': False, 'message': 'æ— æ³•è®¿é—®è¯¥ç¾¤ï¼Œå¯èƒ½æ˜¯ç§æœ‰ç¾¤ or é“¾æ¥æ— æ•ˆ', 'admin_checked': False}
        
        # æ£€æŸ¥æ˜¯å¦æ˜¯ç¾¤ç»„æˆ–è¶…çº§ç¾¤
        if not hasattr(entity, 'broadcast') or entity.broadcast:
            return {'success': False, 'message': 'è¿™ä¸æ˜¯ä¸€ä¸ªç¾¤ç»„é“¾æ¥', 'admin_checked': False}
            
        # è·å–æœºå™¨äººåœ¨ç¾¤å†…çš„æƒé™
        try:
            me = await bot.get_me()
            participant = await bot(GetParticipantRequest(
                channel=entity,
                participant=me.id
            ))
            
            # æ£€æŸ¥æ˜¯å¦ä¸ºç®¡ç†å‘˜
            from telethon.tl.types import (
                ChatParticipantAdmin,
                ChatParticipantCreator,
                ChannelParticipantAdmin,
                ChannelParticipantCreator
            )
            
            is_admin = isinstance(participant.participant, (
                ChatParticipantAdmin,
                ChatParticipantCreator,
                ChannelParticipantAdmin,
                ChannelParticipantCreator
            ))
            
            if not is_admin:
                return {'success': False, 'message': 'æœºå™¨äººä¸æ˜¯ç¾¤ç®¡ç†å‘˜', 'admin_checked': True}
            
            return {'success': True, 'message': 'éªŒè¯æˆåŠŸ', 'admin_checked': True}
        
        except Exception as e:
            print(f'è·å–æƒé™å¤±è´¥: {e}')
            return {'success': False, 'message': 'æœºå™¨äººä¸åœ¨è¯¥ç¾¤å†…æˆ–æ— æ³•è·å–æƒé™', 'admin_checked': True}
            
    except Exception as e:
        print(f'éªŒè¯ç¾¤é“¾æ¥å¤±è´¥: {e}')
        return {'success': False, 'message': f'éªŒè¯å¤±è´¥: {str(e)}', 'admin_checked': False}


async def check_user_in_group(bot, user_id, group_link):
    """
    æ£€æµ‹ç”¨æˆ·æ˜¯å¦åœ¨æŒ‡å®šç¾¤ç»„ä¸­
    
    Args:
        bot: Telegramæœºå™¨äººå®¢æˆ·ç«¯
        user_id: ç”¨æˆ·Telegram ID
        group_link: ç¾¤ç»„é“¾æ¥
    
    Returns:
        bool: Trueè¡¨ç¤ºç”¨æˆ·åœ¨ç¾¤ç»„ä¸­
    """
    try:
        # ä»ç¾¤é“¾æ¥æå–ç¾¤ç»„
        if 'joinchat/' in group_link or 't.me/' in group_link:
            group_entity = await bot.get_entity(group_link)
        else:
            return False
        
        # æ£€æŸ¥ç”¨æˆ·æ˜¯å¦åœ¨ç¾¤ç»„ä¸­
        try:
            participant = await bot(GetParticipantRequest(group_entity, user_id))
            return True
        except:
            return False
    except Exception as e:
        print(f"æ£€æµ‹ç”¨æˆ·æ˜¯å¦åœ¨ç¾¤å¤±è´¥: {e}")
        return False


async def check_bot_is_admin(bot, bot_id, group_link):
    """
    æ£€æµ‹æœºå™¨äººæ˜¯å¦ä¸ºç¾¤ç»„ç®¡ç†å‘˜
    
    Args:
        bot: Telegramæœºå™¨äººå®¢æˆ·ç«¯
        bot_id: æœºå™¨äººçš„Telegram ID
        group_link: ç¾¤ç»„é“¾æ¥
    
    Returns:
        bool: Trueè¡¨ç¤ºæœºå™¨äººæ˜¯ç®¡ç†å‘˜
    """
    try:
        group_entity = await bot.get_entity(group_link)
        
        # è·å–æœºå™¨äººåœ¨ç¾¤ç»„ä¸­çš„èº«ä»½
        participant = await bot(GetParticipantRequest(group_entity, bot_id))
        
        # æ£€æŸ¥æ˜¯å¦ä¸ºç®¡ç†å‘˜æˆ–åˆ›å»ºè€…
        if isinstance(participant.participant, (ChannelParticipantAdmin, ChannelParticipantCreator)):
            return True
        return False
    except Exception as e:
        print(f"æ£€æµ‹æœºå™¨äººç®¡ç†å‘˜æƒé™å¤±è´¥: {e}")
        return False


def get_upline_chain(telegram_id, max_level=10):
    """
    è·å–ç”¨æˆ·çš„ä¸Šçº§é“¾ï¼ˆå‘ä¸ŠNå±‚ï¼‰ï¼Œå¦‚æœä¸Šçº§ä¸è¶³ï¼Œè‡ªåŠ¨ç”¨æ¡æ¼è´¦å·è¡¥é½
    
    Args:
        telegram_id: ç”¨æˆ·Telegram ID
        max_level: æœ€å¤§å±‚çº§æ•°
    
    Returns:
        list: ä¸Šçº§é“¾åˆ—è¡¨ï¼Œæ ¼å¼: [{'level': å±‚çº§, 'id': telegram_id, 'is_fallback': bool}, ...]
    """
    import sys
    import os
    sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
    from app.config import DB_PATH
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    
    upline_chain = []  # æ ¼å¼: [{'level': å±‚çº§, 'id': telegram_id, 'is_fallback': bool}]
    current_id = telegram_id
    
    # 1. å…ˆæ‰¾çœŸå®çš„æ¨èäººé“¾æ¡
    for level in range(1, max_level + 1):
        c.execute('SELECT referrer_id FROM members WHERE telegram_id = ?', (current_id,))
        row = c.fetchone()
        
        if row and row[0]:
            # æ‰¾åˆ°çœŸå®ä¸Šçº§
            upline_chain.append({'level': level, 'id': row[0], 'is_fallback': False})
            current_id = row[0]
        else:
            # æ²¡æœ‰ä¸Šçº§äº†ï¼Œåœæ­¢æŸ¥æ‰¾çœŸå®ä¸Šçº§
            break
    
    # 2. å¦‚æœå±‚æ•°ä¸è¶³ï¼Œç”¨æ¡æ¼è´¦å·è¡¥é½
    current_chain_len = len(upline_chain)
    needed_count = max_level - current_chain_len
    
    if needed_count > 0:
        # è·å–æ‰€æœ‰æ¿€æ´»çš„æ¡æ¼è´¦å·ï¼ŒæŒ‰IDæ’åº
        c.execute('SELECT telegram_id FROM fallback_accounts WHERE is_active = 1 ORDER BY id ASC')
        fallback_rows = c.fetchall()
        # è¿‡æ»¤æ‰ None å€¼ï¼Œç¡®ä¿å…¨æ˜¯æœ‰æ•ˆçš„ ID
        fallback_ids = [r[0] for r in fallback_rows if r[0] is not None]
        
        if fallback_ids:
            # ä»ä¸‹ä¸€å±‚å¼€å§‹è¡¥
            start_level = current_chain_len + 1
            for i in range(needed_count):
                current_level = start_level + i
                # å¾ªç¯ä½¿ç”¨æ¡æ¼è´¦å·: ç¬¬1ä¸ªè¡¥ä½ç”¨ç¬¬1ä¸ªè´¦å·ï¼Œç¬¬2ä¸ªç”¨ç¬¬2ä¸ª...
                # ä½¿ç”¨å–ä½™ç®—æ³•å®ç°å¾ªç¯åˆ†é…
                fb_id = fallback_ids[i % len(fallback_ids)]
                
                upline_chain.append({
                    'level': current_level, 
                    'id': fb_id, 
                    'is_fallback': True
                })
        else:
            print(f'[get_upline_chain] è­¦å‘Š: æ•°æ®åº“ä¸­æ²¡æœ‰æ¿€æ´»çš„æ¡æ¼è´¦å·ï¼Œæ— æ³•è¡¥è¶³ {needed_count} å±‚')
    
    conn.close()
    return upline_chain


def get_downline_tree(telegram_id, max_level=10):
    """
    è·å–ç”¨æˆ·çš„ä¸‹çº§æ ‘ï¼ˆå‘ä¸‹Nå±‚ï¼‰
    
    Args:
        telegram_id: ç”¨æˆ·Telegram ID
        max_level: æœ€å¤§å±‚çº§æ•°
    
    Returns:
        dict: ä¸‹çº§æ ‘ç»“æ„ {å±‚çº§: [ç”¨æˆ·åˆ—è¡¨]}
    """
    import sys
    import os
    sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
    from app.config import DB_PATH
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    
    downline_tree = {}
    current_level_ids = [telegram_id]
    
    for level in range(1, max_level + 1):
        if not current_level_ids:
            break
        
        # æŸ¥è¯¢å½“å‰å±‚çº§æ‰€æœ‰ç”¨æˆ·çš„ç›´æ¨ä¸‹çº§
        placeholders = ','.join(['?'] * len(current_level_ids))
        c.execute(f'''
            SELECT telegram_id, username, is_vip, register_time
            FROM members
            WHERE referrer_id IN ({placeholders})
        ''', current_level_ids)
        
        downlines = c.fetchall()
        if downlines:
            downline_tree[level] = [
                {
                    'telegram_id': row[0],
                    'username': row[1],
                    'is_vip': row[2],
                    'register_time': row[3]
                }
                for row in downlines
            ]
            # å‡†å¤‡ä¸‹ä¸€å±‚çš„æŸ¥è¯¢
            current_level_ids = [row[0] for row in downlines]
        else:
            break
    
    conn.close()
    return downline_tree


def calculate_team_stats(telegram_id, max_level=10):
    """
    è®¡ç®—å›¢é˜Ÿç»Ÿè®¡æ•°æ®
    
    Args:
        telegram_id: ç”¨æˆ·Telegram ID
        max_level: æœ€å¤§å±‚çº§æ•°
    
    Returns:
        dict: {'direct_count': ç›´æ¨äººæ•°, 'team_count': å›¢é˜Ÿæ€»äººæ•°, 'vip_count': VIPäººæ•°}
    """
    import sys
    import os
    sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
    from app.config import DB_PATH
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    
    # ç›´æ¨äººæ•°
    c.execute('SELECT COUNT(*) FROM members WHERE referrer_id = ?', (telegram_id,))
    direct_count = c.fetchone()[0]
    
    # å›¢é˜Ÿæ€»äººæ•°ï¼ˆé€’å½’æŸ¥è¯¢æ‰€æœ‰ä¸‹çº§ï¼‰
    team_count = 0
    vip_count = 0
    
    downline_tree = get_downline_tree(telegram_id, max_level)
    for level_users in downline_tree.values():
        team_count += len(level_users)
        vip_count += sum(1 for u in level_users if u['is_vip'])
    
    conn.close()
    return {
        'direct_count': direct_count,
        'team_count': team_count,
        'vip_count': vip_count
    }


async def check_user_conditions(bot, telegram_id):
    """
    æ£€æŸ¥ç”¨æˆ·æ˜¯å¦æ»¡è¶³æ‰€æœ‰æ¡ä»¶
    
    Returns:
        dict: {
            'is_vip': bool,
            'is_group_bound': bool,
            'is_bot_admin': bool,
            'is_joined_upline': bool,
            'missing_conditions': []  # æœªæ»¡è¶³çš„æ¡ä»¶åˆ—è¡¨
        }
    """
    import sys
    import os
    sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
    from app.config import DB_PATH
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    
    c.execute('''
        SELECT is_vip, is_group_bound, is_bot_admin, is_joined_upline, group_link
        FROM members WHERE telegram_id = ?
    ''', (telegram_id,))
    row = c.fetchone()
    conn.close()
    
    if not row:
        return None
    
    is_vip, is_group_bound, is_bot_admin, is_joined_upline, group_link = row
    
    missing_conditions = []
    if not is_vip:
        missing_conditions.append('æœªå¼€é€šVIP')
    if not is_group_bound:
        missing_conditions.append('æœªç»‘å®šç¾¤ç»„')
    if not is_bot_admin:
        missing_conditions.append('æœªè®¾ç½®æœºå™¨äººä¸ºç®¡ç†å‘˜')
    if not is_joined_upline:
        missing_conditions.append('æœªåŠ å…¥ä¸Šå±‚æ‰€æœ‰ç¾¤ç»„')
    
    return {
        'is_vip': bool(is_vip),
        'is_group_bound': bool(is_group_bound),
        'is_bot_admin': bool(is_bot_admin),
        'is_joined_upline': bool(is_joined_upline),
        'group_link': group_link or '',
        'missing_conditions': missing_conditions,
        'all_conditions_met': len(missing_conditions) == 0
    }


def update_level_path(telegram_id):
    """
    æ›´æ–°ç”¨æˆ·çš„å±‚çº§è·¯å¾„
    
    Args:
        telegram_id: ç”¨æˆ·Telegram ID
    """
    import sys
    import os
    sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
    from app.config import DB_PATH
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    
    # è·å–ä¸Šçº§é“¾
    path = []
    current_id = telegram_id
    
    for _ in range(20):  # æœ€å¤š20å±‚
        c.execute('SELECT referrer_id FROM members WHERE telegram_id = ?', (current_id,))
        row = c.fetchone()
        if not row or not row[0]:
            break
        path.insert(0, str(row[0]))
        current_id = row[0]
    
    level_path = ','.join(path) if path else ''
    
    # æ›´æ–°level_pathå­—æ®µ
    c.execute('UPDATE members SET level_path = ? WHERE telegram_id = ?', (level_path, telegram_id))
    conn.commit()
    conn.close()


def get_fallback_account(level):
    """
    è·å–æŒ‡å®šå±‚çº§çš„æ¡æ¼è´¦å·

    Args:
        level: å±‚çº§æ•° (1-10)

    Returns:
        int: æ¡æ¼è´¦å·çš„telegram_id
    """
    import sys
    import os
    sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
    from app.config import DB_PATH
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()

    # æŒ‰é¡ºåºè·å–æ¡æ¼è´¦å·
    c.execute('SELECT telegram_id FROM fallback_accounts WHERE is_active = 1 ORDER BY id LIMIT 1 OFFSET ?',
             (level - 1,))
    row = c.fetchone()
    conn.close()

    return row[0] if row else None


# ã€æ–°å¢ã€‘ç”ŸæˆVIPå¼€é€šæˆåŠŸåçš„è¯¦ç»†æ–‡æ¡ˆ
def generate_vip_success_message(telegram_id, amount, vip_price, current_balance):
    """ç”Ÿæˆç¬¦åˆè¦æ±‚çš„VIPå¼€é€šæ–‡æ¡ˆ"""
    try:
        from app.config import DB_PATH
        conn = sqlite3.connect(DB_PATH)
        c = conn.cursor()

        # è·å–ç³»ç»Ÿé…ç½®çš„å±‚æ•°
        c.execute("SELECT value FROM system_config WHERE key = 'level_count'")
        row = c.fetchone()
        level_count = int(row[0]) if row else 10
        conn.close()

        # è·å–ä¸Šçº§ç¾¤åˆ—è¡¨
        upline_chain = get_upline_chain(telegram_id, level_count)
        upline_groups_text = ""
        group_count = 0

        # å†æ¬¡è¿æ¥è·å–ä¸Šçº§è¯¦ç»†ä¿¡æ¯
        conn = sqlite3.connect(DB_PATH)
        c = conn.cursor()

        for item in upline_chain:
            if item.get('is_fallback'): continue # è·³è¿‡æ¡æ¼è´¦å·çš„ç¾¤

            uid = item['id']
            lvl = item['level']
            c.execute("SELECT username, group_link FROM members WHERE telegram_id = ?", (uid,))
            u_row = c.fetchone()

            if u_row and u_row[1]: # æœ‰ç¾¤é“¾æ¥
                # ç®€å•å¤„ç†ç¾¤å
                g_link = u_row[1]
                u_name = u_row[0] or f"ç”¨æˆ·{uid}"
                upline_groups_text += f"{lvl}. @{u_name}çš„ç¾¤\n"
                group_count += 1

        conn.close()

        msg = (
            f"ğŸ‰ å……å€¼æˆåŠŸï¼VIPå·²å¼€é€šï¼\n\n"
            f"ğŸ’° å……å€¼é‡‘é¢: {amount} U\n"
            f"ğŸ’ VIPè´¹ç”¨: {vip_price} U\n"
            f"ğŸ’µ å½“å‰ä½™é¢: {current_balance} U\n\n"
            f"âš ï¸ é‡è¦ï¼šè¯·ç«‹å³å®Œæˆä»¥ä¸‹æ“ä½œ\n\n"
            f"1ï¸âƒ£ ç»‘å®šæ‚¨çš„ç¾¤ç»„\n"
            f"2ï¸âƒ£ åŠ å…¥ä¸Šå±‚ç¾¤ç»„ï¼ˆå…±{group_count}ä¸ªï¼‰\n"
            f"{upline_groups_text}\n"
            f"å®Œæˆä»¥ä¸Šæ“ä½œåï¼Œæ‚¨çš„ä¸‹çº§å¼€é€šVIPæ—¶\n"
            f"æ‚¨æ‰èƒ½è·å¾—åˆ†çº¢ï¼"
        )
        return msg
    except Exception as e:
        print(f"[ç”Ÿæˆæ–‡æ¡ˆé”™è¯¯] {e}")
        return f"ğŸ‰ VIPå¼€é€šæˆåŠŸï¼\nèŠ±è´¹: {vip_price}U\nä½™é¢: {current_balance}U"


async def distribute_vip_rewards(bot, telegram_id, pay_amount, config):
    """
    ç»Ÿä¸€å¤„ç†VIPå¼€é€šåçš„åˆ†çº¢é€»è¾‘ï¼ˆç»ˆæä¿®å¤ç‰ˆï¼šå…¨é“¾è·¯å»é‡ + è¯¦ç»†è¯´æ˜è®°å½•ï¼‰
    """
    import sys
    import os
    sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
    from app.config import DB_PATH

    level_count = int(config.get('level_count', 10))
    reward_amount = float(config.get('level_reward', 1))

    chain = get_upline_chain(telegram_id, level_count)

    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    c.execute('SELECT username FROM members WHERE telegram_id = ?', (telegram_id,))
    user_row = c.fetchone()
    source_username = user_row[0] if user_row else str(telegram_id)
    conn.close()

    reward_stats = {'real': 0, 'fallback': 0}

    # è®°å½•æœ¬è½®å·²è·å¾—å¥–åŠ±çš„è´¦å·IDï¼ˆåŒ…æ‹¬çœŸå®ç”¨æˆ·å’Œæ¡æ¼è´¦å·ï¼‰
    used_ids_in_this_round = set()

    # é¢„å…ˆåŠ è½½æ‰€æœ‰æ´»è·ƒæ¡æ¼è´¦å·ï¼ˆæŒ‰IDæ’åºï¼‰
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    c.execute('SELECT telegram_id FROM fallback_accounts WHERE is_active = 1 ORDER BY id ASC')
    all_fb_rows = c.fetchall()
    all_valid_fbs = [r[0] for r in all_fb_rows if r[0] is not None]
    conn.close()

    for item in chain:
        level = item['level']
        upline_id = item['id']
        is_fallback_in_chain = item['is_fallback']

        if not upline_id or str(upline_id) == 'None': continue

        conn = sqlite3.connect(DB_PATH, timeout=10)
        c = conn.cursor()

        try:
            target_id_to_reward = None
            is_rewarding_fallback = False

            # ã€å…³é”®ä¿®æ”¹ã€‘ç”¨äºå­˜å‚¨å…·ä½“çš„å¤±è´¥åŸå› æè¿°
            record_description = ""
            # --- æ­¥éª¤Aï¼šç¡®å®šè¿™ä¸€å±‚çš„åŸå§‹æ¥æ”¶è€… ---
            if is_fallback_in_chain:
                # é“¾æ¡æœ¬èº«å°±æ˜¯æ¡æ¼è´¦å·ï¼ˆè¯´æ˜è¿™ä¸€å±‚æ²¡æœ‰çœŸå®ä¸Šçº§ï¼‰
                candidate_id = upline_id
                is_rewarding_fallback = True
                record_description = f"ç¬¬{level}å±‚æ— ä¸Šçº§ï¼ˆè‡ªåŠ¨æ¡æ¼ï¼‰"
            else:
                # çœŸå®ç”¨æˆ·ï¼Œæ£€æŸ¥æ¡ä»¶
                c.execute('SELECT username, is_vip, is_group_bound, is_bot_admin, is_joined_upline FROM members WHERE telegram_id = ?', (upline_id,))
                row = c.fetchone()

                # è·å–ä¸Šçº§æ˜¾ç¤ºåç§°
                upline_name = str(upline_id)
                if row and row[0]:
                    upline_name = f"@{row[0]}"

                if row and row[1] and row[2] and row[3] and row[4]:
                    # çœŸå®ç”¨æˆ·è¾¾æ ‡
                    candidate_id = upline_id
                    is_rewarding_fallback = False
                    record_description = f"ç¬¬{level}å±‚ä¸‹çº§å¼€é€šVIP"
                else:
                    # çœŸå®ç”¨æˆ·ä¸è¾¾æ ‡
                    candidate_id = None
                    is_rewarding_fallback = True

                    # ã€å…³é”®ä¿®æ”¹ã€‘æ„å»ºè¯¦ç»†çš„å¤±è´¥åŸå› 
                    fail_reasons = []
                    if not row:
                        fail_reasons.append("ç”¨æˆ·ä¸å­˜åœ¨")
                    else:
                        if not row[1]: fail_reasons.append("æœªVIP")
                        if not row[2]: fail_reasons.append("æœªç»‘ç¾¤")
                        if not row[3]: fail_reasons.append("æœªè®¾ç½®ç¾¤ç®¡")
                        if not row[4]: fail_reasons.append("æœªåŠ ç¾¤")

                    reason_str = ",".join(fail_reasons)
                    # è¿™é‡Œçš„æ ¼å¼å°±æ˜¯æ‚¨æƒ³è¦çš„ï¼šæ˜¾ç¤ºå…·ä½“å“ªä¸ªä¸Šçº§æ²¡å®Œæˆ
                    record_description = f"ä¸Šçº§ {upline_name} {reason_str}ï¼ˆè½¬å…¥æ¡æ¼ï¼‰"
                    # è®°å½•é”™è¿‡æ”¶ç›Šé€šçŸ¥
                    if row:
                        c.execute('UPDATE members SET missed_balance = missed_balance + ? WHERE telegram_id = ?',
                                 (reward_amount, upline_id))
                        # å‘é€é€šçŸ¥ç»™é‚£ä¸ªä¸äº‰æ°”çš„ä¸Šçº§
                        try:
                            await bot.send_message(
                                upline_id,
                                f"ğŸ’¸ **é”™å¤±æ”¶ç›Šé€šçŸ¥**\n\n"
                                f"æ‚¨é”™è¿‡äº† {reward_amount} U çš„æ”¶ç›Šï¼\n"
                                f"åŸå› : {reason_str}\n"
                                f"æ¥æº: ä¸‹çº§ @{source_username} (ç¬¬{level}å±‚) å¼€é€šVIP\n\n"
                                f"è¯·å°½å¿«å®Œæˆä»»åŠ¡ï¼Œä»¥å…å†æ¬¡é”™è¿‡ï¼"
                            )
                        except: pass

            # --- æ­¥éª¤Bï¼šå¦‚æœéœ€è¦æ¡æ¼ï¼Œå¯»æ‰¾æ›¿è¡¥ ---
            if is_rewarding_fallback:
                start_index = (level - 1) % len(all_valid_fbs) if all_valid_fbs else 0
                found_fb = None

                # ä¼˜å…ˆæ£€æŸ¥ chain è‡ªå¸¦çš„é‚£ä¸ªæ¡æ¼å·
                if candidate_id and candidate_id in all_valid_fbs and candidate_id not in used_ids_in_this_round:
                    found_fb = candidate_id
                else:
                    # è½®è¯¢æŸ¥æ‰¾
                    if all_valid_fbs:
                        for i in range(len(all_valid_fbs)):
                            idx = (start_index + i) % len(all_valid_fbs)
                            fb_candidate = all_valid_fbs[idx]
                            if fb_candidate not in used_ids_in_this_round:
                                found_fb = fb_candidate
                                break
                        if found_fb is None: found_fb = all_valid_fbs[start_index]

                target_id_to_reward = found_fb
            else:
                target_id_to_reward = candidate_id

            # --- æ­¥éª¤Cï¼šæ‰§è¡Œå‘æ”¾ ---
            if target_id_to_reward:
                # ç¡®ä¿è´¦å·å­˜åœ¨
                if is_rewarding_fallback:
                    c.execute('SELECT id FROM members WHERE telegram_id = ?', (target_id_to_reward,))
                    if not c.fetchone():
                        c.execute('SELECT username FROM fallback_accounts WHERE telegram_id = ?', (target_id_to_reward,))
                        fb_name = c.fetchone()
                        name = fb_name[0] if fb_name else f'fallback_{target_id_to_reward}'
                        c.execute('INSERT OR IGNORE INTO members (telegram_id, username, is_vip, register_time) VALUES (?, ?, 1, ?)',
                                 (target_id_to_reward, name, get_cn_time()))

                    c.execute('UPDATE fallback_accounts SET total_earned = total_earned + ? WHERE telegram_id = ?',
                             (reward_amount, target_id_to_reward))
                    reward_stats['fallback'] += 1
                else:
                    reward_stats['real'] += 1

                used_ids_in_this_round.add(int(target_id_to_reward))

                # æ›´æ–°ä½™é¢
                c.execute('UPDATE members SET balance = balance + ?, total_earned = total_earned + ? WHERE telegram_id = ?',
                         (reward_amount, reward_amount, target_id_to_reward))

                # ã€å…³é”®ä¿®æ”¹ã€‘å†™å…¥æ•°æ®åº“æ—¶ä½¿ç”¨ä¸Šé¢æ„å»ºå¥½çš„è¯¦ç»†è¯´æ˜
                c.execute('''INSERT INTO earnings_records (upgraded_user, earning_user, amount, description, create_time)
                           VALUES (?, ?, ?, ?, ?)''',
                           (telegram_id, target_id_to_reward, reward_amount, record_description, get_cn_time()))

                # é€šçŸ¥
                if not is_rewarding_fallback:
                    try:
                        await bot.send_message(target_id_to_reward,
                            f'ğŸ‰ è·å¾— {reward_amount} U å¥–åŠ±\næ¥æºï¼šç¬¬ {level} å±‚ä¸‹çº§ @{source_username} å¼€é€šVIP')
                    except: pass

            conn.commit()
        except Exception as e:
            print(f"[åˆ†çº¢åˆ†é…é”™è¯¯] Level {level}: {e}")
        finally:
            conn.close()

    return reward_stats
-e 

--- File: ./app/database.py ---
"""
æ•°æ®åº“å±‚ - ç»Ÿä¸€ç®¡ç†æ‰€æœ‰æ•°æ®åº“æ“ä½œ
"""
import sqlite3
import time
import os
import sys
from datetime import datetime, timedelta, timezone
from werkzeug.security import generate_password_hash
from flask_login import UserMixin

# å…¼å®¹ä¸åŒå¯¼å…¥æ–¹å¼
try:
    # ä¼˜å…ˆå°è¯•ä» app.config å¯¼å…¥ï¼ˆå½“ä½œä¸ºæ¨¡å—å¯¼å…¥æ—¶ï¼‰
    from app.config import DB_PATH
except ImportError:
    try:
        # å°è¯•ä» config å¯¼å…¥ï¼ˆå½“åœ¨ app ç›®å½•ä¸‹ç›´æ¥è¿è¡Œæ—¶ï¼‰
        from config import DB_PATH
    except ImportError:
        # å¦‚æœéƒ½å¤±è´¥ï¼Œä½¿ç”¨ç›¸å¯¹è·¯å¾„è®¡ç®—
        BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
        DATA_DIR = os.path.join(BASE_DIR, 'data')
        DB_PATH = os.path.join(DATA_DIR, 'bot.db')

# å®šä¹‰ä¸­å›½æ—¶åŒº
CN_TIMEZONE = timezone(timedelta(hours=8))

def get_cn_time():
    """è·å–ä¸­å›½æ—¶é—´å­—ç¬¦ä¸²"""
    return datetime.now(CN_TIMEZONE).isoformat()

def get_db_conn():
    """è·å–æ•°æ®åº“è¿æ¥ï¼Œè®¾ç½®è¶…æ—¶å’Œ WAL æ¨¡å¼ä»¥é¿å…é”å®š"""
    conn = sqlite3.connect(DB_PATH, timeout=10.0)
    conn.execute('PRAGMA journal_mode=WAL')
    conn.execute('PRAGMA busy_timeout=10000')
    return conn

def init_db():
    """åˆå§‹åŒ–æ•°æ®åº“è¡¨ç»“æ„"""
    conn = get_db_conn()
    c = conn.cursor()
    
    # ä¼šå‘˜è¡¨
    c.execute('''CREATE TABLE IF NOT EXISTS members (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        telegram_id INTEGER UNIQUE,
        username TEXT,
        backup_account TEXT,
        referrer_id INTEGER,
        balance REAL DEFAULT 0,
        missed_balance REAL DEFAULT 0,
        group_link TEXT,
        is_vip INTEGER DEFAULT 0,
        register_time TEXT,
        vip_time TEXT,
        is_group_bound INTEGER DEFAULT 0,
        is_bot_admin INTEGER DEFAULT 0,
        is_joined_upline INTEGER DEFAULT 0,
        level_path TEXT,
        direct_count INTEGER DEFAULT 0,
        team_count INTEGER DEFAULT 0,
        total_earned REAL DEFAULT 0,
        withdraw_address TEXT,
        FOREIGN KEY (referrer_id) REFERENCES members(telegram_id)
    )''')
    
    # å®¢æœè¡¨
    c.execute('''CREATE TABLE IF NOT EXISTS customer_service (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        name TEXT,
        link TEXT
    )''')
    
    # è¡Œä¸šèµ„æºåˆ†ç±»è¡¨
    c.execute('''CREATE TABLE IF NOT EXISTS resource_categories (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        name TEXT,
        parent_id INTEGER DEFAULT 0
    )''')
    
    # è¡Œä¸šèµ„æºè¡¨
    c.execute('''CREATE TABLE IF NOT EXISTS resources (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        category_id INTEGER,
        name TEXT,
        link TEXT,
        type TEXT,
        member_count INTEGER DEFAULT 0,
        FOREIGN KEY (category_id) REFERENCES resource_categories(id)
    )''')
    
    # æç°è®°å½•è¡¨
    c.execute('''CREATE TABLE IF NOT EXISTS withdrawals (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        member_id INTEGER,
        amount REAL,
        usdt_address TEXT,
        status TEXT DEFAULT 'pending',
        create_time TEXT,
        process_time TEXT,
        FOREIGN KEY (member_id) REFERENCES members(telegram_id)
    )''')
    
    # ç³»ç»Ÿé…ç½®è¡¨
    c.execute('''CREATE TABLE IF NOT EXISTS system_config (
        key TEXT PRIMARY KEY,
        value TEXT
    )''')

    # ç®¡ç†å‘˜è¡¨
    c.execute('''CREATE TABLE IF NOT EXISTS admin_users (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        username TEXT UNIQUE,
        password_hash TEXT
    )''')
    
    # æ”¶ç›Šè®°å½•è¡¨ï¼ˆè®°å½•è°è§¦å‘å‡çº§ã€å“ªä¸ªç”¨æˆ·è·å¾—æ”¶ç›Šã€é‡‘é¢ã€è¯´æ˜ã€æ—¶é—´ï¼‰
    c.execute('''CREATE TABLE IF NOT EXISTS earnings_records (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        upgraded_user INTEGER,     -- å‡çº§çš„å‘èµ·è€…ï¼ˆè°å¼€é€š/å‡çº§é€ æˆåˆ†çº¢ï¼‰
        earning_user INTEGER,      -- è·å¾—æ”¶ç›Šçš„ç”¨æˆ·ï¼ˆæ”¶åˆ°åˆ†çº¢çš„è´¦æˆ·ï¼‰
        amount REAL,
        description TEXT,
        create_time TEXT,
        FOREIGN KEY (earning_user) REFERENCES members(telegram_id)
    )''')
    
    # å……å€¼è®°å½•è¡¨
    c.execute('''CREATE TABLE IF NOT EXISTS recharge_records (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        member_id INTEGER,
        amount REAL,
        order_id TEXT,
        status TEXT,
        payment_method TEXT,
        create_time TEXT,
        FOREIGN KEY (member_id) REFERENCES members(telegram_id)
    )''')
    
    # æ¡æ¼è´¦å·è¡¨
    c.execute('''CREATE TABLE IF NOT EXISTS fallback_accounts (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        telegram_id INTEGER UNIQUE,
        username TEXT,
        group_link TEXT,
        total_earned REAL DEFAULT 0,
        is_active INTEGER DEFAULT 1,
        main_account_id INTEGER
    )''')

    # ç¾¤å‘é˜Ÿåˆ—è¡¨
    c.execute('''CREATE TABLE IF NOT EXISTS broadcast_queue (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        group_link TEXT,
        group_name TEXT,
        message TEXT,
        status TEXT DEFAULT 'pending',
        result TEXT,
        create_time TEXT
    )''')

    # ç¾¤å‘æ¶ˆæ¯è¡¨
    c.execute('''CREATE TABLE IF NOT EXISTS broadcast_messages (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        title TEXT,
        content TEXT,
        media_type TEXT,
        media_url TEXT,
        image_url TEXT,
        video_url TEXT,
        buttons TEXT,
        buttons_per_row INTEGER DEFAULT 2,
        schedule_enabled INTEGER DEFAULT 0,
        schedule_time TEXT,
        is_active INTEGER DEFAULT 1,
        create_time TEXT
    )''')

    # ç¾¤å‘åˆ†é…è¡¨ï¼šè®°å½•å“ªäº›ç¾¤è¢«åˆ†é…äº†å“ªäº›ç¾¤å‘å†…å®¹ï¼Œä»¥åŠå¯ç”¨çŠ¶æ€å’Œæœ€åå‘é€æ—¶é—´
    c.execute('''CREATE TABLE IF NOT EXISTS broadcast_assignments (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        group_id INTEGER,
        message_id INTEGER,
        is_active INTEGER DEFAULT 1,
        create_time TEXT,
        last_sent_time TEXT,
        FOREIGN KEY (group_id) REFERENCES member_groups(id),
        FOREIGN KEY (message_id) REFERENCES broadcast_messages(id)
    )''')

    # ä¼šå‘˜ç¾¤ç»„è¡¨
    c.execute('''CREATE TABLE IF NOT EXISTS member_groups (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        telegram_id INTEGER,
        group_id INTEGER,
        group_name TEXT,
        group_link TEXT,
        member_count INTEGER DEFAULT 0,
        bot_id INTEGER,
        is_bot_admin INTEGER DEFAULT 0,
        owner_username TEXT,
        group_type TEXT DEFAULT 'group',
        schedule_broadcast INTEGER DEFAULT 1,
        create_time TEXT,
        FOREIGN KEY (telegram_id) REFERENCES members(telegram_id)
    )''')
    
    # ç¾¤å‘æ—¥å¿—è¡¨
    c.execute('''CREATE TABLE IF NOT EXISTS broadcast_logs (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        message_id INTEGER,
        group_ids TEXT,
        status TEXT DEFAULT 'pending',
        sent_count INTEGER DEFAULT 0,
        failed_count INTEGER DEFAULT 0,
        create_time TEXT
    )''')
    
    # å¹¿å‘Šè¡¨
    c.execute('''CREATE TABLE IF NOT EXISTS advertisements (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        title TEXT,
        content TEXT,
        position TEXT DEFAULT 'top',
        is_active INTEGER DEFAULT 1,
        create_time TEXT
    )''')
    
    # æ¬¢è¿è¯­è¡¨
    c.execute('''CREATE TABLE IF NOT EXISTS welcome_messages (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        group_id TEXT,
        message TEXT,
        is_active INTEGER DEFAULT 1,
        create_time TEXT
    )''')
    
    # æœºå™¨äººé…ç½®è¡¨
    c.execute('''CREATE TABLE IF NOT EXISTS bot_configs (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        bot_token TEXT,
        bot_username TEXT,
        is_active INTEGER DEFAULT 1,
        api_id INTEGER,
        api_hash TEXT,
        create_time TEXT
    )''')

    # æ£€æŸ¥æ˜¯å¦æœ‰ç®¡ç†å‘˜ï¼Œå¦‚æœæ²¡æœ‰åˆ™åˆ›å»ºé»˜è®¤ç®¡ç†å‘˜
    c.execute('SELECT COUNT(*) FROM admin_users')
    if c.fetchone()[0] == 0:
        default_password_hash = generate_password_hash('admin')
        c.execute('INSERT INTO admin_users (username, password_hash) VALUES (?, ?)', ('admin', default_password_hash))
        print('âš ï¸ åˆ›å»ºé»˜è®¤ç®¡ç†å‘˜è´¦å·: admin / admin')
    
    conn.commit()
    conn.close()

# æ•°æ®åº“æ“ä½œç±»
class DB:
    @staticmethod
    def get_conn():
        """è·å–æ•°æ®åº“è¿æ¥"""
        return get_db_conn()
    
    @staticmethod
    def get_member(telegram_id):
        """è·å–ä¼šå‘˜ä¿¡æ¯"""
        conn = DB.get_conn()
        c = conn.cursor()
        c.execute('''
            SELECT 
                id, telegram_id, username, backup_account, referrer_id,
                balance, missed_balance, group_link, is_vip, register_time, vip_time,
                is_group_bound, is_bot_admin, is_joined_upline, level_path,
                direct_count, team_count, total_earned, withdraw_address
            FROM members WHERE telegram_id = ?
        ''', (telegram_id,))
        row = c.fetchone()
        conn.close()
        if row:
            return {
                'id': row[0], 'telegram_id': row[1], 'username': row[2],
                'backup_account': row[3], 'referrer_id': row[4], 'balance': row[5],
                'missed_balance': row[6], 'group_link': row[7], 'is_vip': row[8],
                'register_time': row[9], 'vip_time': row[10],
                'is_group_bound': row[11], 'is_bot_admin': row[12],
                'is_joined_upline': row[13], 'level_path': row[14],
                'direct_count': row[15], 'team_count': row[16],
                'total_earned': row[17], 'withdraw_address': row[18]
            }
        return None
    
    @staticmethod
    def create_member(telegram_id, username, referrer_id=None):
        """åˆ›å»ºä¼šå‘˜è®°å½•ï¼Œå¸¦é‡è¯•"""
        max_retries = 5
        for retry in range(max_retries):
            conn = DB.get_conn()
            c = conn.cursor()
            try:
                c.execute(
                    '''INSERT INTO members (telegram_id, username, referrer_id, register_time)
                        VALUES (?, ?, ?, ?)''',
                    (telegram_id, username, referrer_id, get_cn_time())
                )
                conn.commit()
                conn.close()
                return True
            except sqlite3.IntegrityError:
                conn.close()
                return True
            except sqlite3.OperationalError as e:
                conn.close()
                if 'locked' in str(e).lower() and retry < max_retries - 1:
                    time.sleep(0.2)
                    continue
                return False
            except Exception:
                conn.close()
                return False
        return False
    
    @staticmethod
    def update_member(telegram_id, **kwargs):
        """æ›´æ–°ä¼šå‘˜ä¿¡æ¯"""
        conn = DB.get_conn()
        c = conn.cursor()
        sets = ', '.join([f'{k} = ?' for k in kwargs.keys()])
        values = list(kwargs.values()) + [telegram_id]
        c.execute(f'UPDATE members SET {sets} WHERE telegram_id = ?', values)
        conn.commit()
        conn.close()
    
    @staticmethod
    def get_upline_members(telegram_id, levels=10):
        """è·å–ä¸ŠNå±‚æ¨èäººï¼ˆå·²åºŸå¼ƒï¼Œè¯·ä½¿ç”¨ core_functions.get_upline_chainï¼‰"""
        members = []
        conn = DB.get_conn()
        c = conn.cursor()
        current_id = telegram_id
        
        for _ in range(levels):
            c.execute('SELECT referrer_id FROM members WHERE telegram_id = ?', (current_id,))
            row = c.fetchone()
            if row and row[0]:
                c.execute('SELECT telegram_id, username, is_vip, balance FROM members WHERE telegram_id = ?', (row[0],))
                member_row = c.fetchone()
                if member_row:
                    members.append({
                        'telegram_id': member_row[0],
                        'username': member_row[1],
                        'is_vip': member_row[2],
                        'balance': member_row[3]
                    })
                    current_id = row[0]
                else:
                    break
            else:
                break
        conn.close()
        return members
    
    @staticmethod
    def get_downline_count(telegram_id, level=1):
        """è·å–ä¸‹Nå±‚ä¼šå‘˜æ•°é‡"""
        conn = DB.get_conn()
        c = conn.cursor()
        
        current_level_ids = [telegram_id]
        counts = []
        
        for _ in range(level):
            if not current_level_ids:
                counts.append({'total': 0, 'vip': 0})
                continue
            placeholders = ','.join(['?' for _ in current_level_ids])
            c.execute(f'SELECT telegram_id, is_vip FROM members WHERE referrer_id IN ({placeholders})', 
                     current_level_ids)
            rows = c.fetchall()
            counts.append({'total': len(rows), 'vip': sum(1 for r in rows if r[1])})
            current_level_ids = [r[0] for r in rows]
        
        conn.close()
        return counts

    @staticmethod
    def get_customer_services():
        """è·å–å®¢æœåˆ—è¡¨"""
        conn = DB.get_conn()
        c = conn.cursor()
        c.execute('SELECT * FROM customer_service')
        rows = c.fetchall()
        conn.close()
        return [{'id': r[0], 'name': r[1], 'link': r[2]} for r in rows]
    
    @staticmethod
    def get_resource_categories(parent_id=0):
        """è·å–èµ„æºåˆ†ç±»"""
        conn = DB.get_conn()
        c = conn.cursor()
        c.execute('SELECT * FROM resource_categories WHERE parent_id = ?', (parent_id,))
        rows = c.fetchall()
        conn.close()
        return [{'id': r[0], 'name': r[1]} for r in rows]
    
    @staticmethod
    def get_resources(category_id, page=1, per_page=20):
        """è·å–èµ„æºåˆ—è¡¨"""
        conn = DB.get_conn()
        c = conn.cursor()
        offset = (page - 1) * per_page
        c.execute('SELECT * FROM resources WHERE category_id = ? LIMIT ? OFFSET ?', 
                 (category_id, per_page, offset))
        rows = c.fetchall()
        c.execute('SELECT COUNT(*) FROM resources WHERE category_id = ?', (category_id,))
        total = c.fetchone()[0]
        conn.close()
        return {
            'items': [{'id': r[0], 'name': r[2], 'link': r[3], 'type': r[4], 'count': r[5]} for r in rows],
            'total': total,
            'pages': (total + per_page - 1) // per_page
        }

def get_system_config():
    """ä»æ•°æ®åº“åŠ¨æ€è¯»å–ç³»ç»Ÿé…ç½®"""
    conn = get_db_conn()
    c = conn.cursor()
    c.execute('SELECT key, value FROM system_config')
    config_rows = c.fetchall()
    
    # é»˜è®¤é…ç½®
    config = {
        'level_count': 10,
        'level_reward': 1,
        'vip_price': 10,
        'withdraw_threshold': 50,
        'support_text': 'ğŸ‘©â€ğŸ’¼ åœ¨çº¿å®¢æœ\n\næš‚æ— å®¢æœä¿¡æ¯ï¼Œè¯·è”ç³»ç®¡ç†å‘˜',
        'usdt_address': '',
        'pinned_ad': '',
        'welcome_message': '',
        'welcome_enabled': '1',
        'auto_register_enabled': '0',
        'level_amounts': [] # é»˜è®¤ä¸ºç©ºåˆ—è¡¨
    }
    
    key_mapping = {
        'levels': 'level_count',
        'reward_per_level': 'level_reward',
        'vip_price': 'vip_price',
        'withdraw_threshold': 'withdraw_threshold',
        'service_text': 'support_text',
        'usdt_address': 'usdt_address',
        'pinned_ad': 'pinned_ad',
        'welcome_message': 'welcome_message',
        'welcome_enabled': 'welcome_enabled',
        'level_amounts': 'level_amounts',
        'auto_register_enabled': 'auto_register_enabled',
        # æ·»åŠ æ—§é”®åæ˜ å°„
        'payment_url': 'payment_url',
        'payment_token': 'payment_token',
        'payment_rate': 'payment_rate',
        'payment_channel': 'payment_channel',
        'payment_user_id': 'payment_user_id'
    }
    
    for key, value in config_rows:
        # å¤„ç†æ˜ å°„é”®
        mapped_key = key_mapping.get(key, key)

        # æ•°å€¼ç±»å‹è½¬æ¢
        if mapped_key in ['level_count', 'withdraw_threshold']:
            try: config[mapped_key] = int(float(value))
            except: config[mapped_key] = 0
        elif mapped_key in ['level_reward', 'vip_price', 'payment_rate']:
            try: config[mapped_key] = float(value)
            except: config[mapped_key] = 0.0
        # ç‰¹æ®Šå¤„ç† level_amounts
        elif mapped_key == 'level_amounts':
                try:
                    import json
                parsed = json.loads(value)
                if isinstance(parsed, list):
                    config['level_amounts'] = parsed
                elif isinstance(parsed, dict):
                    # å…¼å®¹æ—§çš„å­—å…¸æ ¼å¼ï¼Œè½¬ä¸ºåˆ—è¡¨
                    max_k = 0
                    for k in parsed:
                        try:
                            if int(k) > max_k: max_k = int(k)
                        except: pass
                    lst = []
                    for i in range(1, max_k + 1):
                        lst.append(float(parsed.get(str(i)) or parsed.get(i) or 0))
                    config['level_amounts'] = lst
                except Exception:
                config['level_amounts'] = [] # è§£æå¤±è´¥å›é€€
            else:
            config[mapped_key] = value
    
    conn.close()
    return config

def update_system_config(key, value):
    """æ›´æ–°ç³»ç»Ÿé…ç½®åˆ°æ•°æ®åº“"""
    reverse_key_mapping = {
        'level_count': 'levels',
        'level_reward': 'reward_per_level',
        'vip_price': 'vip_price',
        'withdraw_threshold': 'withdraw_threshold',
        'support_text': 'service_text',
        'usdt_address': 'usdt_address'
    }
    
    db_key = reverse_key_mapping.get(key, key)
    
    conn = get_db_conn()
    c = conn.cursor()
    c.execute('''
        INSERT INTO system_config (key, value) 
        VALUES (?, ?)
        ON CONFLICT(key) DO UPDATE SET value=excluded.value
    ''', (db_key, str(value)))
    conn.commit()
    conn.close()

class AdminUser(UserMixin):
    """ç®¡ç†å‘˜ç”¨æˆ·ç±»"""
    def __init__(self, id, username, password_hash):
        self.id = id
        self.username = username
        self.password_hash = password_hash

# Webåå°æ•°æ®åº“æ“ä½œç±»ï¼ˆåˆå¹¶åçš„å®Œæ•´ç‰ˆæœ¬ï¼‰
class WebDB:
    """Webç®¡ç†åå°æ•°æ®åº“æ“ä½œ"""
    
    @staticmethod
    def get_user_by_username(username):
        """æ ¹æ®ç”¨æˆ·åè·å–ç”¨æˆ·"""
        conn = get_db_conn()
        c = conn.cursor()
        c.execute('SELECT id, username, password_hash FROM admin_users WHERE username = ?', (username,))
        row = c.fetchone()
        conn.close()
        if row:
            return AdminUser(row[0], row[1], row[2])
        return None
    
    @staticmethod
    def get_user_by_id(user_id):
        """æ ¹æ®IDè·å–ç”¨æˆ·"""
        conn = get_db_conn()
        c = conn.cursor()
        c.execute('SELECT id, username, password_hash FROM admin_users WHERE id = ?', (user_id,))
        row = c.fetchone()
        conn.close()
        if row:
            return AdminUser(row[0], row[1], row[2])
        return None
    
    @staticmethod
    def update_password(user_id, new_password):
        """æ›´æ–°å¯†ç """
        from werkzeug.security import generate_password_hash
        conn = get_db_conn()
        c = conn.cursor()
        password_hash = generate_password_hash(new_password)
        c.execute('UPDATE admin_users SET password_hash = ? WHERE id = ?', (password_hash, user_id))
        conn.commit()
        conn.close()
    
    @staticmethod
    def get_statistics():
        """è·å–ç»Ÿè®¡æ•°æ®"""
        conn = get_db_conn()
        c = conn.cursor()
        
        c.execute('SELECT COUNT(*) FROM members')
        total_members = c.fetchone()[0] or 0
        
        c.execute('SELECT COUNT(*) FROM members WHERE is_vip = 1')
        vip_members = c.fetchone()[0] or 0
        
        c.execute('SELECT COALESCE(SUM(balance), 0) FROM members')
        total_balance = c.fetchone()[0] or 0
        
        c.execute('SELECT COALESCE(SUM(missed_balance), 0) FROM members')
        total_missed = c.fetchone()[0] or 0
        
        conn.close()
        
        return {
            'total_members': total_members,
            'vip_members': vip_members,
            'total_balance': total_balance,
            'total_missed': total_missed
        }
    
    @staticmethod
    def get_chart_data():
        """è·å–å›¾è¡¨ç»Ÿè®¡æ•°æ®"""
        conn = get_db_conn()
        c = conn.cursor()
        
        # è·å–è¿‘7å¤©çš„æ³¨å†Œè¶‹åŠ¿
        from datetime import datetime, timedelta
        today = datetime.now().date()
        dates = []
        counts = []
        
        for i in range(6, -1, -1):
            date = today - timedelta(days=i)
            date_str = date.strftime('%Y-%m-%d')
            dates.append(date.strftime('%m-%d'))
            
            c.execute("SELECT COUNT(*) FROM members WHERE register_time LIKE ?", (f"{date_str}%",))
            count = c.fetchone()[0]
            counts.append(count)
            
        # è·å–VIPæ¯”ä¾‹
        c.execute('SELECT COUNT(*) FROM members WHERE is_vip = 1')
        vip_count = c.fetchone()[0]
        c.execute('SELECT COUNT(*) FROM members WHERE is_vip = 0')
        normal_count = c.fetchone()[0]
        
        conn.close()
        
        return {
            'growth': {'labels': dates, 'data': counts},
            'composition': {'vip': vip_count, 'normal': normal_count}
        }
    
    @staticmethod
    def get_withdrawals(page=1, per_page=20, status='all', search=''):
        """è·å–æç°åˆ—è¡¨"""
        conn = get_db_conn()
        c = conn.cursor()
        offset = (page - 1) * per_page
        
        try:
            search_term = search.lstrip('@').strip() if search else ''
            
            if status != 'all':
                c.execute('SELECT id, member_id, amount, usdt_address, status, create_time, process_time FROM withdrawals WHERE status = ? ORDER BY id DESC', (status,))
            else:
                c.execute('SELECT id, member_id, amount, usdt_address, status, create_time, process_time FROM withdrawals ORDER BY id DESC')
            
            all_rows = c.fetchall()
            
            results = []
            for row in all_rows:
                member_id = row[1]
                c.execute('SELECT username FROM members WHERE telegram_id = ?', (member_id,))
                user_row = c.fetchone()
                username = user_row[0] if user_row else str(member_id)
                
                if search_term:
                    if search_term.lower() not in username.lower() and search_term not in str(member_id):
                        continue
                
                results.append({
                    'id': row[0],
                    'member_id': row[1],
                    'amount': row[2],
                    'usdt_address': row[3],
                    'status': row[4],
                    'create_time': row[5],
                    'process_time': row[6],
                    'username': username
                })
            
            total = len(results)
            withdrawals = results[offset:offset + per_page]
            
            return {
                'withdrawals': withdrawals,
                'total': total,
                'page': page,
                'pages': (total + per_page - 1) // per_page if total > 0 else 1,
                'per_page': per_page
            }
        except Exception as e:
            print(f"get_withdrawals error: {e}")
            import traceback
            traceback.print_exc()
            return {'withdrawals': [], 'total': 0, 'page': 1, 'pages': 1, 'per_page': per_page}
        finally:
            conn.close()
    
    @staticmethod
    def process_withdrawal(withdrawal_id, action):
        """å¤„ç†æç°è¯·æ±‚"""
        conn = get_db_conn()
        c = conn.cursor()
        
        try:
            c.execute('SELECT member_id, amount, status FROM withdrawals WHERE id = ?', (withdrawal_id,))
            row = c.fetchone()
            
            if not row:
                return False, "è®°å½•ä¸å­˜åœ¨"
                
            member_id, amount, status = row
            
            from datetime import datetime
            now = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
            
            if action == 'approve':
                if status == 'rejected':
                    c.execute('UPDATE members SET balance = balance - ? WHERE telegram_id = ?', 
                             (amount, member_id))
                
                c.execute('UPDATE withdrawals SET status = ?, process_time = ? WHERE id = ?', 
                         ('approved', now, withdrawal_id))
                
            elif action == 'reject':
                if status != 'pending':
                    return False, "åªèƒ½æ‹’ç»å¾…å¤„ç†çš„æç°"
                
                c.execute('UPDATE withdrawals SET status = ?, process_time = ? WHERE id = ?', 
                         ('rejected', now, withdrawal_id))
                c.execute('UPDATE members SET balance = balance + ? WHERE telegram_id = ?', 
                         (amount, member_id))
            else:
                return False, "æ— æ•ˆæ“ä½œ"
                
            conn.commit()
            
            # å‘é€BOTé€šçŸ¥
            try:
                import requests
                if action == 'approve':
                    msg = f"âœ… æç°å®¡æ ¸é€šè¿‡\n\nğŸ’° é‡‘é¢: {amount} USDT\nğŸ“ è®¢å•å·: #{withdrawal_id}\nâ° æ—¶é—´: {now}\n\nè¯·æ³¨æ„æŸ¥æ”¶ï¼Œæ„Ÿè°¢æ‚¨çš„è€å¿ƒç­‰å¾…ï¼"
                else:
                    msg = f"âŒ æç°ç”³è¯·è¢«æ‹’ç»\n\nğŸ’° é‡‘é¢: {amount} USDT\nğŸ“ è®¢å•å·: #{withdrawal_id}\nâ° æ—¶é—´: {now}\n\nä½™é¢å·²é€€å›è´¦æˆ·ï¼Œå¦‚æœ‰ç–‘é—®è¯·è”ç³»å®¢æœã€‚"
                
                requests.post("http://127.0.0.1:5051/internal/notify", json={
                    'member_id': member_id, 'message': msg
                }, timeout=1)
            except:
                pass
            
            return True, "æ“ä½œæˆåŠŸ"
        except Exception as e:
            return False, str(e)
        finally:
            conn.close()
    
    @staticmethod
    def get_all_members(page=1, per_page=20, search='', filter_type='all'):
        """è·å–ä¼šå‘˜åˆ—è¡¨ï¼ˆå®Œæ•´ç‰ˆï¼Œè¿‡æ»¤æ‰æ¡æ¼è´¦å·ï¼‰"""
        conn = get_db_conn()
        c = conn.cursor()
        offset = (page - 1) * per_page
        
        search_term = search.lstrip('@').strip() if search else ''
        
        # æ„å»ºæŸ¥è¯¢æ¡ä»¶ï¼ˆä½¿ç”¨è¡¨åˆ«å mï¼‰
        where_clauses = []
        params = []

        # ã€æ ¸å¿ƒä¿®æ”¹ã€‘è¿‡æ»¤æ‰æ¡æ¼è´¦å·ï¼šæ’é™¤åœ¨ fallback_accounts è¡¨ä¸­çš„ç”¨æˆ·
        where_clauses.append('m.telegram_id NOT IN (SELECT telegram_id FROM fallback_accounts)')
        
        if filter_type == 'vip':
            where_clauses.append('m.is_vip = 1')
        elif filter_type == 'normal':
            where_clauses.append('m.is_vip = 0')
        
        if search_term:
            where_clauses.append('(m.username LIKE ? OR m.telegram_id LIKE ?)')
            params.extend([f'%{search_term}%', f'%{search_term}%'])
        
        where_sql = ' AND '.join(where_clauses) if where_clauses else '1=1'
        
        # è·å–æ€»æ•°ï¼ˆä½¿ç”¨JOINä»¥ä¿æŒä¸€è‡´æ€§ï¼‰
        c.execute(f'''
            SELECT COUNT(*) 
            FROM members m
            LEFT JOIN members r ON m.referrer_id = r.telegram_id
            WHERE {where_sql}
        ''', params)
        total = c.fetchone()[0]
        
        # è·å–åˆ†é¡µæ•°æ®ï¼ˆåŒ…å«æ‰€æœ‰å¿…è¦å­—æ®µï¼‰
        c.execute(f'''
            SELECT m.id, m.telegram_id, m.username, m.balance, m.is_vip, m.register_time, m.vip_time, 
                   m.referrer_id, m.group_link, m.missed_balance, m.total_earned,
                   m.is_group_bound, m.is_bot_admin, m.is_joined_upline, m.backup_account,
                   r.username as referrer_username
            FROM members m
            LEFT JOIN members r ON m.referrer_id = r.telegram_id
            WHERE {where_sql}
            ORDER BY m.id DESC
            LIMIT ? OFFSET ?
        ''', params + [per_page, offset])
        
        rows = c.fetchall()
        members = []
        
        # è·å–ç³»ç»Ÿé…ç½®çš„å±‚çº§æ•°
        try:
            c.execute("SELECT value FROM system_config WHERE key = 'level_count'")
            level_row = c.fetchone()
            level_count_cfg = int(level_row[0]) if level_row else 10
        except Exception:
            level_count_cfg = 10
        
        for row in rows:
            tg_id = row[1]
            # ã€æ ¸å¿ƒä¿®å¤ã€‘å®æ—¶è®¡ç®—ç›´æ¨ä¸å›¢é˜Ÿï¼ˆé¿å… team_count å…¨ä¸º 0ï¼‰
            downline_counts = DB.get_downline_count(tg_id, level_count_cfg)
            direct_count = downline_counts[0]['total'] if downline_counts else 0
            team_count = sum(item.get('total', 0) for item in downline_counts) if downline_counts else 0
            
            members.append({
                'id': row[0],  # æ·»åŠ IDå­—æ®µ
                'telegram_id': row[1],
                'username': row[2] or '',
                'balance': row[3] or 0,
                'is_vip': bool(row[4]),
                'register_time': row[5][:19] if row[5] else '',
                'vip_time': row[6][:19] if row[6] else '',
                'referrer_id': row[7],
                'referrer_username': row[15] or '',  # æ·»åŠ æ¨èäººç”¨æˆ·å
                'group_link': row[8] or '',
                'missed_balance': row[9] or 0,
                'total_earned': row[10] or 0,
                'is_group_bound': bool(row[11]),  # æ·»åŠ ç¾¤çŠ¶æ€å­—æ®µ
                'is_bot_admin': bool(row[12]),
                'is_joined_upline': bool(row[13]),
                'direct_count': direct_count,  # å®æ—¶è®¡ç®—çš„ç›´æ¨äººæ•°
                'team_count': team_count  # å®æ—¶è®¡ç®—çš„å›¢é˜Ÿäººæ•°
            })
        
        conn.close()
        
        return {
            'members': members,
            'total': total,
            'page': page,
            'per_page': per_page,
            'pages': (total + per_page - 1) // per_page
        }
    
    @staticmethod
    def get_member_detail(telegram_id):
        """è·å–ä¼šå‘˜è¯¦æƒ…"""
        conn = get_db_conn()
        c = conn.cursor()
        
        c.execute('''
            SELECT telegram_id, username, balance, is_vip, register_time, vip_time,
                   referrer_id, group_link, missed_balance, total_earned, backup_account
            FROM members WHERE telegram_id = ?
        ''', (telegram_id,))
        
        row = c.fetchone()
        conn.close()
        
        if not row:
            return None
        
        return {
            'telegram_id': row[0],
            'username': row[1] or '',
            'balance': row[2] or 0,
            'is_vip': bool(row[3]),
            'register_time': row[4][:19] if row[4] else '',
            'vip_time': row[5][:19] if row[5] else '',
            'referrer_id': row[6],
            'group_link': row[7] or '',
            'missed_balance': row[8] or 0,
            'total_earned': row[9] or 0,
            'backup_account': row[10] or ''
        }
    
    @staticmethod
    def update_member(telegram_id, data):
        """æ›´æ–°ä¼šå‘˜ä¿¡æ¯"""
        conn = get_db_conn()
        c = conn.cursor()
        
        allowed_fields = ['username', 'balance', 'is_vip', 'group_link', 'missed_balance', 'total_earned']
        updates = []
        params = []
        
        for field in allowed_fields:
            if field in data:
                updates.append(f'{field} = ?')
                params.append(data[field])
        
        if updates:
            params.append(telegram_id)
            c.execute(f'UPDATE members SET {", ".join(updates)} WHERE telegram_id = ?', params)
            conn.commit()
        
        conn.close()
    
    @staticmethod
    def delete_member(telegram_id):
        """åˆ é™¤ä¼šå‘˜"""
        conn = get_db_conn()
        c = conn.cursor()
        c.execute('DELETE FROM members WHERE telegram_id = ?', (telegram_id,))
        conn.commit()
        conn.close()

# ==================== æ•°æ®åº“å‡çº§å‡½æ•° ====================

def upgrade_members_table():
    """å‡çº§membersè¡¨ç»“æ„"""
    conn = get_db_conn()
    c = conn.cursor()
    try:
        c.execute('ALTER TABLE members ADD COLUMN is_group_bound INTEGER DEFAULT 0')
    except: pass
    try:
        c.execute('ALTER TABLE members ADD COLUMN is_bot_admin INTEGER DEFAULT 0')
    except: pass
    try:
        c.execute('ALTER TABLE members ADD COLUMN is_joined_upline INTEGER DEFAULT 0')
    except: pass
    try:
        c.execute('ALTER TABLE members ADD COLUMN level_path TEXT')
    except: pass
    try:
        c.execute('ALTER TABLE members ADD COLUMN direct_count INTEGER DEFAULT 0')
    except: pass
    try:
        c.execute('ALTER TABLE members ADD COLUMN team_count INTEGER DEFAULT 0')
    except: pass
    try:
        c.execute('ALTER TABLE members ADD COLUMN total_earned REAL DEFAULT 0')
    except: pass
    try:
        c.execute('ALTER TABLE members ADD COLUMN withdraw_address TEXT')
    except: pass
    conn.commit()
    conn.close()

def upgrade_member_groups_table():
    """å‡çº§member_groupsè¡¨ç»“æ„"""
    conn = get_db_conn()
    c = conn.cursor()
    try:
        c.execute('ALTER TABLE member_groups ADD COLUMN owner_username TEXT')
    except: pass
    try:
        c.execute('ALTER TABLE member_groups ADD COLUMN group_type TEXT DEFAULT "group"')
    except: pass
    try:
        c.execute('ALTER TABLE member_groups ADD COLUMN schedule_broadcast INTEGER DEFAULT 1')
    except: pass
    conn.commit()
    conn.close()

def upgrade_broadcast_table():
    """å‡çº§broadcast_messagesè¡¨ç»“æ„"""
    conn = get_db_conn()
    c = conn.cursor()
    try:
        c.execute('ALTER TABLE broadcast_messages ADD COLUMN image_url TEXT')
    except: pass
    try:
        c.execute('ALTER TABLE broadcast_messages ADD COLUMN video_url TEXT')
    except: pass
    try:
        c.execute('ALTER TABLE broadcast_messages ADD COLUMN buttons TEXT')
    except: pass
    try:
        c.execute('ALTER TABLE broadcast_messages ADD COLUMN buttons_per_row INTEGER DEFAULT 2')
    except: pass
    try:
        c.execute('ALTER TABLE broadcast_messages ADD COLUMN schedule_enabled INTEGER DEFAULT 0')
    except: pass
    try:
        c.execute('ALTER TABLE broadcast_messages ADD COLUMN schedule_time TEXT')
    except: pass
    try:
        c.execute('ALTER TABLE broadcast_messages ADD COLUMN broadcast_interval INTEGER DEFAULT 120')
    except: pass
    try:
        c.execute('ALTER TABLE broadcast_messages ADD COLUMN broadcast_interval INTEGER DEFAULT 120')
    except: pass
    conn.commit()
    conn.close()

def upsert_member_group(telegram_id, group_link, owner_username=None, is_bot_admin=1):
    """
    å†™å…¥æˆ–æ›´æ–° member_groups è¡¨ï¼Œä¾¿äºåå°åˆ—è¡¨å±•ç¤ºã€‚
    é»˜è®¤ is_bot_admin=1ï¼Œå› ä¸ºéªŒè¯é€šè¿‡åæ‰ä¼šè°ƒç”¨ã€‚
    """
    if not group_link:
        return
    try:
        conn = get_db_conn()
        c = conn.cursor()
        c.execute('SELECT id FROM member_groups WHERE telegram_id = ?', (telegram_id,))
        row = c.fetchone()
        now = get_cn_time()
        if row:
            c.execute(
                '''UPDATE member_groups 
                   SET group_link = ?, owner_username = COALESCE(?, owner_username)
                 WHERE id = ?''',
                (group_link, owner_username, row[0])
            )
        else:
            c.execute(
                '''INSERT INTO member_groups 
                   (telegram_id, group_name, group_link, is_bot_admin, create_time, owner_username, group_type, schedule_broadcast)
                   VALUES (?, ?, ?, ?, ?, ?, ?, ?)''',
                (telegram_id, '', group_link, is_bot_admin, now, owner_username or '', 'group', 1)
            )
        conn.commit()
        conn.close()
    except Exception as e:
        print(f'[member_groups upsert] error: {e}')

def sync_member_groups_from_members():
    """å¯åŠ¨æ—¶åŒæ­¥å·²å­˜åœ¨çš„ä¼šå‘˜ç¾¤é“¾æ¥åˆ° member_groupsï¼Œé¿å…åå°åˆ—è¡¨ä¸ºç©º"""
    try:
        conn = get_db_conn()
        c = conn.cursor()
        c.execute("SELECT telegram_id, username, group_link FROM members WHERE group_link IS NOT NULL AND group_link != ''")
        rows = c.fetchall()
        conn.close()
        for r in rows:
            tg_id, uname, glink = r
            try:
                upsert_member_group(tg_id, glink, uname or None, is_bot_admin=1)
            except Exception as inner_err:
                print(f'[sync_member_groups] å•æ¡å¤±è´¥ {tg_id}: {inner_err}')
    except Exception as e:
        print(f'[sync_member_groups] å¤±è´¥: {e}')

# åœ¨æ¨¡å—åŠ è½½æ—¶æ‰§è¡Œæ•°æ®åº“å‡çº§
upgrade_members_table()
upgrade_member_groups_table()
upgrade_broadcast_table()

-e 

--- File: ./app/payment.py ---
"""
æ”¯ä»˜ç›¸å…³åŠŸèƒ½æ¨¡å—
åŒ…å«USDTå……å€¼ã€æ”¯ä»˜è®¢å•åˆ›å»ºã€æ”¯ä»˜çŠ¶æ€æ£€æŸ¥ç­‰åŠŸèƒ½
"""
import asyncio
import time
import hashlib
import requests as req
import re
from datetime import datetime, timedelta, timezone
from telethon import Button
import os
import sys

# æ·»åŠ é¡¹ç›®æ ¹ç›®å½•åˆ°Pythonè·¯å¾„
project_root = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
if project_root not in sys.path:
    sys.path.insert(0, project_root)

from app.config import ADMIN_IDS
from app.database import DB, get_cn_time, get_system_config, get_db_conn
from app.core_functions import update_level_path, distribute_vip_rewards, get_upline_chain

# æ”¯ä»˜é…ç½®
PAYMENT_CONFIG = {
    'api_url': 'https://usdt.qxzy7888.org/pay/',
    'partner_id': '15',
    'key': '5c9dd0b054b184f964',
    'notify_url': 'http://154.201.68.178:5051/api/payment/notify',
    'return_url': 'http://154.201.68.178:5051/payment/success',
    'pay_type': 'trc20',
    'version': '1.0'
}

# æ”¯ä»˜è®¢å•ç›¸å…³
payment_orders = {}  # å­˜å‚¨å……å€¼è®¢å•
payment_tasks = {}  # å­˜å‚¨æ”¯ä»˜æ£€æŸ¥ä»»åŠ¡
interval_time_in_seconds = 9  # æ£€æŸ¥æ”¯ä»˜é—´éš”ï¼ˆç§’ï¼‰
check_duration_seconds = 1200  # è®¢å•æœ‰æ•ˆæœŸï¼ˆç§’ï¼‰ï¼Œ20åˆ†é’Ÿ

CN_TIMEZONE = timezone(timedelta(hours=8))

def generate_payment_sign(params, key):
    """ç”Ÿæˆæ”¯ä»˜ç­¾å"""
    sorted_params = sorted([(k, v) for k, v in params.items() if v is not None and v != ''])
    sign_str = '&'.join([f'{k}={v}' for k, v in sorted_params])
    sign_str += f'&key={key}'
    return hashlib.md5(sign_str.encode()).hexdigest().upper()

def create_payment_order(amount, out_trade_no, remark=''):
    """åˆ›å»ºæ”¯ä»˜è®¢å•"""
    params = {
        'amount': f'{amount:.2f}',
        'partnerid': PAYMENT_CONFIG['partner_id'],
        'notifyUrl': PAYMENT_CONFIG['notify_url'],
        'out_trade_no': out_trade_no,
        'payType': PAYMENT_CONFIG['pay_type'],
        'returnUrl': PAYMENT_CONFIG['return_url'],
        'version': PAYMENT_CONFIG['version'],
        'format': 'json'
    }
    params['sign'] = generate_payment_sign(params, PAYMENT_CONFIG['key'])
    if remark:
        params['remark'] = remark
    try:
        print(f'[æ”¯ä»˜API] è¯·æ±‚å‚æ•°: {params}')
        response = req.post(PAYMENT_CONFIG['api_url'], data=params, timeout=10)
        result = response.json()
        print(f'[æ”¯ä»˜API] å“åº”: {result}')
        return result
    except Exception as e:
        print(f'[æ”¯ä»˜APIé”™è¯¯] {e}')
        import traceback
        traceback.print_exc()
        return None

def check_usdt_transaction(usdt_address):
    """æŸ¥è¯¢USDT TRC20åœ°å€çš„äº¤æ˜“è®°å½•"""
    try:
        api_url = f"https://api.trongrid.io/v1/accounts/{usdt_address}/transactions/trc20?limit=200&contract_address=TR7NHqjeKQxGTCi8q8ZY4pL8otSzgjLj6t"
        response = req.get(api_url, timeout=10)
        if response.status_code == 200:
            return response.json()
        return None
    except Exception as e:
        print(f"æŸ¥è¯¢USDTäº¤æ˜“å¤±è´¥: {e}")
        return None

def extract_usdt_address_from_payment_url(payment_url):
    """ä»æ”¯ä»˜é“¾æ¥é¡µé¢è§£æUSDTæ”¶æ¬¾åœ°å€"""
    if not payment_url:
        return None
    
    try:
        headers = {
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
        }
        response = req.get(payment_url, headers=headers, timeout=10, allow_redirects=True)
        
        if response.status_code == 200:
            html = response.text
            # åŒ¹é…TRC20åœ°å€æ ¼å¼ï¼šTå¼€å¤´ï¼Œ34ä¸ªå­—ç¬¦
            pattern = r'T[A-Za-z1-9]{33}'
            matches = re.findall(pattern, html)
            if matches:
                return matches[0]
    except Exception as e:
        print(f'[è§£ææ”¯ä»˜åœ°å€] å¤±è´¥: {e}')
    
    return None

async def check_payment_task(bot, order):
    """æŒç»­æ£€æŸ¥è®¢å•æ”¯ä»˜çŠ¶æ€"""
    print(f"å¼€å§‹æ£€æŸ¥è®¢å• {order['order_number']} çš„æ”¯ä»˜çŠ¶æ€")
    
    while True:
        try:
            print(f"æ­£åœ¨æ£€æŸ¥è®¢å• {order['order_number']} - é‡‘é¢: {order['amount']} U")
            
            # æŸ¥è¯¢äº¤æ˜“è®°å½•
            transaction_data = check_usdt_transaction(order['usdt_address'])
            
            if transaction_data and 'data' in transaction_data:
                current_time = datetime.now(CN_TIMEZONE)
                
                for transaction in transaction_data['data']:
                    # è·å–äº¤æ˜“æ—¶é—´
                    transaction_time = datetime.fromtimestamp(
                        transaction['block_timestamp'] / 2000,
                        tz=CN_TIMEZONE
                    )
                    
                    # æ£€æŸ¥äº¤æ˜“æ˜¯å¦åœ¨è®¢å•åˆ›å»ºåä¸”åœ¨æœ‰æ•ˆæœŸå†…
                    if transaction_time > order['created_at'] and transaction_time < (order['created_at'] + timedelta(seconds=check_duration_seconds)):
                        # è·å–äº¤æ˜“é‡‘é¢ï¼ˆUSDTçš„ç²¾åº¦æ˜¯6ä½å°æ•°ï¼‰
                        amount = float(transaction['value']) / 2000000
                        
                        print(f"å‘ç°äº¤æ˜“ - é‡‘é¢: {amount} U, è®¢å•é‡‘é¢: {order['amount']} U")
                        
                        # æ£€æŸ¥é‡‘é¢æ˜¯å¦åŒ¹é…
                        if abs(float(order['amount']) - amount) < 0.01:  # å…è®¸0.01çš„è¯¯å·®
                            print(f"è®¢å• {order['order_number']} æ”¯ä»˜æˆåŠŸï¼")
                            
                            # å¤„ç†å……å€¼ï¼ˆåˆ¤æ–­æ˜¯å¦ä¸ºVIPè®¢å•ï¼‰
                            is_vip_order = order.get('is_vip_order', False)
                            # å»¶è¿Ÿå¯¼å…¥é¿å…å¾ªç¯ä¾èµ–
                            import importlib
                            bot_logic_module = importlib.import_module('bot_logic')
                            await bot_logic_module.process_recharge(order['telegram_id'], amount, is_vip_order)
                            
                            # æ¸…ç†è®¢å•å’Œä»»åŠ¡
                            order_number = order['order_number']
                            if order_number in payment_tasks:
                                _, timeout_task = payment_tasks[order_number]
                                timeout_task.cancel()
                                del payment_tasks[order_number]
                            
                            if order_number in payment_orders:
                                del payment_orders[order_number]
                            
                            return
            
            print(f"æœªå‘ç°è®¢å• {order['order_number']} çš„æ”¯ä»˜ï¼Œ{interval_time_in_seconds}ç§’åé‡è¯•")
            await asyncio.sleep(interval_time_in_seconds)
            
        except Exception as e:
            print(f"æ£€æŸ¥æ”¯ä»˜å¼‚å¸¸: {e}")
            await asyncio.sleep(interval_time_in_seconds)

async def payment_timeout_handler(bot, order):
    """å¤„ç†è®¢å•è¶…æ—¶ï¼ˆä¿®å¤ç‰ˆï¼šå¢åŠ çŠ¶æ€äºŒæ¬¡æ£€æŸ¥ï¼Œå®Œç¾è§£å†³æ‰‹åŠ¨å…¥æ¬¾å´æç¤ºè¶…æ—¶çš„é—®é¢˜ï¼‰

    é—®é¢˜æ ¹æºï¼š
    - ä¸‰æ–¹æ”¯ä»˜åå°æ˜¾ç¤º"ç­‰å¾…æ”¯ä»˜"æ˜¯æ­£å¸¸çš„ï¼ˆå› ä¸ºç®¡ç†å‘˜æ²¡çœŸä»˜é’±ï¼‰
    - æœ¬åœ°æœºå™¨äººåå°æ˜¾ç¤º"å·²å®Œæˆ"æ˜¯ç®¡ç†å‘˜æ‰‹åŠ¨æ“ä½œçš„ç»“æœ
    - æœºå™¨äººå€’è®¡æ—¶ä»»åŠ¡é†’æ¥åï¼Œæ²¡æœ‰æ£€æŸ¥æ•°æ®åº“çŠ¶æ€å°±å‘è¶…æ—¶é€šçŸ¥

    è§£å†³æ–¹æ¡ˆï¼š
    - åœ¨å‘é€è¶…æ—¶é€šçŸ¥å‰ï¼Œå…ˆå»æ•°æ®åº“æ£€æŸ¥è®¢å•çŠ¶æ€
    - å¦‚æœæ•°æ®åº“çŠ¶æ€å·²æ˜¯completedï¼Œç›´æ¥æ‹¦æˆªè¶…æ—¶é€šçŸ¥
    """
    # 1. ç­‰å¾…è®¢å•æœ‰æ•ˆæœŸï¼ˆä¾‹å¦‚20åˆ†é’Ÿ = 1200ç§’ï¼‰
    check_duration = 1200
    await asyncio.sleep(check_duration)
    
    order_number = order['order_number']
    telegram_id = order['telegram_id']
    
    # 2. æ¸…ç†å†…å­˜ä¸­çš„ä»»åŠ¡è®°å½•ï¼ˆåœæ­¢è½®è¯¢åŒºå—é“¾ï¼‰
    if order_number in payment_orders:
        del payment_orders[order_number]
    if order_number in payment_tasks:
        del payment_tasks[order_number]

    try:
        # 3. ã€å…³é”®æ­¥éª¤ã€‘å»æ•°æ®åº“æŸ¥æœ€æ–°çš„çŠ¶æ€
        conn = get_db_conn()
        c = conn.cursor()
        c.execute("SELECT status FROM recharge_records WHERE order_id = ?", (order_number,))
        row = c.fetchone()
        conn.close()

        # 4. å¦‚æœæ•°æ®åº“æ˜¾ç¤ºå·²å®Œæˆï¼ˆç®¡ç†å‘˜æ‰‹åŠ¨ç‚¹è¿‡æˆ–å›è°ƒæˆåŠŸï¼‰ï¼Œç›´æ¥é€€å‡ºï¼Œä»€ä¹ˆéƒ½ä¸å‘
        if row and row[0] == 'completed':
            print(f"[è¶…æ—¶æ£€æŸ¥] è®¢å• {order_number} å·²ç”±ç®¡ç†å‘˜æ‰‹åŠ¨å®Œæˆæˆ–æ”¯ä»˜æˆåŠŸï¼Œæ‹¦æˆªè¶…æ—¶é€šçŸ¥")
            return
        # 5. åªæœ‰çŠ¶æ€ç¡®å®ä¸æ˜¯ completed æ—¶ï¼Œæ‰å‘è¶…æ—¶é€šçŸ¥
            await bot.send_message(
            telegram_id,
            f'â° è®¢å•å·²å…³é—­\n\nè®¢å•å·: {order_number}\né‡‘é¢: {order["amount"]} U\n\næç¤ºï¼šå¦‚æœæ‚¨å·²æ”¯ä»˜ä½†æœªåˆ°è´¦ï¼Œè¯·è”ç³»äººå·¥å®¢æœå¤„ç†ã€‚'
            )
    except Exception as e:
        print(f"[è¶…æ—¶å¤„ç†é”™è¯¯] {e}")

async def create_recharge_order(bot, event, amount, is_vip_order=False):
    """åˆ›å»ºå……å€¼è®¢å•"""
    telegram_id = event.sender_id
    order_number = f"RCH_{telegram_id}_{int(time.time())}"
    payment_result = create_payment_order(amount, order_number, f"TG{telegram_id}")
    if not payment_result or payment_result.get("code") != 200:
        await event.respond("åˆ›å»ºæ”¯ä»˜è®¢å•å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•")
        return

    # ä¿å­˜å……å€¼è®°å½•åˆ°æ•°æ®åº“
    conn = get_db_conn()
    c = conn.cursor()
    remark = "å¼€é€š" if is_vip_order else ""

    # æ£€æŸ¥è¡¨æ˜¯å¦æœ‰remarkå­—æ®µ
    c.execute("PRAGMA table_info(recharge_records)")
    columns = [col[1] for col in c.fetchall()]
    if 'remark' in columns:
        c.execute('''INSERT INTO recharge_records
                     (member_id, amount, order_id, status, payment_method, remark, create_time)
                     VALUES (?, ?, ?, ?, ?, ?, ?)''',
                  (telegram_id, amount, order_number, 'pending', 'USDT', remark, get_cn_time()))
    else:
        c.execute('''INSERT INTO recharge_records
                     (member_id, amount, order_id, status, payment_method, create_time)
                     VALUES (?, ?, ?, ?, ?, ?)''',
                  (telegram_id, amount, order_number, 'pending', 'USDT', get_cn_time()))
    conn.commit()
    conn.close()
    
    # ä¼˜å…ˆä½¿ç”¨æ”¯ä»˜å¹³å°è¿”å›çš„æ”¯ä»˜é“¾æ¥/äºŒç»´ç 
    payment_url = None
    payment_qrcode = None
    usdt_address = None
    
    if payment_result.get("code") == 200:
        data = payment_result.get("data", {})
        if isinstance(data, dict):
            # å°è¯•è·å–æ”¯ä»˜é“¾æ¥
            payment_url = data.get("url") or data.get("data", {}).get("url") or data.get("data", {}).get("qrcode")
            payment_qrcode = data.get("data", {}).get("qrcode")
            
            # å°è¯•ä»æ”¯ä»˜å¹³å°è¿”å›çš„æ•°æ®ä¸­ç›´æ¥è·å–åœ°å€ï¼ˆå¦‚æœæœ‰çš„è¯ï¼‰
            if "address" in str(data).lower() or "æ”¶æ¬¾åœ°å€" in str(data):
                data_str = str(data)
                pattern = r'T[A-Za-z1-9]{33}'
                matches = re.findall(pattern, data_str)
                if matches:
                    usdt_address = matches[0]
    
    # å¦‚æœæ²¡æœ‰ä»è¿”å›æ•°æ®ä¸­è·å–åˆ°åœ°å€ï¼Œå°è¯•ä»æ”¯ä»˜é“¾æ¥é¡µé¢å®æ—¶è§£æ
    if not usdt_address and payment_url:
        print(f'[æ”¯ä»˜åœ°å€] å¼€å§‹å®æ—¶è§£ææ”¯ä»˜é“¾æ¥: {payment_url}')
        usdt_address = extract_usdt_address_from_payment_url(payment_url)
        if usdt_address:
            print(f'[æ”¯ä»˜åœ°å€] å®æ—¶è§£ææˆåŠŸ: {usdt_address}')
        else:
            print(f'[æ”¯ä»˜åœ°å€] å®æ—¶è§£æå¤±è´¥ï¼Œæœªæ‰¾åˆ°USDTåœ°å€')
    
    # åªä½¿ç”¨å®æ—¶è§£æåˆ°çš„åœ°å€ï¼Œä¸ä½¿ç”¨ä»»ä½•ç¼“å­˜æˆ–æ‰‹åŠ¨é…ç½®
    if usdt_address:
        msg = f'''âœ… æ”¯ä»˜è®¢å•å·²åˆ›å»º

è®¢å•å·: `{order_number}`
æ”¯ä»˜é‡‘é¢: {amount:.2f} USDT

ğŸ“ è¯·è½¬è´¦åˆ°ä»¥ä¸‹åœ°å€ï¼š
`{usdt_address}`
(TRC-20ç½‘ç»œ)

âš ï¸ è®¢å•10åˆ†é’Ÿå†…æœ‰æ•ˆï¼Œè¿‡æœŸåè¯·é‡æ–°åˆ›å»º
âš ï¸ è½¬è´¦é‡‘é¢å¿…é¡»ä¸è®¢å•é‡‘é¢å®Œå…¨ä¸€è‡´
âœ… æ”¯ä»˜å®Œæˆåï¼Œç³»ç»Ÿå°†è‡ªåŠ¨åˆ°è´¦ï¼ˆçº¦1-2åˆ†é’Ÿï¼‰'''
    
        buttons = [[Button.inline("è¿”å›", b"back")]]
        await event.respond(msg, buttons=buttons, parse_mode='markdown')
        
        # ä¿å­˜è®¢å•ä¿¡æ¯å¹¶å¯åŠ¨æ”¯ä»˜æ£€æŸ¥ä»»åŠ¡
        order_info = {
            'order_number': order_number,
            'telegram_id': telegram_id,
            'amount': amount,
            'usdt_address': usdt_address,
            'created_at': datetime.now(CN_TIMEZONE),
            'is_vip_order': is_vip_order
        }
        payment_orders[order_number] = order_info
        
        # å¯åŠ¨æ”¯ä»˜æ£€æŸ¥ä»»åŠ¡
        payment_task = bot.loop.create_task(check_payment_task(bot, order_info))
        timeout_task = bot.loop.create_task(payment_timeout_handler(bot, order_info))
        payment_tasks[order_number] = (payment_task, timeout_task)
    else:
        # å¦‚æœæ— æ³•è§£æåˆ°USDTåœ°å€ï¼Œæç¤ºé”™è¯¯
        error_msg = "âŒ æ— æ³•è·å–æ”¯ä»˜åœ°å€ï¼Œè¯·ç¨åé‡è¯•"
        if payment_url:
            error_msg += f"\n\næ”¯ä»˜é“¾æ¥: {payment_url}\nï¼ˆç³»ç»Ÿæ— æ³•è§£æè¯¥é“¾æ¥ä¸­çš„æ”¶æ¬¾åœ°å€ï¼‰"
        await event.respond(
            error_msg,
            buttons=[[Button.inline("è¿”å›", b"back")]]
        )

__all__ = [
    'create_recharge_order', 'check_payment_task', 'payment_timeout_handler',
    'check_usdt_transaction', 'create_payment_order', 'generate_payment_sign',
    'extract_usdt_address_from_payment_url', 'payment_orders', 'payment_tasks',
    'PAYMENT_CONFIG'
]

-e 

--- File: ./app/bot_commands_addon.py ---
"""
æœºå™¨äººå‘½ä»¤æ‰©å±•æ¨¡å—
æ·»åŠ ç¾¤ç»„ç»‘å®šã€æ£€æµ‹ç­‰æ–°åŠŸèƒ½å‘½ä»¤
éœ€è¦åœ¨a.pyä¸­å¯¼å…¥å¹¶æ³¨å†Œè¿™äº›å‘½ä»¤
"""

from telethon import events, Button
import sqlite3
import os
import sys

# æ·»åŠ é¡¹ç›®æ ¹ç›®å½•åˆ°Pythonè·¯å¾„
project_root = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
if project_root not in sys.path:
    sys.path.insert(0, project_root)

from app.core_functions import check_bot_is_admin, get_upline_chain, get_downline_tree, check_user_conditions


async def handle_bind_group(event, bot, DB):
    """å¤„ç†ç¾¤ç»„ç»‘å®š"""
    telegram_id = event.sender_id
    member = DB.get_member(telegram_id)
    
    if not member:
        await event.respond('è¯·å…ˆå‘é€ /start æ³¨å†Œ')
        return
    
    if not member['is_vip']:
        await event.respond('âš ï¸ è¯·å…ˆå¼€é€šVIPæ‰èƒ½ç»‘å®šç¾¤ç»„')
        return
    
    # æç¤ºç”¨æˆ·å‘é€ç¾¤é“¾æ¥
    await event.respond(
        'ğŸ“± ç¾¤ç»„ç»‘å®šæ­¥éª¤ï¼š\n\n'
        '1ï¸âƒ£ å°†æœ¬æœºå™¨äººæ‹‰å…¥æ‚¨çš„ç¾¤ç»„\n'
        '2ï¸âƒ£ å°†æœºå™¨äººè®¾ç½®ä¸ºç®¡ç†å‘˜\n'
        '3ï¸âƒ£ åœ¨æ‚¨çš„ç¾¤é‡Œè¾“å…¥ /link è·å–ç¾¤é“¾æ¥\n'
        '4ï¸âƒ£ å°†ç¾¤é“¾æ¥å‘é€ç»™æˆ‘\n\n'
        'ğŸ’¡ ç¾¤é“¾æ¥æ ¼å¼ï¼šhttps://t.me/+xxx æˆ– @groupname'
    )


async def handle_group_link_message(event, bot, DB):
    """å¤„ç†ç”¨æˆ·å‘é€çš„ç¾¤é“¾æ¥"""
    telegram_id = event.sender_id
    group_link = event.message.text.strip()
    
    # éªŒè¯é“¾æ¥æ ¼å¼
    if not (group_link.startswith('https://t.me/') or group_link.startswith('@')):
        await event.respond('âŒ ç¾¤é“¾æ¥æ ¼å¼ä¸æ­£ç¡®\n\nè¯·å‘é€å®Œæ•´çš„ç¾¤é“¾æ¥ï¼Œæ ¼å¼å¦‚ï¼š\nhttps://t.me/+xxx æˆ– @groupname')
        return
    
    member = DB.get_member(telegram_id)
    if not member or not member['is_vip']:
        return
    
    # æ£€æµ‹æœºå™¨äººæ˜¯å¦åœ¨ç¾¤å†…ä¸”ä¸ºç®¡ç†å‘˜ï¼ˆç»“æœä»…ä½œæç¤ºï¼Œä¸é˜»æ–­æ“ä½œï¼‰
    bot_id = (await bot.get_me()).id
    is_admin = await check_bot_is_admin(bot, bot_id, group_link)
    
    # æ›´æ–°æ•°æ®åº“
    conn = DB.get_conn()
    c = conn.cursor()
    c.execute('''
        UPDATE members 
        SET group_link = ?, is_group_bound = 1, is_bot_admin = ?
        WHERE telegram_id = ?
    ''', (group_link, 1 if is_admin else 0, telegram_id))
    conn.commit()
    conn.close()
    
    if is_admin:
        await event.respond(
            'âœ… ç¾¤ç»„ç»‘å®šæˆåŠŸï¼\n\n'
            f'æ‚¨çš„ç¾¤é“¾æ¥ï¼š{group_link}\n\n'
            'ğŸ‰ æ­å–œï¼æ‚¨å·²å®Œæˆç¾¤ç»„ç»‘å®šå’Œç®¡ç†å‘˜è®¾ç½®\n\n'
            'ä¸‹ä¸€æ­¥ï¼šåŠ å…¥ä¸Šå±‚ç¾¤ç»„\n'
            'å‘é€ /join_upline æŸ¥çœ‹éœ€è¦åŠ å…¥çš„ç¾¤'
        )
    else:
        await event.respond(
            'âœ… ç¾¤ç»„é“¾æ¥å·²è®°å½•\n\n'
            f'é“¾æ¥: {group_link}\n\n'
            'â„¹ï¸ æœªèƒ½è‡ªåŠ¨æ£€æµ‹ç®¡ç†å‘˜æƒé™ï¼Œè¯·ç¡®ä¿æœºå™¨äººå·²åœ¨ç¾¤ä¸”ä¸ºç®¡ç†å‘˜ï¼Œ'
            'å¦åˆ™æŸäº›éªŒè¯åŠŸèƒ½å¯èƒ½ä¸å¯ç”¨ã€‚'
        )


async def handle_join_upline(event, bot, DB, get_system_config):
    """æ˜¾ç¤ºéœ€è¦åŠ å…¥çš„ä¸Šå±‚ç¾¤åˆ—è¡¨"""
    telegram_id = event.sender_id
    member = DB.get_member(telegram_id)
    
    if not member:
        await event.respond('è¯·å…ˆå‘é€ /start æ³¨å†Œ')
        return
    
    if not member['is_vip']:
        await event.respond('âš ï¸ è¯·å…ˆå¼€é€šVIP')
        return
    
    # è·å–ä¸Šçº§é“¾
    config = get_system_config()
    max_level = int(config['level_count'])
    upline_chain = get_upline_chain(telegram_id, max_level)
    
    if not upline_chain:
        await event.respond('æ‚¨æ²¡æœ‰ä¸Šçº§ï¼Œæ— éœ€åŠ ç¾¤')
        return
    
    # è·å–ä¸Šå±‚ç¾¤åˆ—è¡¨ï¼ˆæ–°æ ¼å¼ï¼šå­—å…¸åˆ—è¡¨ï¼‰
    upline_groups = []
    for item in upline_chain:
        if item.get('is_fallback'):
            # è·³è¿‡æ¡æ¼è´¦å·
            continue
        upline_id = item['id']
        level = item['level']
        up_member = DB.get_member(upline_id)
        if up_member and up_member['group_link']:
            upline_groups.append({
                'level': level,
                'username': up_member['username'],
                'group_link': up_member['group_link']
            })
    
    if not upline_groups:
        await event.respond('ä¸Šå±‚æš‚æ— å¯åŠ å…¥çš„ç¾¤')
        return
    
    # æ„å»ºæŒ‰é’®
    buttons = []
    text = f'ğŸ“‹ éœ€è¦åŠ å…¥çš„ä¸Šå±‚ç¾¤ç»„ï¼ˆå…±{len(upline_groups)}ä¸ªï¼‰\n\n'
    
    for i, group in enumerate(upline_groups, 1):
        text += f'{i}. ç¬¬{group["level"]}å±‚ - @{group["username"]}çš„ç¾¤\n'
        buttons.append([Button.url(f'åŠ å…¥ç¬¬{group["level"]}å±‚ç¾¤', group['group_link'])])
    
    text += '\nğŸ’¡ è¯·ä¾æ¬¡åŠ å…¥æ‰€æœ‰ç¾¤ç»„ï¼Œå®Œæˆåå‘é€ /check_status æ£€æŸ¥çŠ¶æ€'
    
    await event.respond(text, buttons=buttons)


async def handle_check_status(event, bot, DB):
    """æ£€æŸ¥ç”¨æˆ·å®ŒæˆçŠ¶æ€"""
    telegram_id = event.sender_id
    member = DB.get_member(telegram_id)
    
    if not member:
        await event.respond('è¯·å…ˆå‘é€ /start æ³¨å†Œ')
        return
    
    # æ£€æŸ¥æ‰€æœ‰æ¡ä»¶
    conditions = await check_user_conditions(bot, telegram_id)
    
    if not conditions:
        await event.respond('âŒ è·å–çŠ¶æ€å¤±è´¥')
        return
    
    # ç”ŸæˆçŠ¶æ€æŠ¥å‘Š
    status_text = 'ğŸ“Š æ‚¨çš„å®ŒæˆçŠ¶æ€\n\n'
    status_text += f'âœ… VIPçŠ¶æ€ï¼š{"å·²å¼€é€š" if conditions["is_vip"] else "æœªå¼€é€š"}\n'
    status_text += f'{"âœ…" if conditions["is_group_bound"] else "âŒ"} ç¾¤ç»„ç»‘å®šï¼š{"å·²å®Œæˆ" if conditions["is_group_bound"] else "æœªå®Œæˆ"}\n'
    status_text += f'{"âœ…" if conditions["is_bot_admin"] else "âŒ"} æœºå™¨äººç®¡ç†å‘˜ï¼š{"å·²è®¾ç½®" if conditions["is_bot_admin"] else "æœªè®¾ç½®"}\n'
    status_text += f'{"âœ…" if conditions["is_joined_upline"] else "âŒ"} åŠ å…¥ä¸Šå±‚ç¾¤ï¼š{"å·²å®Œæˆ" if conditions["is_joined_upline"] else "æœªå®Œæˆ"}\n\n'
    
    if conditions['all_conditions_met']:
        status_text += 'ğŸ‰ æ­å–œï¼æ‚¨å·²å®Œæˆæ‰€æœ‰æ¡ä»¶\nç°åœ¨æ‚¨çš„ä¸‹çº§å¼€é€šVIPæ—¶ï¼Œæ‚¨å°†è·å¾—åˆ†çº¢ï¼'
    else:
        status_text += 'âš ï¸ æœªå®Œæˆçš„æ¡ä»¶ï¼š\n'
        for cond in conditions['missing_conditions']:
            status_text += f'  â€¢ {cond}\n'
        status_text += '\nğŸ’¡ å®Œæˆæ‰€æœ‰æ¡ä»¶åæ‰èƒ½è·å¾—åˆ†çº¢'
    
    await event.respond(status_text)


async def handle_my_team(event, bot, DB):
    """æŸ¥çœ‹å›¢é˜Ÿæ•°æ®"""
    telegram_id = event.sender_id
    member = DB.get_member(telegram_id)
    
    if not member:
        await event.respond('è¯·å…ˆå‘é€ /start æ³¨å†Œ')
        return
    
    if not member['is_vip']:
        await event.respond('âš ï¸ è¯·å…ˆå¼€é€šVIPæ‰èƒ½æŸ¥çœ‹å›¢é˜Ÿæ•°æ®')
        return
    
    # è·å–ä¸‹çº§æ ‘
    downline_tree = get_downline_tree(telegram_id, 10)
    
    text = 'ğŸ‘¥ æˆ‘çš„å›¢é˜Ÿæ•°æ®\n\n'
    text += f'ğŸ’ VIPçŠ¶æ€ï¼šå·²å¼€é€š\n'
    text += f'ğŸ’° å½“å‰ä½™é¢ï¼š{member["balance"]} U\n'
    text += f'ğŸ’¸ ç´¯è®¡è·å¾—ï¼š{member.get("total_earned", 0)} U\n'
    text += f'âš ï¸ ç´¯è®¡é”™è¿‡ï¼š{member["missed_balance"]} U\n\n'
    
    text += 'ğŸ“Š å›¢é˜Ÿå±‚çº§åˆ†å¸ƒï¼š\n\n'
    
    total_members = 0
    total_vip = 0
    
    for level in range(1, 11):
        if level in downline_tree:
            members = downline_tree[level]
            vip_count = sum(1 for m in members if m['is_vip'])
            total_members += len(members)
            total_vip += vip_count
            text += f'ç¬¬{level}å±‚ï¼š{len(members)}äºº (VIP:{vip_count}äºº)\n'
        else:
            text += f'ç¬¬{level}å±‚ï¼š0äºº\n'
    
    text += f'\nğŸ“ˆ å›¢é˜Ÿæ€»è®¡ï¼š{total_members}äºº\n'
    text += f'ğŸ’ VIPæ€»æ•°ï¼š{total_vip}äºº\n'
    
    await event.respond(text)


# æ·»åŠ å‘½ä»¤è¯´æ˜
COMMAND_HELP = """
ğŸ¤– ç¾¤ç»„ç®¡ç†å‘½ä»¤

/bind_group - ç»‘å®šæ‚¨çš„ç¾¤ç»„
/join_upline - æŸ¥çœ‹éœ€è¦åŠ å…¥çš„ä¸Šå±‚ç¾¤
/check_status - æ£€æŸ¥å®ŒæˆçŠ¶æ€
/my_team - æŸ¥çœ‹å›¢é˜Ÿæ•°æ®

ğŸ’¡ å®Œæˆæ‰€æœ‰æ¡ä»¶åï¼Œæ‚¨çš„ä¸‹çº§å¼€é€šVIPæ—¶
   æ‚¨å°†è·å¾— 1U åˆ†çº¢ï¼
"""
-e 

--- File: ./reset_database.py ---
#!/usr/bin/env python3
"""
æ•°æ®åº“é‡ç½®è„šæœ¬ - é‡ç½®æ•°æ®åº“å¹¶æ·»åŠ æ¡æ¼è´¦å·
âš ï¸ è­¦å‘Šï¼šæ­¤è„šæœ¬ä¼šåˆ é™¤æ‰€æœ‰æ•°æ®ï¼
"""
import os
import sys
import sqlite3
import shutil
from datetime import datetime

# æ·»åŠ é¡¹ç›®è·¯å¾„åˆ° sys.path
project_root = os.path.dirname(os.path.abspath(__file__))
sys.path.insert(0, project_root)

# ç¡®ä¿å¯ä»¥å¯¼å…¥ app æ¨¡å—
from app.config import DB_PATH, DATA_DIR
from app.database import init_db, get_db_conn, get_cn_time

def backup_database():
    """å¤‡ä»½ç°æœ‰æ•°æ®åº“"""
    if os.path.exists(DB_PATH):
        backup_path = os.path.join(DATA_DIR, f'bot_backup_{datetime.now().strftime("%Y%m%d_%H%M%S")}.db')
        shutil.copy2(DB_PATH, backup_path)
        print(f"âœ… æ•°æ®åº“å·²å¤‡ä»½åˆ°: {backup_path}")
        return backup_path
    return None

def reset_database():
    """é‡ç½®æ•°æ®åº“"""
    print("=" * 60)
    print("ğŸ—‘ï¸  å¼€å§‹é‡ç½®æ•°æ®åº“...")
    print("=" * 60)
    
    # 1. å¤‡ä»½ç°æœ‰æ•°æ®åº“
    backup_path = backup_database()
    
    # 2. åˆ é™¤ç°æœ‰æ•°æ®åº“æ–‡ä»¶
    if os.path.exists(DB_PATH):
        os.remove(DB_PATH)
        print(f"âœ… å·²åˆ é™¤ç°æœ‰æ•°æ®åº“æ–‡ä»¶: {DB_PATH}")
    
    # 3. é‡æ–°åˆå§‹åŒ–æ•°æ®åº“
    print("\nğŸ“Š é‡æ–°åˆå§‹åŒ–æ•°æ®åº“...")
    init_db()
    print("âœ… æ•°æ®åº“åˆå§‹åŒ–å®Œæˆ")
    
    return backup_path

def add_fallback_accounts():
    """æ·»åŠ æ¡æ¼è´¦å·"""
    print("\n" + "=" * 60)
    print("â• æ·»åŠ æ¡æ¼è´¦å·...")
    print("=" * 60)
    
    # æ¡æ¼è´¦å·æ•°æ®
    fallback_accounts = [
        {'telegram_id': 8889990001, 'username': 'cslb0006', 'group_link': 'https://t.me/cslb0006'},
        {'telegram_id': 8889990002, 'username': 'cslb0007', 'group_link': 'https://t.me/cslb0007'},
        {'telegram_id': 8889990003, 'username': 'cslb0008', 'group_link': 'https://t.me/cslb0008'},
        {'telegram_id': 8889990004, 'username': 'cslb0009', 'group_link': 'https://t.me/cslb0009'},
        {'telegram_id': 8889990005, 'username': 'cslb00010', 'group_link': 'https://t.me/cslb00010'},
        {'telegram_id': 8889990006, 'username': 'cslb00011', 'group_link': 'https://t.me/cslb00011'},
        {'telegram_id': 8889990007, 'username': 'cslb00012', 'group_link': 'https://t.me/cslb00012'},
        {'telegram_id': 8889990008, 'username': 'cslb00013', 'group_link': 'https://t.me/cslb00013'},
        {'telegram_id': 8889990009, 'username': 'cslb00014', 'group_link': 'https://t.me/cslb00014'},
        {'telegram_id': 88899900010, 'username': 'cslb00015', 'group_link': 'https://t.me/cslb00015'},
    ]
    
    conn = get_db_conn()
    c = conn.cursor()
    
    added_count = 0
    for account in fallback_accounts:
        try:
            # æ’å…¥æ¡æ¼è´¦å·
            c.execute('''
                INSERT INTO fallback_accounts 
                (telegram_id, username, group_link, total_earned, is_active)
                VALUES (?, ?, ?, 0, 1)
            ''', (
                account['telegram_id'],
                account['username'],
                account['group_link']
            ))
            added_count += 1
            print(f"âœ… æ·»åŠ æ¡æ¼è´¦å·: {account['telegram_id']} (@{account['username']})")
        except sqlite3.IntegrityError:
            # å¦‚æœå·²å­˜åœ¨ï¼Œæ›´æ–°ä¿¡æ¯
            c.execute('''
                UPDATE fallback_accounts 
                SET username = ?, group_link = ?, is_active = 1
                WHERE telegram_id = ?
            ''', (
                account['username'],
                account['group_link'],
                account['telegram_id']
            ))
            print(f"ğŸ”„ æ›´æ–°æ¡æ¼è´¦å·: {account['telegram_id']} (@{account['username']})")
        except Exception as e:
            print(f"âŒ æ·»åŠ æ¡æ¼è´¦å·å¤±è´¥ {account['telegram_id']}: {e}")
    
    conn.commit()
    conn.close()
    
    print(f"\nâœ… æˆåŠŸå¤„ç† {added_count} ä¸ªæ¡æ¼è´¦å·")
    return added_count

def main():
    """ä¸»å‡½æ•°"""
    print("âš ï¸" * 30)
    print("âš ï¸  è­¦å‘Šï¼šæ­¤æ“ä½œå°†åˆ é™¤æ‰€æœ‰æ•°æ®åº“æ•°æ®ï¼")
    print("âš ï¸" * 30)
    print("\næ“ä½œæ­¥éª¤ï¼š")
    print("1. å¤‡ä»½ç°æœ‰æ•°æ®åº“")
    print("2. åˆ é™¤ç°æœ‰æ•°æ®åº“")
    print("3. é‡æ–°åˆå§‹åŒ–æ•°æ®åº“")
    print("4. æ·»åŠ 10ä¸ªæ¡æ¼è´¦å·")
    print()
    
    response = input("æ˜¯å¦ç»§ç»­ï¼Ÿ(yes/no): ").strip().lower()
    
    if response != 'yes':
        print("âŒ æ“ä½œå·²å–æ¶ˆ")
        return
    
    try:
        # é‡ç½®æ•°æ®åº“
        backup_path = reset_database()
        
        # æ·»åŠ æ¡æ¼è´¦å·
        add_fallback_accounts()
        
        print("\n" + "=" * 60)
        print("âœ… æ•°æ®åº“é‡ç½®å®Œæˆï¼")
        print("=" * 60)
        if backup_path:
            print(f"ğŸ“¦ å¤‡ä»½æ–‡ä»¶: {backup_path}")
        print("\nğŸ’¡ æç¤ºï¼š")
        print("   - æ•°æ®åº“å·²é‡ç½®å¹¶åˆå§‹åŒ–")
        print("   - å·²æ·»åŠ 10ä¸ªæ¡æ¼è´¦å·")
        print("   - é»˜è®¤ç®¡ç†å‘˜è´¦å·: admin / admin")
        print("   - è¯·é‡å¯åº”ç”¨ä»¥ç”Ÿæ•ˆ")
        print("=" * 60)
        
    except Exception as e:
        print(f"\nâŒ æ“ä½œå¤±è´¥: {e}")
        import traceback
        traceback.print_exc()
        if backup_path and os.path.exists(backup_path):
            print(f"\nğŸ’¡ å¯ä»¥ä»å¤‡ä»½æ¢å¤: {backup_path}")

if __name__ == '__main__':
    main()

-e 

--- File: ./add_fallback_accounts.py ---
#!/usr/bin/env python3
"""
æ·»åŠ æ¡æ¼è´¦å·è„šæœ¬ - ä»…æ·»åŠ æ¡æ¼è´¦å·ï¼Œä¸é‡ç½®æ•°æ®åº“
"""
import os
import sys
import sqlite3

# æ·»åŠ é¡¹ç›®è·¯å¾„åˆ° sys.path
project_root = os.path.dirname(os.path.abspath(__file__))
sys.path.insert(0, project_root)

# ç¡®ä¿å¯ä»¥å¯¼å…¥ app æ¨¡å—
from app.database import get_db_conn

def add_fallback_accounts():
    """æ·»åŠ æ¡æ¼è´¦å·"""
    print("=" * 60)
    print("â• æ·»åŠ æ¡æ¼è´¦å·...")
    print("=" * 60)
    
    # æ¡æ¼è´¦å·æ•°æ®
    fallback_accounts = [
        {'telegram_id': 8889990001, 'username': 'cslb0006', 'group_link': 'https://t.me/cslb0006'},
        {'telegram_id': 8889990002, 'username': 'cslb0007', 'group_link': 'https://t.me/cslb0007'},
        {'telegram_id': 8889990003, 'username': 'cslb0008', 'group_link': 'https://t.me/cslb0008'},
        {'telegram_id': 8889990004, 'username': 'cslb0009', 'group_link': 'https://t.me/cslb0009'},
        {'telegram_id': 8889990005, 'username': 'cslb00010', 'group_link': 'https://t.me/cslb00010'},
        {'telegram_id': 8889990006, 'username': 'cslb00011', 'group_link': 'https://t.me/cslb00011'},
        {'telegram_id': 8889990007, 'username': 'cslb00012', 'group_link': 'https://t.me/cslb00012'},
        {'telegram_id': 8889990008, 'username': 'cslb00013', 'group_link': 'https://t.me/cslb00013'},
        {'telegram_id': 8889990009, 'username': 'cslb00014', 'group_link': 'https://t.me/cslb00014'},
        {'telegram_id': 88899900010, 'username': 'cslb00015', 'group_link': 'https://t.me/cslb00015'},
    ]
    
    conn = get_db_conn()
    c = conn.cursor()
    
    added_count = 0
    updated_count = 0
    error_count = 0
    
    for account in fallback_accounts:
        try:
            # æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨
            c.execute('SELECT id FROM fallback_accounts WHERE telegram_id = ?', (account['telegram_id'],))
            existing = c.fetchone()
            
            if existing:
                # æ›´æ–°ç°æœ‰è´¦å·
                c.execute('''
                    UPDATE fallback_accounts 
                    SET username = ?, group_link = ?, is_active = 1
                    WHERE telegram_id = ?
                ''', (
                    account['username'],
                    account['group_link'],
                    account['telegram_id']
                ))
                updated_count += 1
                print(f"ğŸ”„ æ›´æ–°æ¡æ¼è´¦å·: {account['telegram_id']} (@{account['username']})")
            else:
                # æ’å…¥æ–°è´¦å·
                c.execute('''
                    INSERT INTO fallback_accounts 
                    (telegram_id, username, group_link, total_earned, is_active)
                    VALUES (?, ?, ?, 0, 1)
                ''', (
                    account['telegram_id'],
                    account['username'],
                    account['group_link']
                ))
                added_count += 1
                print(f"âœ… æ·»åŠ æ¡æ¼è´¦å·: {account['telegram_id']} (@{account['username']})")
        except Exception as e:
            error_count += 1
            print(f"âŒ å¤„ç†æ¡æ¼è´¦å·å¤±è´¥ {account['telegram_id']}: {e}")
    
    conn.commit()
    conn.close()
    
    print("\n" + "=" * 60)
    print(f"âœ… å®Œæˆï¼")
    print(f"   - æ–°å¢: {added_count} ä¸ª")
    print(f"   - æ›´æ–°: {updated_count} ä¸ª")
    print(f"   - å¤±è´¥: {error_count} ä¸ª")
    print("=" * 60)

if __name__ == '__main__':
    add_fallback_accounts()

-e 

--- File: ./scripts/deploy_check.py ---
#!/usr/bin/env python3
"""
éƒ¨ç½²ç¯å¢ƒæ£€æŸ¥è„šæœ¬
ç”¨äºæ£€æŸ¥éƒ¨ç½²ç¯å¢ƒæ˜¯å¦æ»¡è¶³è¦æ±‚
"""

import sys
import os
import subprocess

def check_python_version():
    """æ£€æŸ¥Pythonç‰ˆæœ¬"""
    print("=" * 60)
    print("ğŸ“¦ æ£€æŸ¥ Python ç‰ˆæœ¬...")
    version = sys.version_info
    if version.major >= 3 and version.minor >= 7:
        print(f"âœ… Python {version.major}.{version.minor}.{version.micro} - ç¬¦åˆè¦æ±‚")
        return True
    else:
        print(f"âŒ Python {version.major}.{version.minor}.{version.micro} - éœ€è¦ Python 3.7+")
        return False

def check_dependencies():
    """æ£€æŸ¥ä¾èµ–åŒ…"""
    print("\n" + "=" * 60)
    print("ğŸ“¦ æ£€æŸ¥ä¾èµ–åŒ…...")
    
    required_packages = {
        'flask': 'Flask',
        'telethon': 'Telethon',
        'requests': 'requests',
        'werkzeug': 'werkzeug',
        'qrcode': 'qrcode',
        'PIL': 'Pillow',
        'flask_login': 'flask-login'
    }
    
    missing = []
    for module, package in required_packages.items():
        try:
            __import__(module)
            print(f"âœ… {package} - å·²å®‰è£…")
        except ImportError:
            print(f"âŒ {package} - æœªå®‰è£…")
            missing.append(package)
    
    if missing:
        print(f"\nâš ï¸  ç¼ºå°‘ä»¥ä¸‹ä¾èµ–åŒ…: {', '.join(missing)}")
        print("   è¯·è¿è¡Œ: pip3 install -r requirements.txt")
        return False
    return True

def check_files():
    """æ£€æŸ¥å¿…éœ€æ–‡ä»¶"""
    print("\n" + "=" * 60)
    print("ğŸ“ æ£€æŸ¥é¡¹ç›®æ–‡ä»¶...")
    
    required_files = [
        'a.py',
        'requirements.txt',
        'start.sh',
        'stop.sh',
        'core_functions.py',
        'bot_commands_addon.py'
    ]
    
    missing = []
    for file in required_files:
        if os.path.exists(file):
            print(f"âœ… {file} - å­˜åœ¨")
        else:
            print(f"âŒ {file} - ä¸å­˜åœ¨")
            missing.append(file)
    
    if missing:
        print(f"\nâš ï¸  ç¼ºå°‘ä»¥ä¸‹æ–‡ä»¶: {', '.join(missing)}")
        return False
    return True

def check_directories():
    """æ£€æŸ¥å¿…éœ€ç›®å½•"""
    print("\n" + "=" * 60)
    print("ğŸ“‚ æ£€æŸ¥é¡¹ç›®ç›®å½•...")
    
    required_dirs = [
        'templates',
        'static'
    ]
    
    missing = []
    for dir_name in required_dirs:
        if os.path.exists(dir_name) and os.path.isdir(dir_name):
            print(f"âœ… {dir_name}/ - å­˜åœ¨")
        else:
            print(f"âŒ {dir_name}/ - ä¸å­˜åœ¨")
            missing.append(dir_name)
    
    if missing:
        print(f"\nâš ï¸  ç¼ºå°‘ä»¥ä¸‹ç›®å½•: {', '.join(missing)}")
        return False
    return True

def check_config():
    """æ£€æŸ¥é…ç½®æ–‡ä»¶"""
    print("\n" + "=" * 60)
    print("âš™ï¸  æ£€æŸ¥é…ç½®æ–‡ä»¶...")
    
    try:
        with open('a.py', 'r', encoding='utf-8') as f:
            content = f.read()
        
        checks = {
            'API_ID': 'API_ID = ' in content,
            'API_HASH': 'API_HASH = ' in content,
            'BOT_TOKEN': 'BOT_TOKEN = ' in content,
            'ADMIN_IDS': 'ADMIN_IDS = ' in content,
        }
        
        all_ok = True
        for key, exists in checks.items():
            if exists:
                # æ£€æŸ¥æ˜¯å¦ä¸ºé»˜è®¤å€¼ï¼ˆéœ€è¦ç”¨æˆ·ä¿®æ”¹ï¼‰
                if key == 'API_ID' and '21332425' in content:
                    print(f"âš ï¸  {key} - å­˜åœ¨ä½†å¯èƒ½æ˜¯é»˜è®¤å€¼ï¼Œè¯·ç¡®è®¤å·²ä¿®æ”¹")
                elif key == 'BOT_TOKEN' and '8282974213:AAEISGP5ijUbJSBMA9N5eoygWjAB266-1UE' in content:
                    print(f"âš ï¸  {key} - å­˜åœ¨ä½†å¯èƒ½æ˜¯é»˜è®¤å€¼ï¼Œè¯·ç¡®è®¤å·²ä¿®æ”¹")
                else:
                    print(f"âœ… {key} - å·²é…ç½®")
            else:
                print(f"âŒ {key} - æœªæ‰¾åˆ°")
                all_ok = False
        
        return all_ok
    except Exception as e:
        print(f"âŒ æ— æ³•è¯»å–é…ç½®æ–‡ä»¶: {e}")
        return False

def check_permissions():
    """æ£€æŸ¥æ–‡ä»¶æƒé™"""
    print("\n" + "=" * 60)
    print("ğŸ” æ£€æŸ¥æ–‡ä»¶æƒé™...")
    
    files_to_check = ['start.sh', 'stop.sh']
    all_ok = True
    
    for file in files_to_check:
        if os.path.exists(file):
            if os.access(file, os.X_OK):
                print(f"âœ… {file} - æœ‰æ‰§è¡Œæƒé™")
            else:
                print(f"âš ï¸  {file} - æ— æ‰§è¡Œæƒé™ï¼Œè¿è¡Œ: chmod +x {file}")
                all_ok = False
        else:
            print(f"âš ï¸  {file} - ä¸å­˜åœ¨")
    
    return all_ok

def check_database():
    """æ£€æŸ¥æ•°æ®åº“"""
    print("\n" + "=" * 60)
    print("ğŸ’¾ æ£€æŸ¥æ•°æ®åº“...")
    
    if os.path.exists('bot.db'):
        size = os.path.getsize('bot.db')
        print(f"âœ… bot.db - å­˜åœ¨ ({size} å­—èŠ‚)")
        
        # æ£€æŸ¥æ˜¯å¦å¯è¯»å†™
        try:
            import sqlite3
            conn = sqlite3.connect('bot.db')
            conn.execute('SELECT 1')
            conn.close()
            print("âœ… æ•°æ®åº“å¯æ­£å¸¸è®¿é—®")
            return True
        except Exception as e:
            print(f"âŒ æ•°æ®åº“æ— æ³•è®¿é—®: {e}")
            return False
    else:
        print("â„¹ï¸  bot.db - ä¸å­˜åœ¨ï¼ˆé¦–æ¬¡è¿è¡Œä¼šè‡ªåŠ¨åˆ›å»ºï¼‰")
        return True

def check_port():
    """æ£€æŸ¥ç«¯å£å ç”¨"""
    print("\n" + "=" * 60)
    print("ğŸ”Œ æ£€æŸ¥ç«¯å£ 5051...")
    
    try:
        import socket
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        result = sock.connect_ex(('127.0.0.1', 5051))
        sock.close()
        
        if result == 0:
            print("âš ï¸  ç«¯å£ 5051 å·²è¢«å ç”¨")
            print("   å¦‚æœæœåŠ¡æ­£åœ¨è¿è¡Œï¼Œè¿™æ˜¯æ­£å¸¸çš„")
            return True
        else:
            print("âœ… ç«¯å£ 5051 å¯ç”¨")
            return True
    except Exception as e:
        print(f"âš ï¸  æ— æ³•æ£€æŸ¥ç«¯å£: {e}")
        return True

def main():
    """ä¸»å‡½æ•°"""
    print("\n" + "=" * 60)
    print("ğŸ” è£‚å˜æ¨å¹¿æœºå™¨äºº - éƒ¨ç½²ç¯å¢ƒæ£€æŸ¥")
    print("=" * 60)
    
    results = []
    
    results.append(("Pythonç‰ˆæœ¬", check_python_version()))
    results.append(("ä¾èµ–åŒ…", check_dependencies()))
    results.append(("é¡¹ç›®æ–‡ä»¶", check_files()))
    results.append(("é¡¹ç›®ç›®å½•", check_directories()))
    results.append(("é…ç½®æ–‡ä»¶", check_config()))
    results.append(("æ–‡ä»¶æƒé™", check_permissions()))
    results.append(("æ•°æ®åº“", check_database()))
    results.append(("ç«¯å£", check_port()))
    
    # æ€»ç»“
    print("\n" + "=" * 60)
    print("ğŸ“Š æ£€æŸ¥ç»“æœæ€»ç»“")
    print("=" * 60)
    
    passed = sum(1 for _, result in results if result)
    total = len(results)
    
    for name, result in results:
        status = "âœ… é€šè¿‡" if result else "âŒ å¤±è´¥"
        print(f"{name}: {status}")
    
    print("\n" + "=" * 60)
    if passed == total:
        print("ğŸ‰ æ‰€æœ‰æ£€æŸ¥é€šè¿‡ï¼å¯ä»¥å¼€å§‹éƒ¨ç½²äº†ã€‚")
        print("\nä¸‹ä¸€æ­¥ï¼š")
        print("1. ç¡®è®¤ a.py ä¸­çš„é…ç½®å·²æ­£ç¡®ä¿®æ”¹")
        print("2. è¿è¡Œ: ./start.sh å¯åŠ¨æœåŠ¡")
        print("3. è®¿é—®: http://ä½ çš„IP:5051 ç™»å½•ç®¡ç†åå°")
    else:
        print(f"âš ï¸  æœ‰ {total - passed} é¡¹æ£€æŸ¥æœªé€šè¿‡ï¼Œè¯·å…ˆè§£å†³è¿™äº›é—®é¢˜ã€‚")
        print("\nè¯·å‚è€ƒ éƒ¨ç½²æŒ‡å—.md è·å–è¯¦ç»†å¸®åŠ©ã€‚")
    print("=" * 60 + "\n")
    
    return passed == total

if __name__ == '__main__':
    success = main()
    sys.exit(0 if success else 1)

-e 

--- File: ./cleanup_database.py ---
#!/usr/bin/env python3
"""
æ•°æ®åº“æ¸…ç†è„šæœ¬ - æ¸…ç†å¹½çµç”¨æˆ·å’Œæ— æ•ˆæ•°æ®
æ‰§è¡Œå‰è¯·å…ˆå¤‡ä»½æ•°æ®åº“ï¼
"""
import sqlite3
import sys
import os

# æ·»åŠ é¡¹ç›®è·¯å¾„
sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))
from app.config import DB_PATH

def cleanup_database():
    """æ¸…ç†æ•°æ®åº“ä¸­çš„è„æ•°æ®"""
    print("=" * 60)
    print("å¼€å§‹æ¸…ç†æ•°æ®åº“è„æ•°æ®...")
    print("=" * 60)
    
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    
    try:
        # 1. åˆ é™¤æ— æ•ˆçš„å¹½çµç”¨æˆ·
        print("\n1. åˆ é™¤æ— æ•ˆçš„å¹½çµç”¨æˆ·...")
        # å…ˆæŸ¥è¯¢ä¸€ä¸‹æœ‰å¤šå°‘æ— æ•ˆç”¨æˆ·
        c.execute("""
            SELECT COUNT(*) FROM members 
            WHERE telegram_id IS NULL 
               OR telegram_id = 'None' 
               OR CAST(telegram_id AS TEXT) = 'None'
               OR username = 'fallback_None'
               OR username LIKE 'fallback_%None%'
        """)
        count_before = c.fetchone()[0]
        print(f"   å‘ç° {count_before} ä¸ªå¯ç–‘çš„æ— æ•ˆç”¨æˆ·")
        
        c.execute("""
            DELETE FROM members 
            WHERE telegram_id IS NULL 
               OR telegram_id = 'None' 
               OR CAST(telegram_id AS TEXT) = 'None'
               OR username = 'fallback_None'
               OR username LIKE 'fallback_%None%'
        """)
        deleted_members = c.rowcount
        print(f"   å·²åˆ é™¤ {deleted_members} ä¸ªæ— æ•ˆç”¨æˆ·")
        
        # 2. åˆ é™¤å…³è”çš„é”™è¯¯æ”¶ç›Šè®°å½•
        print("\n2. åˆ é™¤å…³è”çš„é”™è¯¯æ”¶ç›Šè®°å½•...")
        c.execute("""
            DELETE FROM earnings_records 
            WHERE member_id IS NULL 
               OR member_id = 'None'
               OR CAST(member_id AS TEXT) = 'None'
        """)
        deleted_earnings = c.rowcount
        print(f"   å·²åˆ é™¤ {deleted_earnings} æ¡æ— æ•ˆæ”¶ç›Šè®°å½•")
        
        # 3. æ£€æŸ¥å¹¶æ¸…ç†æ— æ•ˆçš„å……å€¼è®°å½•
        print("\n3. æ£€æŸ¥æ— æ•ˆçš„å……å€¼è®°å½•...")
        c.execute("""
            DELETE FROM recharge_records 
            WHERE member_id IS NULL 
               OR member_id = 'None'
               OR CAST(member_id AS TEXT) = 'None'
        """)
        deleted_recharges = c.rowcount
        print(f"   å·²åˆ é™¤ {deleted_recharges} æ¡æ— æ•ˆå……å€¼è®°å½•")
        
        # 4. æ£€æŸ¥å¹¶æ¸…ç†æ— æ•ˆçš„æç°è®°å½•
        print("\n4. æ£€æŸ¥æ— æ•ˆçš„æç°è®°å½•...")
        # æ£€æŸ¥è¡¨æ˜¯å¦å­˜åœ¨
        c.execute("SELECT name FROM sqlite_master WHERE type='table' AND name='withdrawals'")
        table_exists = c.fetchone()
        if table_exists:
            c.execute("""
                DELETE FROM withdrawals 
                WHERE member_id IS NULL 
                   OR member_id = 'None'
                   OR CAST(member_id AS TEXT) = 'None'
            """)
            deleted_withdrawals = c.rowcount
            print(f"   å·²åˆ é™¤ {deleted_withdrawals} æ¡æ— æ•ˆæç°è®°å½•")
        else:
            print("   è¡¨ 'withdrawals' ä¸å­˜åœ¨ï¼Œè·³è¿‡")
            deleted_withdrawals = 0
        
        # æäº¤æ›´æ”¹
        conn.commit()
        
        print("\n" + "=" * 60)
        print("æ•°æ®åº“æ¸…ç†å®Œæˆï¼")
        print("=" * 60)
        print(f"æ€»è®¡åˆ é™¤:")
        print(f"  - æ— æ•ˆç”¨æˆ·: {deleted_members} ä¸ª")
        print(f"  - æ— æ•ˆæ”¶ç›Šè®°å½•: {deleted_earnings} æ¡")
        print(f"  - æ— æ•ˆå……å€¼è®°å½•: {deleted_recharges} æ¡")
        print(f"  - æ— æ•ˆæç°è®°å½•: {deleted_withdrawals} æ¡")
        print("=" * 60)
        
    except Exception as e:
        print(f"\nâŒ æ¸…ç†è¿‡ç¨‹ä¸­å‘ç”Ÿé”™è¯¯: {e}")
        import traceback
        traceback.print_exc()
        conn.rollback()
    finally:
        conn.close()

if __name__ == '__main__':
    print("âš ï¸  è­¦å‘Šï¼šæ­¤è„šæœ¬å°†åˆ é™¤æ•°æ®åº“ä¸­çš„æ— æ•ˆæ•°æ®ï¼")
    print("âš ï¸  è¯·ç¡®ä¿å·²å¤‡ä»½æ•°æ®åº“ï¼")
    response = input("\næ˜¯å¦ç»§ç»­ï¼Ÿ(yes/no): ")
    
    if response.lower() == 'yes':
        cleanup_database()
    else:
        print("å·²å–æ¶ˆæ“ä½œã€‚")

-e 

--- File: ./main.py ---
"""
å¯åŠ¨å…¥å£ - ç»Ÿä¸€å¯åŠ¨Botå’ŒWebåå°
"""
import threading
from app.database import init_db, sync_member_groups_from_members
from app.bot_logic import run_bot

def main():
    print("=" * 60)
    print("ğŸ¤– è£‚å˜æ¨å¹¿æœºå™¨äººç³»ç»Ÿå¯åŠ¨ä¸­...")
    print("=" * 60)
    print()
    
    # 1. åˆå§‹åŒ–æ•°æ®åº“
    print("ğŸ“Š åˆå§‹åŒ–æ•°æ®åº“...")
    init_db()
    print("âœ… æ•°æ®åº“åˆå§‹åŒ–å®Œæˆ")
    
    # åŒæ­¥å·²æœ‰ä¼šå‘˜ç¾¤é“¾æ¥åˆ° member_groups
    print("ğŸ”„ åŒæ­¥ä¼šå‘˜ç¾¤ç»„æ•°æ®...")
    try:
        sync_member_groups_from_members()
        print("âœ… ä¼šå‘˜ç¾¤ç»„æ•°æ®åŒæ­¥å®Œæˆ")
    except Exception as e:
        print(f"âš ï¸ ä¼šå‘˜ç¾¤ç»„æ•°æ®åŒæ­¥å¤±è´¥: {e}")
    print()
    
    # 2. å¯åŠ¨ Web åå° (åœ¨ç‹¬ç«‹çº¿ç¨‹ä¸­)
    print("ğŸŒ å¯åŠ¨Webç®¡ç†åå°...")
    try:
        from web_app import run_web
        web_thread = threading.Thread(target=run_web, daemon=True)
        web_thread.start()
        print("âœ… Webç®¡ç†åå°å·²å¯åŠ¨ (ç«¯å£: 5051)")
    except Exception as e:
        print(f"âš ï¸ Webåå°å¯åŠ¨å¤±è´¥: {e}")
        print("ç»§ç»­å¯åŠ¨Bot...")
    print()
    
    # 3. å¯åŠ¨ Bot (ä¸»çº¿ç¨‹)
    print("ğŸš€ Telegramæœºå™¨äººå¯åŠ¨ä¸­...")
    print()
    print("=" * 60)
    print("ğŸ“± è®¿é—®åœ°å€ï¼š")
    print("   Webåå°: http://localhost:5051")
    print("=" * 60)
    print()
    print("ğŸ’¡ æç¤ºï¼š")
    print("   - æ‰€æœ‰æœåŠ¡æ­£åœ¨è¿è¡Œä¸­...")
    print("   - æŒ‰ Ctrl+C åœæ­¢æ‰€æœ‰æœåŠ¡")
    print("=" * 60)
    print()
    
    try:
        run_bot()
    except KeyboardInterrupt:
        print("\nåœæ­¢æœåŠ¡...")
    except Exception as e:
        print(f"âŒ å¯åŠ¨å¤±è´¥: {e}")
        import traceback
        traceback.print_exc()

if __name__ == '__main__':
    main()

-e 

