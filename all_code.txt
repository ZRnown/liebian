--- File: ./app/bot_logic.py ---
"""
æœºå™¨äººé€»è¾‘å±‚ - ç»Ÿä¸€ç®¡ç†æ‰€æœ‰Telegramæœºå™¨äººäº¤äº’
ã€æ ¸å¿ƒä¿®å¤ã€‘æ‰€æœ‰VIPå¼€é€šè·¯å¾„éƒ½è°ƒç”¨ distribute_vip_rewardsï¼Œåˆ é™¤å†—ä½™çš„æ‰‹å†™åˆ†çº¢é€»è¾‘
"""
from .payment import create_recharge_order, PAYMENT_CONFIG, generate_payment_sign
from .config import SESSION_DIR
import asyncio
import sqlite3
import time
import os
from urllib.parse import quote  # ã€æ–°å¢ã€‘ç”¨äºURLç¼–ç æ¨å¹¿æ–‡æ¡ˆ
from datetime import datetime, timedelta, timezone
from telethon import TelegramClient, events, Button
from telethon.sessions import MemorySession
from telethon.tl.types import (
    ChannelParticipantsAdmins,
    UpdateChannelParticipant,
    UpdateChatParticipantAdmin,
    UpdateChatParticipant,
    ChannelParticipantAdmin,
    ChannelParticipantCreator)
from telethon.tl.functions.channels import GetParticipantRequest
import socks

from .config import (
    API_ID, API_HASH, ADMIN_IDS, USE_PROXY,
    PROXY_TYPE, PROXY_HOST, PROXY_PORT, DATA_DIR
)
from .database import DB, get_cn_time, get_system_config, get_db_conn
from .core_functions import (
    get_upline_chain, check_user_conditions, update_level_path,
    distribute_vip_rewards, check_user_in_group, check_bot_is_admin,
    verify_group_link, check_any_bot_in_group
)
from .bot_commands_addon import (
    handle_bind_group, handle_join_upline, handle_group_link_message,
    handle_check_status, handle_my_team
)


def compute_vip_price_from_config(config):
    """è®¡ç®—VIPä»·æ ¼ (é€»è¾‘åŒæ­¥Webç«¯)"""
    try:
        level_count = int(config.get('level_count', 10))
        # é»˜è®¤å€¼é˜²æ­¢ä¸º0
        default_reward = float(config.get('level_reward', 1.0))
        if default_reward <= 0:
            default_reward = 1.0

        level_amounts = config.get('level_amounts')
        if level_amounts:
            import json
            try:
                if isinstance(level_amounts, str):
                    parsed = json.loads(level_amounts)
                else:
                    parsed = level_amounts
            except BaseException:
                parsed = None

            if isinstance(parsed, list):
                vals = []
                last_val = default_reward
                for x in parsed[:level_count]:
                    try:
                        v = float(x)
                        if v > 0:
                            last_val = v
                    except BaseException:
                        v = last_val
                    vals.append(v)
                # è¡¥é½
                if len(vals) < level_count:
                    vals += [last_val] * (level_count - len(vals))
                return sum(vals)
            elif isinstance(parsed, dict):
                total = 0.0
                for i in range(1, level_count + 1):
                    v = parsed.get(str(i)) or parsed.get(i) or default_reward
                    total += float(v)
                return total

        # é»˜è®¤è¿”å›å›ºå®šä»·æ ¼
        return default_reward * level_count
    except Exception as e:
        print(f'[VIPä»·æ ¼è®¡ç®—] é”™è¯¯: {e}')
        return 10.0  # é»˜è®¤ä»·æ ¼


# æŒ‰é’®æ–‡å­—å¸¸é‡
BTN_PROFILE = 'ğŸ‘¤ ä¸ªäººä¸­å¿ƒ'
BTN_FISSION = 'ğŸ”— ç¾¤è£‚å˜åŠ å…¥'
BTN_VIEW_FISSION = 'ğŸ“Š æˆ‘çš„è£‚å˜'
BTN_RESOURCES = 'ğŸ“ è¡Œä¸šèµ„æº'
BTN_PROMOTE = 'ğŸ’° èµšé’±æ¨å¹¿'
BTN_SUPPORT = 'ğŸ‘©â€ğŸ’¼ åœ¨çº¿å®¢æœ'
BTN_BACK = 'ğŸ”™ è¿”å›ä¸»èœå•'
BTN_ADMIN = 'âš™ï¸ ç®¡ç†åå°'
BTN_VIP = 'ğŸ’ å¼€é€šä¼šå‘˜'
BTN_MY_PROMOTE = 'ğŸ’« æˆ‘çš„æ¨å¹¿'
BTN_EARNINGS = 'ğŸ“Š æ”¶ç›Šè®°å½•'


async def send_vip_required_prompt(event_or_id, reply_method='respond'):
    """ç»™æœªå¼€é€šVIPçš„ç”¨æˆ·å‘é€ç»Ÿä¸€æç¤ºæ–‡æ¡ˆï¼Œæ”¯æŒ event æˆ– telegram_id"""
    try:
        if isinstance(event_or_id, int):
            telegram_id = event_or_id
            member = DB.get_member(telegram_id)
            client = bot  # é»˜è®¤ä½¿ç”¨ä¸»botå‘é€ä¸»åŠ¨æ¶ˆæ¯
        else:
            original = event_or_id
            client = original.client  # ä½¿ç”¨è§¦å‘äº‹ä»¶çš„é‚£ä¸ªæœºå™¨äººå®ä¾‹
            try:
                original_sender_id = original.sender_id
                original.sender_id = get_main_account_id(
                    original_sender_id, getattr(
                        original.sender, 'username', None))
            except Exception:
                pass
            member = DB.get_member(original.sender_id)
            telegram_id = original.sender_id

        config = get_system_config()
        # ä¼˜å…ˆä»é…ç½®è®¡ç®—VIPæ€»ä»·ï¼Œç¡®ä¿å’Œå±‚çº§è®¾ç½®ä¸€è‡´
        vip_price = compute_vip_price_from_config(config)
        balance = member['balance'] if member else 0

        # ã€ä¿®å¤ã€‘æ›´æ–°æ–‡æ¡ˆæ ¼å¼
        text = "æŠ±æ­‰ æ‚¨è¿˜ä¸æ˜¯VIP\n\n"
        text += "ä¸èƒ½ä½¿ç”¨æ­¤åŠŸèƒ½ è¯·å…ˆå¼€é€šVIP\n"
        text += "ç‚¹å‡»ä¸‹æ–¹ã€Œå¼€é€šVIPã€æŒ‰é’® å¼€é€šåœ¨æ¥å“¦\n\n"
        text += f"ğŸ’° VIPä»·æ ¼: {vip_price} U\n"
        text += f"ğŸ’µ å½“å‰ä½™é¢: {balance} U\n"

        buttons = []
        # å¦‚æœä½™é¢è¶³å¤Ÿï¼Œæä¾›ä½™é¢å¼€é€šæŒ‰é’®ï¼›å¦åˆ™åªæä¾›å……å€¼å…¥å£
        if balance >= vip_price:
            buttons = [[Button.inline('ğŸ’ ä½™é¢å¼€é€šVIP', b'open_vip_balance')]]
        else:
            # è®¡ç®—å·®é¢
            need = vip_price - balance
            text += f"\n\nâŒ ä½™é¢ä¸è¶³ï¼Œè¯·å…ˆå……å€¼"
            buttons = [[Button.inline(f'ğŸ’³ å……å€¼å¼€é€šVIP', b'recharge_for_vip')]]

        if isinstance(event_or_id, int):
            try:
                if client:
                    await client.send_message(telegram_id, text, buttons=buttons)
            except Exception:
                pass
        else:
            # event-like
            try:
                if reply_method == 'respond':
                    await event_or_id.respond(text, buttons=buttons)
                else:
                    await event_or_id.answer(text, alert=True)
            except Exception:
                try:
                    await event_or_id.answer(text, alert=True)
                except Exception:
                    pass
    except Exception as e:
        print(f"[VIPæç¤º] å‘é€å¤±è´¥: {e}")

# ==================== å¤šæœºå™¨äººåˆå§‹åŒ–é€»è¾‘ ====================


def get_active_bot_tokens():
    """è·å–æ‰€æœ‰æ´»è·ƒçš„æœºå™¨äººtoken"""
    try:
        conn = get_db_conn()
        c = conn.cursor()
        c.execute(
            'SELECT id, bot_token FROM bot_configs WHERE is_active = 1 ORDER BY id ASC')
        rows = c.fetchall()
        conn.close()
        # è¿”å› (id, token) åˆ—è¡¨
        tokens = [(row[0], row[1]) for row in rows if row[1]]
        print(f"[æœºå™¨äººåˆå§‹åŒ–] æ‰¾åˆ° {len(tokens)} ä¸ªæ´»è·ƒæœºå™¨äººtoken")
        return tokens
    except Exception as e:
        print(f"[æœºå™¨äººåˆå§‹åŒ–] è·å–æ´»è·ƒtokenå¤±è´¥: {e}")
        return []


# åˆå§‹åŒ–å®¢æˆ·ç«¯åˆ—è¡¨
clients = []
active_tokens = get_active_bot_tokens()

registered_handlers = []

# æƒé™æ£€æŸ¥æ§åˆ¶å˜é‡
permission_check_triggered = False

# å¦‚æœæ•°æ®åº“æ²¡é…ç½®ï¼Œå°è¯•è¯»å–ç¯å¢ƒå˜é‡é…ç½®ä½œä¸ºé»˜è®¤
if not active_tokens:
    from .config import BOT_TOKEN
    if BOT_TOKEN:
        print("[æœºå™¨äººåˆå§‹åŒ–] æ•°æ®åº“æ— é…ç½®ï¼Œä½¿ç”¨é»˜è®¤é…ç½®æ–‡ä»¶Token")
        active_tokens.append((0, BOT_TOKEN))
    else:
        print("[æœºå™¨äººåˆå§‹åŒ–] âŒ é”™è¯¯ï¼šæ²¡æœ‰æ‰¾åˆ°ä»»ä½•æœºå™¨äººé…ç½®ï¼")

# ä»£ç†è®¾ç½®
proxy = None
if USE_PROXY:
    if PROXY_TYPE.lower() == 'socks5':
        proxy = (socks.SOCKS5, PROXY_HOST, PROXY_PORT)
    elif PROXY_TYPE.lower() == 'socks4':
        proxy = (socks.SOCKS4, PROXY_HOST, PROXY_PORT)
    elif PROXY_TYPE.lower() == 'http':
        proxy = (socks.HTTP, PROXY_HOST, PROXY_PORT)
    else:
        proxy = (socks.SOCKS5, PROXY_HOST, PROXY_PORT)

# ç¡®ä¿ session ç›®å½•å­˜åœ¨
os.makedirs(SESSION_DIR, exist_ok=True)

# åˆ›å»ºæ‰€æœ‰æœºå™¨äººå®¢æˆ·ç«¯
for db_id, token in active_tokens:
    try:
        # ã€å…³é”®ä¿®å¤ã€‘ä½¿ç”¨ç‹¬ç«‹çš„ Session æ–‡ä»¶åï¼Œé˜²æ­¢å†²çª
        # ä½¿ç”¨æ•°æ®åº“IDä½œä¸ºåŒºåˆ†ï¼ŒIDä¸º0çš„æ˜¯é…ç½®æ–‡ä»¶é»˜è®¤Bot
        session_name = f'bot_{db_id}'
        session_path = os.path.join(SESSION_DIR, session_name)

        print(f"[æœºå™¨äººåˆå§‹åŒ–] æ­£åœ¨å¯åŠ¨ Bot ID {db_id} (Session: {session_name})...")

        # ã€æ–°å¢ã€‘æ·»åŠ é‡è¯•æœºåˆ¶ï¼Œè§£å†³ç½‘ç»œè¿æ¥é—®é¢˜
        max_retries = 3
        for attempt in range(max_retries):
            try:
                client = TelegramClient(
                    session_path, API_ID, API_HASH, proxy=proxy)
                # å¯åŠ¨å®¢æˆ·ç«¯ï¼Œè®¾ç½®è¾ƒé•¿çš„è¶…æ—¶æ—¶é—´
                client.start(bot_token=token)
                clients.append(client)
                print(
                    f"[æœºå™¨äººåˆå§‹åŒ–] âœ… æˆåŠŸå¯åŠ¨: {token[:10]}... (å°è¯• {attempt + 1}/{max_retries})")
                break  # æˆåŠŸå¯åŠ¨ï¼Œè·³å‡ºé‡è¯•å¾ªç¯
            except Exception as retry_e:
                print(f"[æœºå™¨äººåˆå§‹åŒ–] å°è¯• {attempt + 1}/{max_retries} å¤±è´¥: {retry_e}")
                if attempt == max_retries - 1:
                    raise retry_e  # æœ€åä¸€æ¬¡å°è¯•å¤±è´¥ï¼ŒæŠ›å‡ºå¼‚å¸¸
                import time
                time.sleep(2)  # ç­‰å¾…2ç§’åé‡è¯•

    except Exception as e:
        print(f"[æœºå™¨äººåˆå§‹åŒ–] âŒ å¯åŠ¨å¤±è´¥ (ID: {db_id}): {e}")
        print(f"[æœºå™¨äººåˆå§‹åŒ–] ğŸ”„ å°†è·³è¿‡æ­¤æœºå™¨äººï¼Œç»§ç»­å¯åŠ¨å…¶ä»–æœºå™¨äºº...")

if not clients:
    print("[æœºå™¨äººåˆå§‹åŒ–] âŒ ä¸¥é‡é”™è¯¯ï¼šæ— æ³•å¯åŠ¨ä»»ä½•æœºå™¨äºº")
    print("[æœºå™¨äººåˆå§‹åŒ–] ğŸ’¡ Webç®¡ç†åå°ä»å¯æ­£å¸¸ä½¿ç”¨ï¼Œè¯·æ£€æŸ¥æœºå™¨äººTokené…ç½®")
    bot = None
else:
    # å®šä¹‰ bot ä¸ºç¬¬ä¸€ä¸ªå®¢æˆ·ç«¯ (ä¸»è¦ç”¨äºåå°ä»»åŠ¡çš„ä¸»åŠ¨å‘é€)
    bot = clients[0]
    print(f"[æœºå™¨äººåˆå§‹åŒ–] ğŸ‰ æˆåŠŸå¯åŠ¨ {len(clients)} ä¸ªæœºå™¨äººå®¢æˆ·ç«¯")

# è‡ªå®šä¹‰è£…é¥°å™¨ï¼šæ³¨å†Œäº‹ä»¶åˆ°æ‰€æœ‰æœºå™¨äºº


def multi_bot_on(event_builder):
    def decorator(handler):
        registered_handlers.append((handler, event_builder))
        for client in clients:
            client.add_event_handler(handler, event_builder)
        return handler
    return decorator


print(f"[æœºå™¨äººåˆå§‹åŒ–] âœ… å…¨éƒ¨å¯åŠ¨å®Œæˆï¼Œå…± {len(clients)} ä¸ªæœºå™¨äººåœ¨çº¿")

# å…¨å±€é˜Ÿåˆ—
pending_broadcasts = []
notify_queue = []
process_recharge_queue = []
waiting_for_group_link = {}
waiting_for_backup = {}
waiting_for_recharge_amount = {}
waiting_for_withdraw_amount = {}
waiting_for_withdraw_address = {}
withdraw_temp_data = {}
admin_waiting = {}

# å…¨å±€é€šçŸ¥é˜²é‡ç¼“å­˜ { "user_group_reason": timestamp }
notification_history = {}

# æŒ‰é’®ç‚¹å‡»é¢‘ç‡é™åˆ¶ç¼“å­˜ { user_id: [timestamp1, timestamp2, ...] }
button_click_history = {}

# ã€æ–°å¢ã€‘ç”¨æˆ·æƒ©ç½šçŠ¶æ€ç¼“å­˜ { user_id: expire_timestamp }
# ç”¨äºè®°å½•è¢«å°ç¦ç”¨æˆ·çš„è§£å°æ—¶é—´ï¼Œç¡®ä¿å³ä¾¿æ˜¯ç”±"1åˆ†é’Ÿ20æ¬¡"è§¦å‘çš„"5åˆ†é’Ÿæƒ©ç½š"ï¼Œ
# åœ¨1åˆ†é’Ÿå†å²è®°å½•æ¸…é™¤åï¼Œä¾ç„¶èƒ½æŒç»­ç”Ÿæ•ˆç›´åˆ°5åˆ†é’Ÿç»“æŸã€‚
user_restrictions = {}

# å¯¼å…¥æ”¯ä»˜æ¨¡å—

# ==================== æŒ‰é’®é¢‘ç‡é™åˆ¶é€»è¾‘ ====================


def check_button_rate_limit(user_id, event=None):
    """
    æ£€æŸ¥æŒ‰é’®ç‚¹å‡»é¢‘ç‡é™åˆ¶ (å¸¦å¼ºåˆ¶æƒ©ç½šæœºåˆ¶)

    è§„åˆ™:
    - 5ç§’å†…ç‚¹3æ¬¡ -> å°1åˆ†é’Ÿ
    - 1åˆ†é’Ÿå†…ç‚¹20æ¬¡ -> å°5åˆ†é’Ÿ

    è¿”å›å€¼:
    - None: å…è®¸ç‚¹å‡»
    - (å‰©ä½™ç§’æ•°, æç¤ºæ¶ˆæ¯): è¢«é™åˆ¶
    """
    import time
    current_time = time.time()

    # --- ç¬¬ä¸€æ­¥ï¼šæ£€æŸ¥æ˜¯å¦åœ¨æƒ©ç½šæœŸå†… ---

    if user_id in user_restrictions:
        expire_time = user_restrictions[user_id]
        if current_time < expire_time:
            # ä»åœ¨æƒ©ç½šæœŸï¼Œè®¡ç®—å‰©ä½™æ—¶é—´
            remaining = int(expire_time - current_time)

            # æ ¹æ®å‰©ä½™æ—¶é—´ç”Ÿæˆæ–‡æ¡ˆ
            if remaining > 60:
                mins = int(remaining / 60)
                secs = remaining % 60
                msg = f"ğŸš« æ“ä½œé¢‘ç‡è¿‡é«˜ï¼\nç³»ç»Ÿé™åˆ¶ä¸­ï¼Œéœ€ç­‰å¾… {mins}åˆ†{secs}ç§’ åè§£é™¤"
            else:
                msg = f"â° æ“ä½œå¤ªå¿«äº†\nè¯·ä¼‘æ¯ {remaining} ç§’åå†è¯•"

            return (remaining, msg)
        else:
            # æƒ©ç½šæ—¶é—´å·²è¿‡ï¼Œç§»é™¤æƒ©ç½šå¹¶æ¸…ç©ºå†å²ï¼Œç»™ç”¨æˆ·é‡æ–°å¼€å§‹çš„æœºä¼š
            del user_restrictions[user_id]
            if user_id in button_click_history:
                button_click_history[user_id] = []

    # --- ç¬¬äºŒæ­¥ï¼šè®°å½•ä¸åˆ¤å®š ---

    # åˆå§‹åŒ–
    if user_id not in button_click_history:
        button_click_history[user_id] = []

    # æ¸…ç†60ç§’å‰çš„æ—§è®°å½• (åªä¿ç•™æœ€è¿‘60ç§’çš„æ•°æ®ç”¨äºè®¡ç®—é¢‘ç‡)
    button_click_history[user_id] = [
        ts for ts in button_click_history[user_id]
        if current_time - ts < 60
    ]

    user_clicks = button_click_history[user_id]

    # è§„åˆ™Aï¼š5ç§’å†…ç‚¹å‡» >= 3æ¬¡ (æ£€æµ‹çŸ­æ—¶çˆ†å‘)
    # é€»è¾‘ï¼šå¦‚æœè¿‡å»5ç§’å†…å·²ç»æœ‰2æ¬¡ç‚¹å‡»ï¼ŒåŠ ä¸Šè¿™ä¸€æ¬¡å°±æ˜¯3æ¬¡ï¼Œè§¦å‘é™åˆ¶
    recent_clicks_count = len([ts for ts in user_clicks if current_time - ts <= 5])
    if recent_clicks_count >= 2:
        # è§¦å‘ 1åˆ†é’Ÿ æƒ©ç½š
        restriction_time = 60
        user_restrictions[user_id] = current_time + restriction_time
        return (restriction_time, "â° ç‚¹å‡»å¤ªå¿«äº†ï¼\næ£€æµ‹åˆ°5ç§’å†…è¿ç»­æ“ä½œ\nç³»ç»Ÿé™åˆ¶ 1åˆ†é’Ÿ åè§£é™¤")

    # è§„åˆ™Bï¼š1åˆ†é’Ÿå†…ç‚¹å‡» >= 20æ¬¡ (æ£€æµ‹é•¿æ—¶åˆ·å±)
    # é€»è¾‘ï¼šå¦‚æœè¿‡å»60ç§’å†…å·²ç»æœ‰19æ¬¡ç‚¹å‡»ï¼ŒåŠ ä¸Šè¿™ä¸€æ¬¡å°±æ˜¯20æ¬¡ï¼Œè§¦å‘é™åˆ¶
    if len(user_clicks) >= 19:
        # è§¦å‘ 5åˆ†é’Ÿ æƒ©ç½š
        restriction_time = 300
        user_restrictions[user_id] = current_time + restriction_time
        return (restriction_time, "ğŸš« æ“ä½œé¢‘ç‡è¿‡é«˜ï¼\n1åˆ†é’Ÿå†…æ“ä½œè¶…20æ¬¡\nç³»ç»Ÿé™åˆ¶ 5åˆ†é’Ÿ åè§£é™¤")

    # --- ç¬¬ä¸‰æ­¥ï¼šé€šè¿‡æ£€æŸ¥ï¼Œè®°å½•æœ¬æ¬¡ç‚¹å‡» ---

    user_clicks.append(current_time)

    return None


def rate_limit_callback(func):
    """æŒ‰é’®é¢‘ç‡é™åˆ¶è£…é¥°å™¨"""
    async def wrapper(event, *args, **kwargs):
        # è·å–ç”¨æˆ·IDï¼ˆè€ƒè™‘è´¦å·å…³è”ï¼‰
        original_sender_id = event.sender_id
        try:
            mapped_id = get_main_account_id(
                original_sender_id, getattr(event.sender, 'username', None))
            user_id = mapped_id if mapped_id != original_sender_id else original_sender_id
        except:
            user_id = original_sender_id

        # æ£€æŸ¥é¢‘ç‡é™åˆ¶
        limit_result = check_button_rate_limit(user_id)
        if limit_result:
            limit_seconds, message = limit_result
            print(f'[é¢‘ç‡é™åˆ¶] ğŸš« ç”¨æˆ· {user_id} è¢«é™åˆ¶ {limit_seconds}ç§’: {message}')
            print(f'[é¢‘ç‡é™åˆ¶] ğŸ“Š å½“å‰ç‚¹å‡»å†å²: {button_click_history.get(user_id, [])}')
            print(f'[é¢‘ç‡é™åˆ¶] ğŸ”’ å½“å‰æƒ©ç½šçŠ¶æ€: {user_restrictions.get(user_id, "æ— ")}')
            await event.answer(message, alert=True)

            # æ¸…ç†è¿‡æœŸè®°å½•ï¼ˆé˜²æ­¢å†…å­˜æ³„æ¼ï¼‰
            import time
            current_time = time.time()
            for uid in list(button_click_history.keys()):
                button_click_history[uid] = [
                    ts for ts in button_click_history[uid]
                    if current_time - ts < 3600  # 1å°æ—¶åæ¸…ç†
                ]
                if not button_click_history[uid]:
                    del button_click_history[uid]

            return

        # æ­£å¸¸æ‰§è¡Œ
        click_count = len(button_click_history.get(user_id, []))
        print(f'[é¢‘ç‡é™åˆ¶] âœ… ç”¨æˆ· {user_id} ç‚¹å‡»æ­£å¸¸ï¼Œå·²è®°å½• (å½“å‰{click_count}æ¬¡)')
        return await func(event, *args, **kwargs)

    return wrapper

# ==================== è´¦å·å…³è”é€»è¾‘ ====================


def get_main_account_id(telegram_id, username=None):
    """è·å–ä¸»è´¦å·IDï¼ˆç²¾å‡†IDåŒ¹é…ç‰ˆï¼‰"""
    try:
        target_id_str = str(telegram_id).strip()
        clean_username = (username or '').strip().lstrip('@')
        
        conn = get_db_conn()
        c = conn.cursor()
        
        # æ ¸å¿ƒæŸ¥è¯¢ï¼šæŸ¥æ‰¾æ˜¯å¦æœ‰äººçš„ backup_account å­—æ®µç­‰äºå½“å‰è®¿é—®è€…çš„ ID
        query = "SELECT telegram_id FROM members WHERE backup_account = ?"
        c.execute(query, (target_id_str,))
        row = c.fetchone()
        
        # å¦‚æœIDæ²¡æŸ¥åˆ°ï¼Œå†å°è¯•æŸ¥ç”¨æˆ·å
        if not row and clean_username:
            c.execute(
                'SELECT telegram_id FROM members WHERE backup_account = ? OR backup_account = ?',
                (clean_username, f"@{clean_username}")
            )
            row = c.fetchone()
            
        # æ¡æ¼è´¦å·é€»è¾‘ - ä¼˜å…ˆæŸ¥è¯¢ fallback_accounts
        if not row:
            c.execute(
                'SELECT main_account_id FROM fallback_accounts '
                'WHERE telegram_id = ? AND main_account_id IS NOT NULL LIMIT 1',
                (telegram_id,)
            )
            fallback_result = c.fetchone()
            if fallback_result and fallback_result[0]:
                conn.close()
                print(f"âœ… [è´¦å·æ˜ å°„] {target_id_str} -> ä¸»è´¦å· {fallback_result[0]} (fallback_accounts)")
                return fallback_result[0]
        
        conn.close()
        
        if row:
            print(f"âœ… [è´¦å·æ˜ å°„] {target_id_str} -> ä¸»è´¦å· {row[0]}")
            return int(row[0])  # ç¡®ä¿è¿”å›æ•´æ•°
        
        return telegram_id
    except Exception as e:
        print(f"[å…³è”æŸ¥è¯¢å‡ºé”™] {e}")
        return telegram_id

    
def format_backup_account_display(backup_account, main_account_id=None):
    """æ ¼å¼åŒ–å¤‡ç”¨å·æ˜¾ç¤º"""
    # å¦‚æœæ²¡æœ‰å¤‡ç”¨å·ï¼Œè¿”å›ç©º
    if not backup_account:
        return ""

    backup_account_str = str(backup_account).strip()
    if backup_account_str.startswith('@'):
        return backup_account_str
    if not backup_account_str.isdigit():
        return f"@{backup_account_str}"
    
    try:
        backup_id = int(backup_account_str)
        backup_member = DB.get_member(backup_id)
        if backup_member and backup_member.get('username'):
            return f"@{backup_member['username']}"
        else:
            return backup_account_str
    except (ValueError, Exception):
        return backup_account_str

    # å¦‚æœæ²¡æœ‰ä¼ ç»Ÿå¤‡ç”¨å·ï¼Œå°è¯•ä»fallback_accountsè¡¨æŸ¥æ‰¾
    if main_account_id:
        try:
            conn = get_db_conn()
            c = conn.cursor()
            c.execute('SELECT telegram_id, username FROM fallback_accounts WHERE main_account_id = ? AND is_active = 1', (main_account_id,))
            row = c.fetchone()
            conn.close()

            if row:
                backup_id, backup_username = row
                if backup_username:
                    return f"@{backup_username}"
                else:
                    return str(backup_id)
        except Exception as e:
            print(f"[å¤‡ç”¨å·æ˜¾ç¤ºé”™è¯¯] {e}")
            try:
                conn.close()
            except:
                pass

    return "æœªè®¾ç½®"


def resolve_sender_id(event):
    """è§£æå‘é€è€…IDï¼Œæ”¯æŒå¤‡ç”¨å·æ˜ å°„"""
    original_id = event.sender_id
    main_id = get_main_account_id(
        original_id, getattr(
            event.sender, 'username', None))

    # å¦‚æœæ˜ å°„æˆåŠŸï¼Œè¿”å›ä¸»å·IDï¼›å¦åˆ™è¿”å›åŸå§‹ID
    return main_id if main_id != original_id else original_id


def get_resolved_sender_info(event):
    """è·å–è§£æåçš„å‘é€è€…ä¿¡æ¯ï¼Œè¿”å› (original_id, resolved_id)"""
    original_id = event.sender_id
    resolved_id = resolve_sender_id(event)
    return original_id, resolved_id


def with_account_resolution(func):
    """è£…é¥°å™¨ï¼šè‡ªåŠ¨å¤„ç†è´¦å·è§£æ"""
    async def wrapper(event, *args, **kwargs):
        # ä¸ºäº‹ä»¶å¯¹è±¡æ·»åŠ è§£æåçš„IDå±æ€§
        original_id, resolved_id = get_resolved_sender_info(event)
        event._original_sender_id = original_id
        event._resolved_sender_id = resolved_id
        # ä¿æŒå‘åå…¼å®¹
        event.sender_id = resolved_id
        return await func(event, *args, **kwargs)
    return wrapper


async def check_user_group_binding_status(user_id, clients):
    """æ£€æŸ¥ç”¨æˆ·çš„ç¾¤ç»„ç»‘å®šæ˜¯å¦ä»ç„¶æœ‰æ•ˆ"""
    try:
        # è·å–ç”¨æˆ·çš„ç¾¤ç»„ç»‘å®šä¿¡æ¯
        member = DB.get_member(user_id)
        if not member or not member.get(
                'group_link') or not member.get('is_group_bound'):
            return False

        group_link = member['group_link']
        print(f'[ç¾¤ç»„æ£€æµ‹] æ£€æŸ¥ç”¨æˆ· {user_id} çš„ç¾¤ç»„ç»‘å®š: {group_link}')

        # ä½¿ç”¨å¤šæœºå™¨äººé€»è¾‘æ£€æŸ¥æ˜¯å¦æœ‰æœºå™¨äººä»åœ¨ç¾¤ç»„ä¸­ä¸”ä¸ºç®¡ç†å‘˜
        is_any_bot_in_group, admin_bot_id = await check_any_bot_in_group(clients, group_link)

        if not is_any_bot_in_group:
            # æ²¡æœ‰æœºå™¨äººåŠ å…¥ç¾¤ç»„ï¼Œæ ‡è®°ç»‘å®šå¤±æ•ˆ
            print(f'[ç¾¤ç»„æ£€æµ‹] ç”¨æˆ· {user_id} çš„ç¾¤ç»„ç»‘å®šå¤±æ•ˆï¼šæ²¡æœ‰æœºå™¨äººåŠ å…¥ç¾¤ç»„')
            # æ›´æ–°æ•°æ®åº“çŠ¶æ€
            conn = get_db_conn()
            c = conn.cursor()
            c.execute(
                'UPDATE members SET is_group_bound = 0, is_bot_admin = 0 WHERE telegram_id = ?',
                (user_id,
                 ))
            conn.commit()
            conn.close()
            return False
        elif admin_bot_id is None:
            # æœ‰æœºå™¨äººåŠ å…¥ä½†ä¸æ˜¯ç®¡ç†å‘˜ï¼Œæ ‡è®°ç®¡ç†å‘˜æƒé™å¤±æ•ˆ
            print(f'[ç¾¤ç»„æ£€æµ‹] ç”¨æˆ· {user_id} çš„ç®¡ç†å‘˜æƒé™å¤±æ•ˆï¼šæœºå™¨äººä¸åœ¨ç¾¤ç»„æˆ–ä¸æ˜¯ç®¡ç†å‘˜')
            # æ›´æ–°æ•°æ®åº“çŠ¶æ€
            conn = get_db_conn()
            c = conn.cursor()
            c.execute(
                'UPDATE members SET is_bot_admin = 0 WHERE telegram_id = ?', (user_id,))
            conn.commit()
            conn.close()
            return True  # ç»‘å®šä»ç„¶æœ‰æ•ˆï¼Œåªæ˜¯ç®¡ç†å‘˜æƒé™å¤±æ•ˆ

        # ç»‘å®šå®Œå…¨æœ‰æ•ˆ
        print(f'[ç¾¤ç»„æ£€æµ‹] ç”¨æˆ· {user_id} çš„ç¾¤ç»„ç»‘å®šå®Œå…¨æœ‰æ•ˆ')
        return True

    except Exception as e:
        print(f'[ç¾¤ç»„æ£€æµ‹] æ£€æŸ¥ç”¨æˆ· {user_id} ç¾¤ç»„ç»‘å®šå¤±è´¥: {e}')
        return False


async def notify_group_binding_invalid(
        chat_id,
        bot_id=None,
        reason="ç¾¤ç»„çŠ¶æ€å¼‚å¸¸",
        notify_bot=None):
    """é€šçŸ¥æ‰€æœ‰ç»‘å®šæŒ‡å®šç¾¤ç»„çš„ç”¨æˆ·ï¼Œç¾¤ç»„ç»‘å®šå·²å¤±æ•ˆ"""
    try:
        # ã€ä¿®å¤ã€‘é¿å…é‡å¤é€šçŸ¥ - æ£€æŸ¥æœ€è¿‘24å°æ—¶å†…æ˜¯å¦å·²ç»å‘é€è¿‡ç›¸åŒç±»å‹çš„é€šçŸ¥
        current_time_str = get_cn_time()
        current_time = datetime.fromisoformat(current_time_str)
        one_day_ago = current_time - timedelta(hours=24)

        conn = get_db_conn()
        c = conn.cursor()

        # æ£€æŸ¥æœ€è¿‘çš„é€šçŸ¥è®°å½•ï¼ˆç®€å•é˜²é‡å¤æœºåˆ¶ï¼‰
        # è¿™é‡Œå¯ä»¥è€ƒè™‘æ·»åŠ ä¸€ä¸ªé€šçŸ¥å†å²è¡¨ï¼Œä½†æš‚æ—¶ç”¨æ—¶é—´æˆ³æ£€æŸ¥

        # ã€æ ¸å¿ƒä¿®å¤ã€‘ID æ ¼å¼å…¼å®¹å¤„ç†
        # å°è¯•æŸ¥æ‰¾åŒ¹é…çš„ IDï¼Œè€ƒè™‘åˆ° -100 å‰ç¼€çš„æƒ…å†µ
        target_ids = [chat_id]
        if isinstance(chat_id, int):
            # å¦‚æœæ˜¯æ­£æ•°ï¼Œå°è¯•æ·»åŠ  -100 å‰ç¼€ (Telegram è¶…çº§ç¾¤ç»„ ID)
            if chat_id > 0:
                target_ids.append(int(f"-100{chat_id}"))
            # å¦‚æœæ˜¯è´Ÿæ•°ä¸”ä»¥ -100 å¼€å¤´ï¼Œå°è¯•å»æ‰å‰ç¼€ (ä»¥é˜²æ•°æ®åº“å­˜çš„æ˜¯çŸ­ ID)
            elif str(chat_id).startswith('-100'):
                try:
                    target_ids.append(int(str(chat_id)[4:]))
                except BaseException:
                    pass

        placeholders = ','.join(['?'] * len(target_ids))
        query = f'SELECT telegram_id, group_name, group_link, group_id FROM member_groups WHERE group_id IN ({placeholders})'

        print(f'[é€šçŸ¥] æ­£åœ¨æŸ¥æ‰¾ç»‘å®šç¾¤ç»„çš„ç”¨æˆ·ï¼Œå°è¯•åŒ¹é…ID: {target_ids}')
        c.execute(query, target_ids)
        bound_users = c.fetchall()
        conn.close()

        if not bound_users:
            print(f'[é€šçŸ¥] âŒ æœªåœ¨æ•°æ®åº“ä¸­æ‰¾åˆ°ç»‘å®šç¾¤ç»„ {chat_id} (æˆ–å˜ä½“ {target_ids}) çš„ç”¨æˆ·')
            return

        print(f'[é€šçŸ¥] âœ… æ‰¾åˆ° {len(bound_users)} ä¸ªç»‘å®šç”¨æˆ·ï¼Œå‡†å¤‡å‘é€é€šçŸ¥')

        # é‡ç½®è¿™äº›ç”¨æˆ·çš„ç¾¤ç»„ç»‘å®šçŠ¶æ€
        for user_id, group_name, group_link, db_group_id in bound_users:
            # ã€ä¿®å¤ã€‘é˜²é‡é€»è¾‘ï¼šå¦‚æœåŒä¸€ä¸ªç”¨æˆ·ã€åŒä¸€ä¸ªç¾¤ã€åŒä¸€ä¸ªåŸå› åœ¨60ç§’å†…å·²é€šçŸ¥ï¼Œåˆ™è·³è¿‡
            dedup_key = f"{user_id}_{db_group_id}_{reason}"
            now_ts = time.time()

            # æ¸…ç†è¿‡æœŸç¼“å­˜ï¼ˆè¶…è¿‡60ç§’çš„è®°å½•ï¼‰
            expired_keys = [k for k, ts in notification_history.items() if now_ts - ts > 60]
            for k in expired_keys:
                del notification_history[k]

            if dedup_key in notification_history:
                if now_ts - notification_history[dedup_key] < 60:
                    print(f'[é€šçŸ¥] â³ æ‹¦æˆªé‡å¤é€šçŸ¥: {dedup_key}')
                    continue
            notification_history[dedup_key] = now_ts

            try:
                # ä¸ºæ¯ä¸ªç”¨æˆ·å•ç‹¬å¤„ç†æ•°æ®åº“æ“ä½œï¼Œé¿å…å¹¶å‘é—®é¢˜
                # æ·»åŠ é‡è¯•æœºåˆ¶å¤„ç†æ•°æ®åº“é”å®š
                max_retries = 5
                retry_delay = 0.2
                username = f'ç”¨æˆ·{user_id}'

                for attempt in range(max_retries):
                    try:
                        user_conn = get_db_conn()
                        user_cursor = user_conn.cursor()

                        # è·å–ç”¨æˆ·çœŸå®å§“å
                        user_cursor.execute(
                            'SELECT username FROM members WHERE telegram_id = ?', (user_id,))
                        user_row = user_cursor.fetchone()
                        username = user_row[0] if user_row else f'ç”¨æˆ·{user_id}'

                        # æ›´æ–°æ•°æ®åº“ï¼šæ¸…é™¤ç¾¤ç»„ç»‘å®šå’Œç®¡ç†å‘˜çŠ¶æ€ï¼Œå¹¶é‡ç½®åŠ ç¾¤ä»»åŠ¡çŠ¶æ€
                        user_cursor.execute('''
                            UPDATE members
                            SET is_group_bound = 0, is_bot_admin = 0, is_joined_upline = 0
                            WHERE telegram_id = ?
                        ''', (user_id,))

                        # åŒæ—¶åˆ é™¤member_groupsè¡¨ä¸­çš„è®°å½• - ä½¿ç”¨æ•°æ®åº“ä¸­å­˜å‚¨çš„group_idç¡®ä¿æ ¼å¼åŒ¹é…
                        # ã€ä¿®å¤ã€‘æ”¹ä¸ºæ›´æ–°çŠ¶æ€è€Œä¸æ˜¯åˆ é™¤ï¼Œé˜²æ­¢"æ’¤é”€æƒé™"ç´§æ¥ç€"è¸¢å‡º"æ—¶ï¼Œè¸¢å‡ºäº‹ä»¶æŸ¥ä¸åˆ°ç”¨æˆ·
                        user_cursor.execute(
                            'UPDATE member_groups SET is_bot_admin = 0 WHERE telegram_id = ? AND group_id = ?',
                            (user_id,
                             db_group_id))

                        user_conn.commit()
                        user_conn.close()
                        break  # æˆåŠŸåè·³å‡ºé‡è¯•å¾ªç¯

                    except Exception as db_err:
                        if user_conn:
                            try:
                                user_conn.close()
                            except BaseException:
                                pass

                        if 'locked' in str(db_err).lower(
                        ) and attempt < max_retries - 1:
                            print(
                                f'[é€šçŸ¥] æ•°æ®åº“é”å®šï¼Œé‡è¯• {attempt + 1}/{max_retries} ç”¨æˆ· {user_id}: {db_err}')
                            # é€’å¢å»¶è¿Ÿ
                            await asyncio.sleep(retry_delay * (attempt + 1))
                            continue
                        else:
                            print(
                                f'[é€šçŸ¥] å¤„ç†ç”¨æˆ· {user_id} æ•°æ®åº“æ“ä½œå¤±è´¥ (å°è¯• {attempt + 1}/{max_retries}): {db_err}')
                            raise db_err

                # å¦‚æœæ•°æ®åº“æ“ä½œå¤±è´¥ï¼Œç»§ç»­å¤„ç†é€šçŸ¥ï¼ˆä¸é˜»æ–­é€šçŸ¥å‘é€ï¼‰
                print(f'[é€šçŸ¥] å¼€å§‹å‘ç”¨æˆ· {user_id} ({username}) å‘é€é€šçŸ¥')

                # é€šçŸ¥ç”¨æˆ·
                notification_msg = f'''
âš ï¸ **ç¾¤ç»„ç»‘å®šçŠ¶æ€å¼‚å¸¸**

æ‚¨çš„ç¾¤ç»„ç»‘å®šå·²å¤±æ•ˆï¼ŒåŸå› ï¼š{reason}

åŸç¾¤ç»„ï¼š{group_name}
åŸç¾¤é“¾æ¥ï¼š{group_link}

è¯·é‡æ–°è®¾ç½®ç¾¤ç»„ç»‘å®šä»¥ç»§ç»­è·å¾—åˆ†çº¢æ”¶ç›Šã€‚
                '''.strip()

                # ä½¿ç”¨æŒ‡å®šçš„æœºå™¨äººå‘é€é€šçŸ¥ï¼Œå¦‚æœæ²¡æœ‰æŒ‡å®šåˆ™ä½¿ç”¨å…¨å±€bot
                notification_sent = False
                if notify_bot:
                    try:
                        bot_info = await notify_bot.get_me()
                        bot_name = bot_info.username or str(bot_info.id)
                        await notify_bot.send_message(user_id, notification_msg)
                        print(
                            f'[é€šçŸ¥] âœ… ä½¿ç”¨æŒ‡å®šæœºå™¨äºº({bot_name}) å·²é€šçŸ¥ç”¨æˆ· {user_id} ({username}) ç¾¤ç»„ç»‘å®šå¤±æ•ˆ')
                        notification_sent = True
                    except Exception as e:
                        print(f'[é€šçŸ¥] âŒ ä½¿ç”¨æŒ‡å®šæœºå™¨äººå‘ç”¨æˆ· {user_id} å‘é€é€šçŸ¥å¤±è´¥: {e}')

                if not notification_sent:
                    # å›é€€åˆ°ä½¿ç”¨æ‰€æœ‰æ´»è·ƒçš„æœºå™¨äººå‘é€é€šçŸ¥
                    for client in clients:
                        try:
                            await client.send_message(user_id, notification_msg)
                            print(
                                f'[é€šçŸ¥] âœ… ä½¿ç”¨æœºå™¨äººå·²é€šçŸ¥ç”¨æˆ· {user_id} ({username}) ç¾¤ç»„ç»‘å®šå¤±æ•ˆ')
                            notification_sent = True
                            break
                        except Exception as e:
                            print(f'[é€šçŸ¥] âŒ ä½¿ç”¨æœºå™¨äººå‘ç”¨æˆ· {user_id} å‘é€é€šçŸ¥å¤±è´¥: {e}')
                            continue

                if not notification_sent:
                    print(f'[é€šçŸ¥] âŒ æ‰€æœ‰æœºå™¨äººå‘ç”¨æˆ· {user_id} ({username}) å‘é€é€šçŸ¥éƒ½å¤±è´¥äº†')

            except Exception as user_err:
                print(f'[é€šçŸ¥] å¤„ç†ç”¨æˆ· {user_id} å¤±è´¥: {user_err}')
                continue

            except Exception as user_err:
                print(f'[é€šçŸ¥] å¤„ç†ç”¨æˆ· {user_id} å¤±è´¥: {user_err}')
                continue

            except Exception as e:
                print(f'[é€šçŸ¥] å¤„ç†ç”¨æˆ· {user_id} å¤±è´¥: {e}')
                continue

    except Exception as e:
        print(f'[é€šçŸ¥] ç¾¤ç»„ç»‘å®šå¤±æ•ˆé€šçŸ¥å¤±è´¥: {e}')


def link_account(main_id, backup_id, backup_username):
    """å…³è”å¤‡ç”¨å·åˆ°ä¸»è´¦å·"""
    clean_username = (backup_username or '').strip().lstrip('@')
    
    if clean_username:
        value_to_store = f"@{clean_username}"
    elif backup_id:
        value_to_store = str(backup_id)
    else:
        return False, "âŒ æ— æ•ˆçš„å¤‡ç”¨è´¦å·ä¿¡æ¯"
        
    if str(main_id) == str(backup_id) or value_to_store == str(main_id):
        return False, "âŒ ä¸èƒ½å°†è‡ªå·±è®¾ç½®ä¸ºå¤‡ç”¨å·"

    try:
        if backup_id:
            existing_member = DB.get_member(backup_id)
            if existing_member and str(backup_id) != str(main_id):
                # å¦‚æœå¤‡ç”¨å·å·²ç»æ³¨å†Œï¼Œä½¿ç”¨fallback_accountsè¡¨å»ºç«‹å…³è”
                print(f"[å¤‡ç”¨å·å·²æ³¨å†Œ] {backup_id} å·²æ³¨å†Œï¼Œå°†ä½¿ç”¨fallback_accountså»ºç«‹å…³è”")
                conn = get_db_conn()
                c = conn.cursor()
                try:
                    # æ£€æŸ¥æ˜¯å¦å·²ç»å­˜åœ¨å…³è”
                    c.execute(
                        'SELECT main_account_id FROM fallback_accounts WHERE telegram_id = ?',
                        (backup_id,
                         ))
                    existing_fallback = c.fetchone()

                    if existing_fallback and str(
                            existing_fallback[0]) != str(main_id):
                        conn.close()
                        return False, "âŒ è¯¥è´¦å·å·²ç»æ˜¯å…¶ä»–äººçš„å¤‡ç”¨å·äº†ï¼Œæ— æ³•é‡å¤ç»‘å®š"

                    # æ’å…¥æˆ–æ›´æ–°fallback_accounts
                    c.execute('''
                        INSERT OR REPLACE INTO fallback_accounts (telegram_id, main_account_id, username)
                        VALUES (?, ?, ?)
                    ''', (backup_id, main_id, clean_username or None))
                    conn.commit()
                    conn.close()
                    return True, f"âš ï¸ç»‘å®šæˆåŠŸ/å®Œæˆ\nç»‘å®šå€¼: {value_to_store}\n\nå¤‡ç”¨å·å·²æ³¨å†Œï¼Œå°†ä½¿ç”¨å¤‡ç”¨å…³è”æ¨¡å¼ã€‚\n\nè¯·ä½¿ç”¨å¤‡ç”¨å·è®¿é—®ä¸ªäººä¸­å¿ƒæµ‹è¯•ã€‚"
                except Exception as e:
                    try:
                        conn.close()
                    except BaseException:
                        pass
                    return False, f"å¤‡ç”¨å…³è”è®¾ç½®å¤±è´¥: {e}"
    except Exception as e:
        print(f"[æ£€æŸ¥å¤‡ç”¨å·æ˜¯å¦å·²æ³¨å†Œå¤±è´¥] {e}")

    conn = get_db_conn()
    c = conn.cursor()
    try:
        c.execute(
            'SELECT telegram_id FROM members WHERE backup_account = ?', (str(backup_id),))
        existing_by_id = c.fetchone()
        
        c.execute(
            'SELECT telegram_id FROM members WHERE backup_account = ? OR backup_account = ?',
            (clean_username, f"@{clean_username}")
        )
        existing_by_name = c.fetchone()
        
        existing = existing_by_id or existing_by_name
        
        if existing and str(existing[0]) != str(main_id):
            conn.close()
            return False, "âŒ è¯¥è´¦å·å·²ç»æ˜¯å…¶ä»–äººçš„å¤‡ç”¨å·äº†ï¼Œæ— æ³•é‡å¤ç»‘å®š"

        c.execute(
            'UPDATE members SET backup_account = ? WHERE telegram_id = ?',
            (value_to_store,
             main_id))
        conn.commit()
        conn.close()
        return True, f"âš ï¸ç»‘å®šæˆåŠŸ/å®Œæˆ\nç»‘å®šå€¼: {value_to_store}\n\nè¯·ä½¿ç”¨å¤‡ç”¨å·å‘é€ /start æµ‹è¯•ã€‚"
        
    except Exception as e:
        try:
            conn.close()
        except BaseException:
            pass
        return False, f"å…³è”å¤±è´¥: {str(e)}"


def get_fallback_resource(resource_type='group'):
    """è·å–æ¡æ¼è´¦å·èµ„æº"""
    try:
        conn = get_db_conn()
        c = conn.cursor()
        if resource_type == 'group':
            # è¿”å›åŒ…å«ç¾¤ç»„åç§°å’Œé“¾æ¥çš„åˆ—è¡¨
            c.execute("SELECT username, group_link FROM fallback_accounts WHERE is_active = 1 AND group_link IS NOT NULL AND group_link != '' ORDER BY id ASC")
            results = c.fetchall()
            conn.close()
            if results:
                groups = []
                seen = set()
                for username, group_link in results:
                    if not group_link:
                        continue
                    g_links = group_link.split('\n')
                    for link in g_links:
                        link = link.strip()
                        if link and link not in seen:
                            # é»˜è®¤ä½¿ç”¨ç”¨æˆ·åï¼Œå¦‚æœæ²¡æœ‰åˆ™ä½¿ç”¨é“¾æ¥æœ€åä¸€éƒ¨åˆ†
                            default_name = username or link.split(
                                '/')[-1].replace('+', '')
                            groups.append({
                                'username': username or '',
                                'link': link,
                                'name': default_name  # é»˜è®¤åç§°ï¼Œåç»­å¯ä»¥é€šè¿‡Telegram APIè·å–å®é™…åç§°
                            })
                            seen.add(link)
                return groups if groups else None
        elif resource_type == 'account':
            c.execute(
                "SELECT telegram_id, username FROM fallback_accounts WHERE is_active = 1 ORDER BY RANDOM() LIMIT 1")
            result = c.fetchone()
            conn.close()
            if result:
                return {'telegram_id': result[0], 'username': result[1]}
        conn.close()
    except Exception as e:
        print(f"[æ¡æ¼é”™è¯¯] {e}")
    return None


async def get_group_title(bot, group_link):
    """ä»Telegram APIè·å–ç¾¤ç»„å®é™…åç§°"""
    try:
        # æå–ç¾¤ç»„ç”¨æˆ·å
        if 't.me/' in group_link:
            group_username = group_link.split(
                't.me/')[-1].split('/')[0].split('?')[0]
        elif group_link.startswith('@'):
            group_username = group_link[1:]
        else:
            return None
        
        # è·³è¿‡ç§æœ‰ç¾¤é“¾æ¥
        if group_username.startswith('+'):
            return None
        
        # è·å–ç¾¤ç»„å®ä½“
        group_entity = await bot.get_entity(group_username)
        title = getattr(group_entity, 'title', None)
        return title
    except Exception as e:
        print(f"[è·å–ç¾¤ç»„åç§°å¤±è´¥] {group_link}: {e}")
    return None


def get_main_keyboard(user_id=None):
    """ä¸»èœå•é”®ç›˜"""
    keyboard = [
        [
            Button.text(
                BTN_VIP, resize=True), Button.text(
                BTN_VIEW_FISSION, resize=True), Button.text(
                    BTN_MY_PROMOTE, resize=True)], [
                        Button.text(
                            BTN_RESOURCES, resize=True), Button.text(
                                BTN_FISSION, resize=True), Button.text(
                                    BTN_PROFILE, resize=True)], [
                                        Button.text(
                                            BTN_SUPPORT, resize=True)]]
    if user_id and user_id in ADMIN_IDS:
        keyboard[-1].append(Button.text(BTN_ADMIN, resize=True))
    return keyboard

# ==================== ã€æ ¸å¿ƒä¿®å¤ã€‘VIPå¼€é€šé€»è¾‘ ====================
# æ‰€æœ‰VIPå¼€é€šè·¯å¾„éƒ½ç»Ÿä¸€è°ƒç”¨ distribute_vip_rewardsï¼Œåˆ é™¤å†—ä½™çš„æ‰‹å†™åˆ†çº¢ä»£ç 


async def process_vip_upgrade(
        telegram_id,
        vip_price,
        config,
        deduct_balance=True):
    """
    ç»Ÿä¸€çš„VIPå¼€é€šå¤„ç†å‡½æ•°
    ã€æ ¸å¿ƒã€‘æ‰€æœ‰VIPå¼€é€šéƒ½è°ƒç”¨è¿™ä¸ªå‡½æ•°ï¼Œç¡®ä¿é€»è¾‘ä¸€è‡´
    
    Args:
        telegram_id: ç”¨æˆ·ID
        vip_price: VIPä»·æ ¼ï¼ˆç”¨äºåˆ†çº¢è®¡ç®—ï¼‰
        config: ç³»ç»Ÿé…ç½®
        deduct_balance: æ˜¯å¦æ‰£é™¤ä½™é¢ï¼ˆTrue=ç”¨æˆ·è‡ªå·±å¼€é€šï¼ŒFalse=ç®¡ç†å‘˜èµ é€ï¼‰
    """
    # 1. æ£€æŸ¥ç”¨æˆ·çŠ¶æ€
    member = DB.get_member(telegram_id)
    if not member:
        return False, "ç”¨æˆ·ä¸å­˜åœ¨"
    
    if member.get('is_vip'):
        return False, "ç”¨æˆ·å·²æ˜¯VIP"
    
    # 2. æ‰£é™¤ä½™é¢ï¼ˆå¦‚æœéœ€è¦ï¼‰
    print(
        f'[process_vip_upgrade] å¼€å§‹å¤„ç†: telegram_id={telegram_id}, deduct_balance={deduct_balance}, å½“å‰ä½™é¢={member["balance"]}, vip_price={vip_price}')
    if deduct_balance:
        if member['balance'] < vip_price:
            print(
                f'[process_vip_upgrade] ä½™é¢ä¸è¶³: éœ€è¦{vip_price}, å½“å‰{member["balance"]}')
            return False, "ä½™é¢ä¸è¶³"
        new_balance = member['balance'] - vip_price
        print(
            f'[process_vip_upgrade] æ‰£è´¹: {member["balance"]} -> {new_balance}')
        DB.update_member(
            telegram_id,
            balance=new_balance,
            is_vip=1,
            vip_time=get_cn_time())
    else:
        # ç®¡ç†å‘˜èµ é€ï¼Œä¸æ‰£é™¤ä½™é¢
        new_balance = member['balance']
        print(f'[process_vip_upgrade] ç®¡ç†å‘˜èµ é€VIP: ä½™é¢ä¿æŒ{new_balance}')
        DB.update_member(telegram_id, is_vip=1, vip_time=get_cn_time())
    
    # 3. æ›´æ–°å±‚çº§è·¯å¾„
    update_level_path(telegram_id)
    
    # 4. ã€æ ¸å¿ƒã€‘è°ƒç”¨ç»Ÿä¸€åˆ†çº¢å‡½æ•°ï¼ˆæ›¿ä»£æ‰€æœ‰æ‰‹å†™å¾ªç¯ï¼‰
    # ä½¿ç”¨ä¸»botå‘é€åˆ†çº¢é€šçŸ¥
    if bot:
        stats = await distribute_vip_rewards(bot, telegram_id, vip_price, config)
    else:
        stats = {'real': 0, 'total': 0}  # å¦‚æœbotæœªå¯åŠ¨ï¼Œè¿”å›ç©ºç»Ÿè®¡
    
    return True, {
        'new_balance': new_balance,
        'stats': stats
    }

# ==================== è¾…åŠ©å‡½æ•°ï¼šæ£€æµ‹å¹¶å¤„ç†ä¸Šçº§ç¾¤å¤±æ•ˆ ====================


async def verify_and_handle_upline_group(bot, upline_id, group_link, clients):
    """
    æ£€æµ‹ä¸Šçº§ç¾¤æ˜¯å¦æœ‰æ•ˆï¼ˆæœºå™¨äººæ˜¯å¦åœ¨ç¾¤ä¸”ä¸ºç®¡ç†ï¼‰ã€‚
    å¦‚æœå¤±æ•ˆï¼š
    1. æ›´æ–°æ•°æ®åº“æ ‡è®°è¯¥ç”¨æˆ·ç¾¤ç»‘å®šå¤±æ•ˆ
    2. å‘é€é€šçŸ¥ç»™è¯¥ä¸Šçº§ç”¨æˆ·
    3. è¿”å› False (è¡¨ç¤ºä¸å¯ç”¨)
    """
    try:
        # ä½¿ç”¨ check_any_bot_in_group æ£€æŸ¥ (å¤šæœºå™¨äººæ”¯æŒ)
        is_in_group, admin_bot_id = await check_any_bot_in_group(clients, group_link)

        if is_in_group and admin_bot_id:
            return True  # æœ‰æ•ˆï¼šåœ¨ç¾¤ä¸”æ˜¯ç®¡ç†

        # --- å¤„ç†å¤±æ•ˆé€»è¾‘ ---
        print(f"[æ‡’åŠ è½½æ£€æµ‹] ä¸Šçº§ {upline_id} ç¾¤ç»„å¤±æ•ˆ: {group_link}")

        # 1. æ›´æ–°æ•°æ®åº“
        conn = get_db_conn()
        c = conn.cursor()
        # æ’¤é”€ç¾¤ç®¡çŠ¶æ€ï¼Œä¿ç•™ç¾¤é“¾æ¥ä»¥ä¾¿ç”¨æˆ·çŸ¥é“æ˜¯å“ªä¸ªç¾¤
        c.execute(
            'UPDATE members SET is_bot_admin = 0 WHERE telegram_id = ?', (upline_id,))
        conn.commit()
        conn.close()

        # 2. é€šçŸ¥ä¸Šçº§ç”¨æˆ· (å¼‚æ­¥å‘é€ï¼Œä¸é˜»å¡å½“å‰æµç¨‹)
        try:
            fail_reason = "æœºå™¨äººä¸æ˜¯ç®¡ç†å‘˜" if is_in_group else "æœºå™¨äººä¸åœ¨ç¾¤ç»„å†…"
            msg = f"âš ï¸ **ç¾¤ç»„æƒé™å¼‚å¸¸é€šçŸ¥**\n\næ£€æµ‹åˆ°æ‚¨çš„ç¾¤ç»„çŠ¶æ€å¼‚å¸¸ï¼š{fail_reason}\n\nè¿™å¯¼è‡´æ‚¨çš„ä¸‹çº§æ— æ³•åŠ å…¥æ‚¨çš„ç¾¤ç»„ï¼Œæ‚¨å°†**å¤±å»åˆ†çº¢æ”¶ç›Š**ï¼\n\nè¯·å°½å¿«å°†æœºå™¨äººé‡æ–°è®¾ä¸ºç®¡ç†å‘˜ã€‚"
            await bot.send_message(upline_id, msg)
        except BaseException:
            pass  # å¯èƒ½è¢«æ‹‰é»‘ï¼Œå¿½ç•¥

        return False

    except Exception as e:
        print(f"[æ‡’åŠ è½½æ£€æµ‹] æ£€æŸ¥å¤±è´¥: {e}")
        return False  # ä¿å®ˆèµ·è§ï¼Œå‡ºé”™è§†ä¸ºæ— æ•ˆï¼Œè½¬ä¸ºæ¡æ¼

# ==================== äº‹ä»¶å¤„ç†å™¨ ====================


@multi_bot_on(events.NewMessage(pattern='/check_permission'))
async def check_permission_handler(event):
    """æ‰‹åŠ¨æ£€æŸ¥æƒé™çŠ¶æ€çš„å‘½ä»¤"""
    original_id = event.sender_id
    sender_id = get_main_account_id(
        original_id, getattr(
            event.sender, 'username', None))

    member = DB.get_member(sender_id)
    if not member or not member.get('is_vip'):
        await event.respond("âŒ ä»…é™VIPç”¨æˆ·ä½¿ç”¨æ­¤åŠŸèƒ½")
        return

    await event.respond("ğŸ” æ­£åœ¨æ£€æŸ¥æ‚¨çš„ç¾¤ç»„æƒé™çŠ¶æ€...")

    # ç«‹å³è§¦å‘æƒé™æ£€æŸ¥
    global permission_check_triggered
    permission_check_triggered = True

    await event.respond("âœ… å·²è§¦å‘æƒé™æ£€æŸ¥ï¼Œè¯·ç­‰å¾…ç³»ç»Ÿè‡ªåŠ¨æ£€æµ‹å¹¶é€šçŸ¥")


@multi_bot_on(events.NewMessage(pattern='/bind'))
async def bind_command_handler(event):
    """ç¾¤å†…ç»‘å®šå‘½ä»¤ï¼šåœ¨ç¾¤ç»„ä¸­å‘é€ /bind ç»‘å®šå½“å‰ç¾¤"""
    if event.is_private:
        await event.respond("âŒ è¯·åœ¨æ‚¨éœ€è¦ç»‘å®šçš„**ç¾¤ç»„**å†…å‘é€æ­¤å‘½ä»¤")
        return

    try:
        # 1. è·å–ç¾¤ç»„ä¿¡æ¯
        chat = await event.get_chat()
        if not chat:
            return

        chat_id = chat.id
        chat_title = chat.title or "æœªå‘½åç¾¤ç»„"

        # è·å–ç¾¤é“¾æ¥ï¼ˆå¦‚æœæœ‰å…¬å¼€usernameï¼‰
        chat_username = getattr(chat, 'username', None)
        group_link = f"https://t.me/{chat_username}" if chat_username else ""

        # 2. è§£æå‘é€è€…ï¼ˆæ”¯æŒå¤‡ç”¨å·ï¼‰
        original_id = event.sender_id
        sender_id = get_main_account_id(
            original_id, getattr(
                event.sender, 'username', None))

        # 3. æ£€æŸ¥ç”¨æˆ·æ˜¯å¦æ³¨å†Œ
        member = DB.get_member(sender_id)
        if not member:
            await event.respond(f"âŒ æœªæ‰¾åˆ°æ‚¨çš„è´¦å·ä¿¡æ¯ (ID: {sender_id})\nè¯·å…ˆç§èŠæœºå™¨äººå‘é€ /start æ³¨å†Œ")
            return

        if not member['is_vip']:
            await event.respond("âŒ ä»…é™VIPç”¨æˆ·ç»‘å®šç¾¤ç»„")
            return

        # 4. æ£€æŸ¥å‘é€è€…æ˜¯å¦ä¸ºç¾¤ç®¡ç†å‘˜
        try:
            perms = await event.client.get_permissions(event.chat_id, event.sender_id)
            if not perms.is_admin and not perms.is_creator:
                await event.respond("âŒ æ‚¨å¿…é¡»æ˜¯è¯¥ç¾¤ç»„çš„ç®¡ç†å‘˜æ‰èƒ½ç»‘å®š")
                return
        except Exception as e:
            print(f"[ç¾¤å†…ç»‘å®š] æƒé™æ£€æŸ¥å¤±è´¥: {e}")
            # å°è¯•ç»§ç»­ï¼Œå¦‚æœæ— æ³•è·å–æƒé™ä¿¡æ¯

        # 5. æ›´æ–°æ•°æ®åº“
        # æ›´æ–° members è¡¨
        # ã€ä¿®å¤ã€‘å®é™…æ£€æŸ¥æœºå™¨äººç®¡ç†å‘˜æƒé™ï¼Œè€Œä¸æ˜¯ç›´æ¥å‡è®¾
        is_bot_admin = 0  # é»˜è®¤è®¾ä¸º0ï¼Œåç»­ç”±åå°ä»»åŠ¡æ£€æŸ¥æ›´æ–°

        # å¦‚æœæ²¡æœ‰å…¬å¼€é“¾æ¥ï¼Œå°è¯•ä¿ç•™æ—§é“¾æ¥æˆ–æç¤ºç”¨æˆ·
        final_link = group_link
        if not final_link and member.get('group_link'):
            final_link = member['group_link']  # ä¿ç•™åŸæœ‰é“¾æ¥

        if not final_link:
            # å¦‚æœå®Œå…¨æ²¡æœ‰é“¾æ¥ï¼Œç”Ÿæˆä¸€ä¸ªä¼ªé“¾æ¥æˆ–æç¤º
            final_link = "Private Group (ID: " + str(chat_id) + ")"

        # æ›´æ–°
        conn = get_db_conn()
        c = conn.cursor()
        c.execute('''
            UPDATE members
            SET group_link = ?, is_group_bound = 1, is_bot_admin = ?
            WHERE telegram_id = ?
        ''', (final_link, is_bot_admin, sender_id))
        conn.commit()
        conn.close()

        # æ›´æ–° member_groups è¡¨ (upsert)
        from database import upsert_member_group
        upsert_member_group(
            sender_id,
            final_link,
            member['username'],
            is_bot_admin,
            group_id=chat_id)

        await event.respond(
            f"ğŸ’¡æç¤ºç»‘å®šæˆåŠŸ/å®Œæˆ\n"
            f"ç¾¤ç»„åç§°: {chat_title}\n"
            f"ç¾¤ç»„ID: `{chat_id}`\n"
            f"ç»‘å®šè´¦å·: `{sender_id}`\n\n"
            f"ğŸ’¡ æœºå™¨äººå·²è®°å½•ç¾¤ç»„IDï¼Œåç»­å°†è‡ªåŠ¨æ£€æµ‹çŠ¶æ€ã€‚"
        )

    except Exception as e:
        print(f"[ç¾¤å†…ç»‘å®šé”™è¯¯] {e}")
        import traceback
        traceback.print_exc()
        await event.respond("âŒ ç»‘å®šå¤±è´¥ï¼Œè¯·ç¨åé‡è¯•")


@multi_bot_on(events.NewMessage(pattern='/start'))
async def start_handler(event):
    """å¯åŠ¨å‘½ä»¤"""
    original_id = event.sender_id
    original_username = getattr(event.sender, 'username', None)
    telegram_id = get_main_account_id(original_id, original_username)
    
    username = event.sender.username or f'user_{original_id}'
    
    if original_id != telegram_id:
        print(f"âš ï¸ [Startå‘½ä»¤] æ£€æµ‹åˆ°å¤‡ç”¨å·ç™»å½•: {original_id} -> åˆ‡æ¢è‡³ä¸»è´¦å· {telegram_id}")
    
    # è§£ææ¨èäººID
    referrer_id = None
    if event.message.text and len(event.message.text.split()) > 1:
        try:
            referrer_id = int(event.message.text.split()[1])
        except BaseException:
            pass
    
    member = DB.get_member(telegram_id)
    
    if not member:
        print(f"[DEBUG] start_handler: æˆå‘˜ä¸å­˜åœ¨ï¼Œtelegram_id={telegram_id}, original_id={original_id}")
        # å¦‚æœæ˜¯å¤‡ç”¨å·æ˜ å°„ï¼Œæ£€æŸ¥ä¸»è´¦å·æ˜¯å¦å­˜åœ¨
        if original_id != telegram_id:
            print(f"âš ï¸ [å¤‡ç”¨å·è®¿é—®] å¤‡ç”¨å· {original_id} æ˜ å°„åˆ°ä¸»è´¦å· {telegram_id}")
            # æ£€æŸ¥ä¸»è´¦å·æ˜¯å¦å­˜åœ¨
            main_member = DB.get_member(telegram_id)
            print(f"[DEBUG] ä¸»è´¦å·æŸ¥è¯¢ç»“æœ: {main_member is not None}")
            if not main_member:
                # ä¸»è´¦å·ä¸å­˜åœ¨ï¼Œå…ˆä¸ºä¸»è´¦å·åˆ›å»ºè®°å½•
                print(f"âš ï¸ [å¤‡ç”¨å·è®¿é—®] ä¸»è´¦å· {telegram_id} ä¸å­˜åœ¨ï¼Œåˆ›å»ºä¸»è´¦å·è®°å½•")
                created = DB.create_member(telegram_id, username, referrer_id)
                print(f"[DEBUG] ä¸»è´¦å·åˆ›å»ºç»“æœ: {created}")
                main_member = DB.get_member(telegram_id)
                print(f"[DEBUG] ä¸»è´¦å·åˆ›å»ºåæŸ¥è¯¢ç»“æœ: {main_member is not None}")

            # ä¸ºå¤‡ç”¨å·åˆ›å»ºè®°å½•ï¼ˆå¦‚æœè¿˜æ²¡æœ‰çš„è¯ï¼‰
            backup_member = DB.get_member(original_id)
            print(f"[DEBUG] å¤‡ç”¨å·æŸ¥è¯¢ç»“æœ: {backup_member is not None}")
            if not backup_member:
                print(f"âš ï¸ [å¤‡ç”¨å·è®¿é—®] å¤‡ç”¨å· {original_id} ä¸å­˜åœ¨ï¼Œåˆ›å»ºå¤‡ç”¨å·è®°å½•")
                created = DB.create_member(original_id, username, referrer_id)
                print(f"[DEBUG] å¤‡ç”¨å·åˆ›å»ºç»“æœ: {created}")

        else:
            # æ™®é€šç”¨æˆ·æ³¨å†Œ
            print(f"[DEBUG] æ™®é€šç”¨æˆ·æ³¨å†Œ: telegram_id={telegram_id}")
            created = DB.create_member(telegram_id, username, referrer_id)
            print(f"[DEBUG] æ™®é€šç”¨æˆ·åˆ›å»ºç»“æœ: {created}")

        # ç°åœ¨ä¸»è´¦å·åº”è¯¥å­˜åœ¨äº†
        member = DB.get_member(telegram_id)
        print(f"[DEBUG] æœ€ç»ˆæˆå‘˜æŸ¥è¯¢ç»“æœ: {member is not None}")
        if not member:
            await event.respond('âŒ è´¦å·ä¿¡æ¯åˆ›å»ºå¤±è´¥ï¼Œè¯·ç¨åå†è¯•')
            return
        
        # é€šçŸ¥æ¨èäºº
        if referrer_id:
            referrer = DB.get_member(referrer_id)
            if referrer:
                try:
                    user_full_name = event.sender.first_name or f'user_{telegram_id}'
                    await bot.send_message(
                        referrer_id,
                        f'ğŸ‰ æ–°æˆå‘˜åŠ å…¥!\nç”¨æˆ·: [{user_full_name}](tg://user?id={telegram_id})\né€šè¿‡æ‚¨çš„æ¨å¹¿é“¾æ¥åŠ å…¥äº†æœºå™¨äºº\n\nå¿«å»å¼•å¯¼å¼€é€šVIPå®Œæˆä»»åŠ¡ï¼Œå¿«é€Ÿå‘å±•å›¢é˜Ÿã€‚',
                        parse_mode='markdown'
                    )
                except BaseException:
                    pass
    
    sys_config = get_system_config()
    pinned_ad = sys_config.get('pinned_ad', '')
    
    welcome_text = (
        f'ğŸ‘‹ æ¬¢è¿ä½¿ç”¨è£‚å˜æ¨å¹¿æœºå™¨äºº!\n\n'
        f'ğŸ‘¤ å½“å‰æ˜¾ç¤ºèº«ä»½ID: `{telegram_id}`\n'
        f'ğŸ’ VIPçŠ¶æ€: {"âœ… å·²å¼€é€š" if member["is_vip"] else "âŒ æœªå¼€é€š"}\n'
        f'ğŸ’° ä½™é¢: {member["balance"]} U\n\n'
        f'è¯·é€‰æ‹©åŠŸèƒ½:'
    )
    
    if pinned_ad:
        welcome_text += f'\n\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\nğŸ“¢ {pinned_ad}'
    
    await event.respond(welcome_text, buttons=get_main_keyboard(telegram_id))


@rate_limit_callback
@multi_bot_on(events.CallbackQuery(data=b'open_vip_balance'))
async def open_vip_balance_callback(event):
    """ã€å·²ä¿®å¤ã€‘ä½¿ç”¨ä½™é¢å¼€é€šVIP - ç»Ÿä¸€è°ƒç”¨ distribute_vip_rewards"""
    original_sender_id, resolved_id = get_resolved_sender_info(event)

    telegram_id = resolved_id
    member = DB.get_member(telegram_id)
    
    if not member:
        await event.answer("âŒ ç”¨æˆ·ä¿¡æ¯ä¸å­˜åœ¨", alert=True)
        return
    
    if member.get('is_vip'):
        await event.answer("âœ… æ‚¨å·²ç»æ˜¯VIPä¼šå‘˜", alert=True)
        return
    
    config = get_system_config()
    vip_price = compute_vip_price_from_config(config)
    user_balance = member.get('balance', 0)
    
    if user_balance < vip_price:
        await event.answer(f"âŒ ä½™é¢ä¸è¶³\nå½“å‰ä½™é¢: {user_balance} U\nVIPä»·æ ¼: {vip_price} U", alert=True)
        return
    
    # ã€æ ¸å¿ƒä¿®å¤ã€‘è°ƒç”¨ç»Ÿä¸€å¤„ç†å‡½æ•°
    success, result = await process_vip_upgrade(telegram_id, vip_price, config)
    
    if not success:
        await event.answer(f"âŒ {result}", alert=True)
        return
    
    stats = result['stats']
    new_balance = result['new_balance']
    
    text = f"""ğŸ‰ æ­å–œ! VIPå¼€é€šæˆåŠŸ!

âœ… æ‚¨å·²æˆä¸ºVIPä¼šå‘˜
ğŸ’° æ¶ˆè´¹é‡‘é¢: {vip_price} U
ğŸ’µ å‰©ä½™ä½™é¢: {new_balance} U

ğŸ ä¸Šçº§è·å¾— {stats["real"]} æ¬¡å¥–åŠ±
ğŸ’ æ¨èè´¦å·è·å¾— {stats["fallback"]} æ¬¡å¥–åŠ±"""
    
    # ä»¥æ¶ˆæ¯å½¢å¼å‘é€å¼€é€šæˆåŠŸé€šçŸ¥ï¼ˆé¿å…å¼¹çª— alertï¼‰ï¼Œå¹¶å°è¯•åˆ é™¤ä¹‹å‰çš„äº¤äº’æ¶ˆæ¯
    try:
        await event.respond(text)
    except BaseException:
        await event.answer(text, alert=True)
    try:
        await event.delete()
    except BaseException:
        pass


@rate_limit_callback
@multi_bot_on(events.CallbackQuery(pattern=b'confirm_vip'))
async def confirm_vip_callback(event):
    """ã€å·²ä¿®å¤ã€‘ç¡®è®¤å¼€é€šVIP - ç»Ÿä¸€è°ƒç”¨ distribute_vip_rewards"""
    config = get_system_config()
    original_sender_id, resolved_id = get_resolved_sender_info(event)

    member = DB.get_member(resolved_id)
    if not member:
        await event.answer('è¯·å…ˆå‘é€ /start æ³¨å†Œ')
        return
    
    if member['is_vip']:
        await event.answer('æ‚¨å·²ç»æ˜¯VIPäº†!')
        return
    
    vip_price = compute_vip_price_from_config(config)
    if member['balance'] < vip_price:
        await event.answer(f'ä½™é¢ä¸è¶³! è¿˜éœ€ {vip_price - member["balance"]} U', alert=True)
        return
    
    # ã€æ ¸å¿ƒä¿®å¤ã€‘è°ƒç”¨ç»Ÿä¸€å¤„ç†å‡½æ•°
    success, result = await process_vip_upgrade(event.sender_id, vip_price, config)
    
    if not success:
        await event.answer(f"âŒ {result}", alert=True)
        return
    
    stats = result['stats']
    
    await event.respond(
        f'ğŸ‰ æ­å–œ! VIPå¼€é€šæˆåŠŸ!\n\n'
        f'æ‚¨ç°åœ¨å¯ä»¥:\n'
        f'âœ… æŸ¥çœ‹è£‚å˜æ•°æ®\n'
        f'âœ… è·å¾—ä¸‹çº§å¼€é€šVIPçš„å¥–åŠ±\n'
        f'âœ… åŠ å…¥ä¸Šçº§ç¾¤ç»„\n'
        f'âœ… æ¨å¹¿èµšé’±',
        buttons=[[Button.inline('ğŸ”™ è¿”å›ä¸»èœå•', b'back_to_profile')]]
    )
    await event.answer()

# ==================== å……å€¼å¤„ç† ====================


async def send_recharge_notification(telegram_id, amount):
    """å‘é€å……å€¼æˆåŠŸé€šçŸ¥"""
    try:
        message = f"""âœ… å……å€¼æˆåŠŸ

ğŸ’° å……å€¼é‡‘é¢: {amount} USDT
ğŸ“ è®¢å•çŠ¶æ€: å·²å®Œæˆ
â° åˆ°è´¦æ—¶é—´: {get_cn_time()}

æ‚¨çš„ä½™é¢å·²è‡ªåŠ¨å¢åŠ ï¼Œå¯ä»¥åœ¨ä¸ªäººä¸­å¿ƒæŸ¥çœ‹ã€‚"""
        
        await bot.send_message(telegram_id, message)
        print(f'[å……å€¼é€šçŸ¥] å·²å‘é€é€šçŸ¥ç»™ç”¨æˆ· {telegram_id}')
    except Exception as e:
        print(f'[å……å€¼é€šçŸ¥] å‘é€å¤±è´¥: {e}')


async def process_recharge(telegram_id, amount, is_vip_order=False):
    """å¤„ç†å……å€¼åç»­é€»è¾‘"""
    try:
        config = get_system_config()
        member = DB.get_member(telegram_id)
        if not member:
            return False
            
        # Webç«¯å·²ç»å¢åŠ äº†ä½™é¢ï¼Œè¿™é‡Œç›´æ¥è·å–æœ€æ–°ä½™é¢
        current_balance = member.get('balance', 0)
        vip_price = compute_vip_price_from_config(config)

        if is_vip_order and not member.get(
                'is_vip', False) and current_balance >= vip_price:
            print(f'[å……å€¼å¤„ç†] å¼€å§‹VIPè‡ªåŠ¨å¼€é€š: telegram_id={telegram_id}')
            new_balance = current_balance - vip_price
            DB.update_member(
                telegram_id,
                balance=new_balance,
                is_vip=1,
                vip_time=get_cn_time())
            update_level_path(telegram_id)
            if bot:
                await distribute_vip_rewards(bot, telegram_id, vip_price, config)

            from core_functions import generate_vip_success_message
            msg = generate_vip_success_message(
                telegram_id, amount, vip_price, new_balance)
            if bot:
                try:
                    await bot.send_message(telegram_id, msg, parse_mode='markdown')
                except BaseException:
                    pass
        else:
            if not is_vip_order and bot:
                try:
                    await bot.send_message(telegram_id, f'âœ… å……å€¼åˆ°è´¦é€šçŸ¥\n\nğŸ’° é‡‘é¢: {amount} U\nğŸ’µ å½“å‰ä½™é¢: {current_balance} U')
                except BaseException:
                    pass
    except Exception as e:
        print(f"[å……å€¼å¤„ç†å¼‚å¸¸] {e}")
        return False

# ==================== ç®¡ç†å‘˜æ‰‹åŠ¨å¼€é€šVIP ====================


async def admin_manual_vip_handler(telegram_id, config):
    """
    ã€å·²ä¿®å¤ã€‘ç®¡ç†å‘˜æ‰‹åŠ¨å¼€é€šVIP
    ç»Ÿä¸€è°ƒç”¨ distribute_vip_rewardsï¼Œåˆ é™¤æ‰€æœ‰æ‰‹å†™åˆ†çº¢é€»è¾‘
    """
    member = DB.get_member(telegram_id)
    if not member:
        return False, "ç”¨æˆ·ä¸å­˜åœ¨"
    
    if member.get('is_vip'):
        return False, "ç”¨æˆ·å·²æ˜¯VIP"
    
    # ã€æ ¸å¿ƒä¿®å¤ã€‘è°ƒç”¨ç»Ÿä¸€å¤„ç†å‡½æ•°ï¼ˆä¸æ‰£é™¤ä½™é¢ï¼Œå› ä¸ºæ˜¯ç®¡ç†å‘˜èµ é€ï¼‰
    vip_price = compute_vip_price_from_config(config)
    success, result = await process_vip_upgrade(telegram_id, vip_price, config, deduct_balance=False)
    
    if not success:
        return False, result
    
    stats = result['stats']
    
    # é€šçŸ¥ç”¨æˆ·
    try:
        await bot.send_message(
            telegram_id,
            f'ğŸ‰ æ­å–œ! ç®¡ç†å‘˜å·²ä¸ºæ‚¨å¼€é€šVIP!\n\n'
            f'æ‚¨ç°åœ¨å¯ä»¥:\n'
            f'âœ… æŸ¥çœ‹è£‚å˜æ•°æ®\n'
            f'âœ… è·å¾—ä¸‹çº§å¼€é€šVIPçš„å¥–åŠ±\n'
            f'âœ… åŠ å…¥ä¸Šçº§ç¾¤ç»„\n'
            f'âœ… æ¨å¹¿èµšé’±\n\n'
            f'æ„Ÿè°¢æ‚¨çš„æ”¯æŒ!'
        )
    except Exception as e:
        print(f"é€šçŸ¥ç”¨æˆ·å¤±è´¥: {e}")
    
    return True, {
        'stats': stats,
        'username': member.get('username', '')
    }

# ==================== ç¾¤è£‚å˜åŠ å…¥ï¼ˆä¿®å¤ç‰ˆï¼‰====================


@multi_bot_on(events.NewMessage(pattern=BTN_FISSION))
async def fission_handler(event):
    """ç¾¤è£‚å˜åŠ å…¥ï¼ˆä¿®å¤ç‰ˆ - ä½¿ç”¨ get_upline_chainï¼‰"""
    telegram_id = get_main_account_id(
        event.sender_id, getattr(
            event.sender, 'username', None))
    member = DB.get_member(telegram_id)
    
    if not member:
        await event.respond("âŒ è¯·å…ˆä½¿ç”¨ /start å¼€å§‹")
        return
    
    config = get_system_config()
    
    # æ£€æŸ¥VIP
    if not member.get('is_vip'):
        vip_price = config.get('vip_price', 10)
        user_balance = member.get('balance', 0)
        need_recharge = vip_price - user_balance
        
        text = f"""âŒ æ‚¨è¿˜æœªå¼€é€šVIP

å¼€é€šVIPåå¯è·å¾—ä»¥ä¸‹æƒç›Š:
âœ… æŸ¥çœ‹è£‚å˜æ•°æ®
âœ… è·å¾—ä¸‹çº§å¼€é€šVIPçš„å¥–åŠ±
âœ… åŠ å…¥ä¸Šçº§ç¾¤ç»„

ğŸ’° VIPä»·æ ¼: {vip_price} U
ğŸ’µ æ‚¨çš„ä½™é¢: {user_balance} U"""
        
        if user_balance >= vip_price:
            buttons = [[Button.inline('ğŸ’ ä½™é¢å¼€é€šVIP', b'open_vip_balance')]]
        else:
            text += f"\n\nâŒ ä½™é¢ä¸è¶³ï¼Œè¯·å…ˆå……å€¼"
            buttons = [
                [Button.inline(f'ğŸ’° å……å€¼{need_recharge}Uå¼€é€šVIP', b'recharge_for_vip')]]
        
        await event.respond(text, buttons=buttons)
        return
    
    # å·²å¼€é€šVIPï¼Œç»Ÿä¸€æ˜¾ç¤ºæ‰€æœ‰éœ€è¦åŠ å…¥çš„ç¾¤ç»„ï¼ˆ1-10å±‚ï¼‰
    text = "ğŸ§§ä¸Šçº§ç¾¤å®Œæˆä»»åŠ¡è·å–æ›´å¤šèµ„æº\nÂ Â Â Â  çŸ¥è¯†æ›´å¥½å‘å±•å›¢é˜Ÿ\nâš ï¸æ¸©é¦¨æç¤ºtgæœºåˆ¶ä¸€æ¬¡æ€§åªèƒ½åŠ å…¥\n5ä¸ªç¾¤è¯·ä¼‘æ¯ä¸€å°æ—¶åç»§ç»­å®Œæˆ\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
    
    # è·å–ç³»ç»Ÿé…ç½®
    level_count = min(config.get('level_count', 10), 10)
    
    # ä½¿ç”¨ get_upline_chain è·å–å®Œæ•´çš„10å±‚å…³ç³»
    chain = get_upline_chain(telegram_id, level_count)
    
    # è·å–æ‰€æœ‰æ¡æ¼ç¾¤ç»„
    fb_groups = get_fallback_resource('group')
    # Debug: æ‰“å°æ¡æ¼ç¾¤ç»„åŸå§‹è¿”å›ï¼Œä¾¿äºè¯Šæ–­ä¸ºä½•ä¸ºç©ºæˆ–ä¸åŒ…å«é“¾æ¥
    print(
        f"[fission debug] get_fallback_resource('group') returned: {fb_groups}")
    try:
        conn_dbg = get_db_conn()
        c_dbg = conn_dbg.cursor()
        c_dbg.execute(
            "SELECT id, telegram_id, username, group_link, is_active FROM fallback_accounts ORDER BY id ASC")
        fb_rows = c_dbg.fetchall()
        print(f"[fission debug] fallback_accounts count: {len(fb_rows)}")
        for r in fb_rows:
            print(
                f"[fission debug] fallback_accounts row: id={r[0]}, telegram_id={r[1]}, username={r[2]}, is_active={r[4]}, group_link={r[3]}")
        conn_dbg.close()
    except Exception as dbg_e:
        print(f"[fission debug] error reading fallback_accounts: {dbg_e}")

    if not fb_groups:
        await event.respond("âŒ ç³»ç»Ÿé”™è¯¯ï¼šæ¡æ¼ç¾¤ç»„æœªé…ç½®ï¼Œè¯·è”ç³»ç®¡ç†å‘˜")
        return
    
    # æ„å»ºå±‚çº§æ˜ å°„ï¼šlevel -> ä¸Šçº§ä¿¡æ¯ï¼ˆå¦‚æœå­˜åœ¨ä¸”å®Œæˆä»»åŠ¡ï¼‰
    upline_map = {}
    for item in chain:
        if item.get('is_fallback'):
            continue
        level = item['level']
        upline_id = item['id']
        up_member = DB.get_member(upline_id)
        if up_member and up_member.get('group_link'):
            # æ£€æŸ¥ä¸Šçº§æ˜¯å¦å®Œæˆä»»åŠ¡
            try:
                conds = await check_user_conditions(bot, upline_id)
                if conds and conds['all_conditions_met']:
                    group_links = up_member['group_link'].split('\n')
                    for link in group_links:
                        if link.strip():
                            upline_map[level] = {
                                'link': link.strip(),
                                'upline_id': upline_id
                            }
                            break
            except Exception as e:
                print(f"[ç¾¤è£‚å˜åˆ—è¡¨] æ£€æŸ¥ç¬¬{level}å±‚ä¸Šçº§æ¡ä»¶å¤±è´¥: {e}")
    
    # æ„å»ºæœ€ç»ˆæ˜¾ç¤ºçš„ç¾¤ç»„åˆ—è¡¨ï¼ˆæŒ‰æ˜¾ç¤ºé¡ºåºå¡«å……ï¼šç¬¬1..ç¬¬Nï¼‰
    # è§„åˆ™è°ƒæ•´ï¼šå¦‚æœä¸Šçº§å­˜åœ¨å¹¶å®Œæˆä»»åŠ¡ï¼Œåº”è¯¥æ›¿æ¢æ˜¾ç¤ºåˆ—è¡¨çš„ä»åå‘å‰ä½ç½®ï¼š
    #   ä¸Š1çº§ (level=1) -> æ›¿æ¢æ˜¾ç¤ºç¬¬ N é¡¹ï¼ˆæœ€åä¸€é¡¹ï¼‰
    #   ä¸Š2çº§ (level=2) -> æ›¿æ¢æ˜¾ç¤ºç¬¬ N-1 é¡¹ï¼Œä¾æ­¤ç±»æ¨
    groups_to_show = [None] * level_count  # 0-based positions

    # å…ˆæŠŠä¸Šçº§ç¾¤æ”¾åˆ°å¯¹åº”æ˜¾ç¤ºä½ç½®ï¼ˆå¢åŠ å®æ—¶ç¾¤æƒæ£€æµ‹ï¼‰
    for item in chain:
        if item.get('is_fallback'):
            continue

        level = item['level']
        upline_id = item['id']
        up_member = DB.get_member(upline_id)

        # åªæœ‰å½“ä¸Šçº§è®¾ç½®äº†ç¾¤é“¾æ¥ï¼Œæ‰è¿›è¡Œæ·±å…¥æ£€æµ‹
        if up_member and up_member.get('group_link'):
            try:
                # 1. åŸºç¡€æ¡ä»¶æ£€æŸ¥ (DBå±‚é¢)
                conds = await check_user_conditions(bot, upline_id)

                # 2. å®æ—¶æƒé™æ£€æŸ¥ (APIå±‚é¢ - æ ¸å¿ƒä¿®æ”¹)
                # åªæœ‰å½“ DB æ˜¾ç¤ºæ¡ä»¶æ»¡è¶³æ—¶ï¼Œæ‰å» verify çœŸå®æƒé™ï¼ŒèŠ‚çœèµ„æº
                is_valid = False
                if conds and conds['all_conditions_met']:
                    group_link = up_member['group_link'].split('\n')[0].strip()
                    # ã€æ ¸å¿ƒã€‘è°ƒç”¨æ‡’åŠ è½½æ£€æµ‹
                    is_valid = await verify_and_handle_upline_group(bot, upline_id, group_link, clients)

                if is_valid:
                    pos = level_count - level  # 0-based index
                    if pos < 0 or pos >= level_count:
                        continue

                    group_name = f"ç¬¬{level}å±‚ä¸Šçº§"
                    # å°è¯•è·å–ç¾¤å (ä»£ç ä¿æŒä¸å˜...)
                    try:
                        if 't.me/' in group_link:
                            group_username = group_link.split(
                                't.me/')[-1].split('/')[0].split('?')[0]
                        elif group_link.startswith('@'):
                            group_username = group_link[1:]
                        else:
                            group_username = group_link

                        if not group_username.startswith('+'):
                            try:
                                group_entity = await bot.get_entity(group_username)
                                title = getattr(group_entity, 'title', None)
                                if title:
                                    group_name = title
                            except Exception:
                                # è·å–å®ä½“æˆ–æ ‡é¢˜å¤±è´¥ï¼Œä½¿ç”¨é»˜è®¤ group_name
                                pass
                    except Exception:
                        # group_link è§£æå¼‚å¸¸ï¼Œç»§ç»­ä½¿ç”¨é»˜è®¤ group_name
                        pass

                    # å¡«å……æ˜¾ç¤ºæ•°ç»„
                    groups_to_show[pos] = {
                        'level': level,
                        'link': group_link,
                        'name': group_name,
                        'type': 'upline'
                    }
                else:
                    # æ£€æµ‹ä¸é€šè¿‡ï¼Œè¯¥ä½ç½®ç•™ç©ºï¼Œåç»­ä¼šè‡ªåŠ¨å¡«å……æ¡æ¼
                    pass

            except Exception as e:
                print(f"[ç¾¤è£‚å˜åˆ—è¡¨] æ£€æŸ¥ç¬¬{level}å±‚ä¸Šçº§æ¡ä»¶å¤±è´¥: {e}")

    # ç”¨æ¡æ¼ç¾¤è¡¥å…¨å‰©ä½™ä½ç½®ï¼ˆæŒ‰ä»å‰åˆ°åæ˜ å°„çº§åˆ«ï¼‰
    for display_idx in range(level_count):
        if groups_to_show[display_idx] is None:
            # è¦è®¡ç®—è¯¥æ˜¾ç¤ºä½å¯¹åº”çš„å±‚çº§ï¼ˆåå‘ï¼‰ï¼š display_idx = level_count - level
            level_for_slot = level_count - display_idx
            fb_index = (level_for_slot - 1) % len(fb_groups)
            fb_group = fb_groups[fb_index]
            group_link = (fb_group.get('link') or '').strip()
            group_name = fb_group.get('name') or fb_group.get(
                'username') or f'æ¨èç¾¤ç»„ {level_for_slot}'
            try:
                if group_link:
                    actual_title = await get_group_title(bot, group_link)
                    if actual_title:
                        group_name = actual_title
            except BaseException:
                pass
            # Always fill the slot; if link missing, leave empty string and
            # display as plain text
            groups_to_show[display_idx] = {
                'level': level_for_slot,
                'link': group_link,
                'name': group_name,
                'type': 'fallback'
            }
    
    # ç»Ÿä¸€æ˜¾ç¤ºåœ¨"æ¨èåŠ å…¥çš„ç¾¤ç»„"ä¸­
    if groups_to_show:
        text += "ğŸ”¥ **æ¨èåŠ å…¥çš„ç¾¤ç»„ï¼š**\n"
        for idx, group_info in enumerate(groups_to_show, 1):
            # æ˜¾ç¤ºç¼–å·ä¸ºä»åå‘å‰ï¼ˆä¾‹å¦‚ level_count=10 åˆ™é¦–é¡¹æ˜¾ç¤ºä¸º 10ï¼‰
            display_num = level_count - (idx - 1)
            if not group_info:
                text += f"{display_num}. æœªé…ç½®\n"
                continue
            name = group_info.get('name') or f'æ¨èç¾¤ç»„ {display_num}'
            link = group_info.get('link') or ''
            if link:
                text += f"{display_num}. [{name}]({link})\n"
            else:
                text += f"{display_num}. {name}\n"
    else:
        await event.respond("âŒ æš‚æ— å¯ç”¨ç¾¤ç»„ï¼Œè¯·è”ç³»ç®¡ç†å‘˜é…ç½®æ¡æ¼è´¦å·ç¾¤é“¾æ¥ã€‚")
        return
        
    buttons = [
        [Button.inline('ğŸ” éªŒè¯å·²åŠ ç¾¤', f'verify_groups_{telegram_id}'.encode())]]
    await event.respond(text, buttons=buttons, parse_mode='markdown')

# ==================== æ³¨å†Œå…¶ä»–å‘½ä»¤å¤„ç†å™¨ ====================


@multi_bot_on(events.NewMessage(pattern=BTN_PROFILE))
async def profile_handler(event):
    """ä¸ªäººä¸­å¿ƒ (ä¿®å¤ç‰ˆ)"""
    original_id = event.sender_id
    print(f"[ä¸ªäººä¸­å¿ƒ] åŸå§‹è¯·æ±‚è€…ID: {original_id}")

    # ã€æ ¸å¿ƒä¿®å¤ã€‘è§£ææ­£ç¡®çš„è´¦å·IDï¼ˆæ”¯æŒå¤‡ç”¨å·æ˜ å°„ï¼‰
    resolved_id = resolve_sender_id(event)
    print(f"[ä¸ªäººä¸­å¿ƒ] è§£æç»“æœ: {original_id} -> {resolved_id}")

    # ç›´æ¥ä½¿ç”¨resolved_idæŸ¥è¯¢
    print(f"[ä¸ªäººä¸­å¿ƒ] æŸ¥è¯¢æ•°æ®åº“: telegram_id = {resolved_id}")
    member = DB.get_member(resolved_id)
    print(f"[ä¸ªäººä¸­å¿ƒ] æ•°æ®åº“æŸ¥è¯¢ç»“æœ: {member is not None}")

    if not member:
        # åªæœ‰å½“ç¡®å®æŸ¥ä¸åˆ°è®°å½•æ—¶ï¼Œæ‰æç¤ºæ³¨å†Œ
        print(f"[ä¸ªäººä¸­å¿ƒ] æœªæ‰¾åˆ°ä¼šå‘˜ä¿¡æ¯: {resolved_id}")
        await event.respond('âŒ æœªæ‰¾åˆ°è´¦å·ä¿¡æ¯ï¼Œè¯·å…ˆå‘é€ /start æ³¨å†Œ')
        return
    
    print(f"[ä¸ªäººä¸­å¿ƒ] æ‰¾åˆ°ä¼šå‘˜: {member.get('username')}")

    # è®°ä½è§£æåçš„IDï¼Œç”¨äºåç»­é€»è¾‘
    main_id = resolved_id

    # 4. æ„å»ºç•Œé¢ (ä¿æŒåŸæ ·)
    buttons = [
        [
            Button.inline(
                'ğŸ”— è®¾ç½®ç¾¤é“¾æ¥', b'set_group'), Button.inline(
                'âœï¸ è®¾ç½®å¤‡ç”¨å·', b'set_backup')], [
                    Button.inline(
                        'ğŸ’³ æç°', b'withdraw'), Button.inline(
                            'ğŸ’° å……å€¼', b'do_recharge'), Button.inline(
                                'ğŸ’ å¼€é€šVIP', b'open_vip')], [
                                    Button.inline(
                                        'ğŸ“Š æ”¶ç›Šè®°å½•', b'earnings_history')], ]
    
    backup_display = format_backup_account_display(
        member.get("backup_account"), member["telegram_id"])
    
    # è·å–æ¨èäººä¿¡æ¯
    referrer_info = ""
    if member.get("referrer_id"):
        referrer = DB.get_member(member["referrer_id"])
        if referrer:
            r_name = referrer.get("username", "")
            referrer_info = f'ğŸ‘¥ æ¨èäºº: @{r_name}' if r_name else f'ğŸ‘¥ æ¨èäººID: {member["referrer_id"]}'

    # æ˜¾ç¤ºä¿¡æ¯
    text = f'ğŸ‘¤ ä¸ªäººä¸­å¿ƒ\n\n'
    text += f'ğŸ†” è´¦å·ID: `{member["telegram_id"]}`\n'  # æ˜¾ç¤ºä¸»ID
    if original_id != main_id:
        text += f'ğŸ“± å½“å‰ç™»å½•: å¤‡ç”¨å· ({original_id})\n'
    text += f'ğŸ‘¤ ç”¨æˆ·å: @{member["username"]}\n'
    if referrer_info:
        text += f'{referrer_info}\n'
    text += f'ğŸ’ VIPçŠ¶æ€: {"âœ… å·²å¼€é€š" if member["is_vip"] else "âŒ æœªå¼€é€š"}\n'
    text += f'ğŸ’° ä½™é¢: {member["balance"]} U\n'
    text += f'ğŸ“‰ é”™è¿‡ä½™é¢: {member["missed_balance"]} U\n'
    text += f'ğŸ”— ç¾¤é“¾æ¥: {member["group_link"] or "æœªè®¾ç½®"}\n'
    text += f'ğŸ“± ç»‘å®šå¤‡ç”¨å·: {backup_display}\n'
    
    await event.respond(text, buttons=buttons)

# ==================== ä¸ªäººä¸­å¿ƒæŒ‰é’®å›è°ƒå¤„ç† ====================


@rate_limit_callback
@multi_bot_on(events.CallbackQuery(pattern=b'set_group'))
async def set_group_callback(event):
    """è®¾ç½®ç¾¤é“¾æ¥å›è°ƒ"""
    # è´¦å·å…³è”å¤„ç†ï¼ˆå¤‡ç”¨å·->ä¸»è´¦å·ï¼‰
    original_sender_id = event.sender_id
    main_id = get_main_account_id(
        original_sender_id, getattr(
            event.sender, 'username', None))

    member = DB.get_member(main_id)
    if not member:
        await event.answer('è¯·å…ˆå‘é€ /start æ³¨å†Œ')
        return

    # è®°ä½è§£æåçš„IDç”¨äºåç»­é€»è¾‘
    resolved_id = main_id

    # VIP check
    if not member.get('is_vip'):
        await send_vip_required_prompt(event)
        return
    
    # åˆ‡æ¢åˆ°ç¾¤é“¾æ¥è¾“å…¥æ—¶ï¼Œæ¸…ç†å¤‡ç”¨å·ç­‰å¾…çŠ¶æ€
    waiting_for_backup.pop(resolved_id, None)
    waiting_for_group_link[resolved_id] = True
    await event.respond(
        'ğŸ”— **è®¾ç½®ç¾¤é“¾æ¥**\n\n'
        '**æ–¹æ³• A (æ¨è)ï¼š**\n'
        '1. å°†æœºå™¨äººæ‹‰å…¥æ‚¨çš„ç¾¤ç»„\n'
        '2. å°†æœºå™¨äººè®¾ä¸ºç®¡ç†å‘˜\n'
        '3. åœ¨**ç¾¤ç»„å†…**å‘é€å‘½ä»¤ `/bind`\n'
        'âœ… è¿™ç§æ–¹å¼æœ€å‡†ç¡®ï¼Œèƒ½è‡ªåŠ¨è¯†åˆ«ç§æœ‰ç¾¤ID\n\n'
        '**æ–¹æ³• B (å‘é€é“¾æ¥)ï¼š**\n'
        'è¯·ç›´æ¥å‘é€ç¾¤é“¾æ¥ç»™æˆ‘ (æ ¼å¼: https://t.me/+xxx æˆ– @username)\n'
        'âš ï¸ æ³¨æ„ï¼šå¦‚æœæ˜¯ç§æœ‰é“¾æ¥ï¼Œè¯·**å…ˆå°†æœºå™¨äººæ‹‰è¿›ç¾¤**å†å‘é€ï¼Œå¦åˆ™æ— æ³•è¯†åˆ«ï¼\n\n'
        'å‘é€ /cancel å–æ¶ˆæ“ä½œ'
    )
    await event.answer()


@rate_limit_callback
@multi_bot_on(events.CallbackQuery(pattern=b'set_backup'))
async def set_backup_callback(event):
    """è®¾ç½®å¤‡ç”¨å·å›è°ƒ"""
    # è´¦å·å…³è”å¤„ç†ï¼ˆå¤‡ç”¨å·->ä¸»è´¦å·ï¼‰
    original_sender_id, resolved_id = get_resolved_sender_info(event)

    member = DB.get_member(resolved_id)
    if not member:
        await event.answer('è¯·å…ˆå‘é€ /start æ³¨å†Œ')
        return

    # VIP check
    if not member.get('is_vip'):
        await send_vip_required_prompt(event)
        return
    
    # åˆ‡æ¢åˆ°å¤‡ç”¨å·è¾“å…¥æ—¶ï¼Œæ¸…ç†ç¾¤é“¾æ¥ç­‰å¾…çŠ¶æ€
    waiting_for_group_link.pop(resolved_id, None)
    waiting_for_backup[resolved_id] = True
    await event.respond(
        'ğŸ’¡ é˜²æ­¢è¿™ä¸ªè´¦æˆ·è¢«TGå®˜æ–¹å°é”ï¼Œèµ„é‡‘æ— æ³•ä½¿ç”¨ã€‚ä½ å¯ä»¥åœ¨è¿™é‡Œæ·»åŠ å¤‡ç”¨è´¦æˆ·ã€‚å¯åŒæ—¶ç™»å½•è¿™ä¸ªè´¦æˆ·\n\n'
        'è¯·å‘é€ç›´æ¥æ‚¨æ²¡æ³¨å†Œè¿‡é£æœºå· (å¸¦@çš„ç”¨æˆ·åæˆ–ID)å¦‚: @qxzy7\n\n'
        'å‘é€ /cancel å–æ¶ˆæ“ä½œ'
    )
    await event.answer()


@rate_limit_callback
@multi_bot_on(events.CallbackQuery(pattern=b'earnings_history'))
async def earnings_history_callback(event):
    """æŸ¥çœ‹ä¸ªäººæ”¶ç›Šè®°å½•"""
    # è´¦å·å…³è”å¤„ç†ï¼ˆå¤‡ç”¨å·->ä¸»è´¦å·ï¼‰
    original_sender_id, resolved_id = get_resolved_sender_info(event)

    member = DB.get_member(resolved_id)
    
    if not member:
        await event.answer("âŒ ç”¨æˆ·ä¿¡æ¯ä¸å­˜åœ¨", alert=True)
        return

    # VIP check
    if not member.get('is_vip'):
        await send_vip_required_prompt(event)
        return
    
    conn = DB.get_conn()
    c = conn.cursor()
    # æ–°è¡¨ç»“æ„ï¼šè®°å½• upgraded_user (è°è§¦å‘å‡çº§), earning_user (è°è·å¾—æ”¶ç›Š), amount,
    # description, create_time
    c.execute('''
        SELECT upgraded_user, amount, description, create_time
        FROM earnings_records
        WHERE earning_user = ?
        ORDER BY create_time DESC
        LIMIT 50
    ''', (member["telegram_id"],))
    records = c.fetchall()
    conn.close()
    
    if not records:
        text = "ğŸ“Š æ”¶ç›Šè®°å½•\n\næš‚æ— æ”¶ç›Šè®°å½•"
        buttons = [[Button.inline('ğŸ”™ è¿”å›', b'back_to_profile')]]
    else:
        total = sum(r[1] for r in records)
        text = f"ğŸ“Š æ”¶ç›Šè®°å½•\n\n"
        text += f"ğŸ’° ç´¯è®¡æ”¶ç›Š: {total} U\n"
        text += f"ğŸ“ è®°å½•æ•°: {len(records)} æ¡\n\n"
        text += "æœ€è¿‘æ”¶ç›Šè®°å½•:\n"
        text += "â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
        
        for i, (upgraded_user, amount, desc,
                create_time) in enumerate(records[:20], 1):
            # å°è¯•è·å–å‡çº§è€…ç”¨æˆ·å
            try:
                upm = DB.get_member(upgraded_user) if upgraded_user else None
                up_name = f"@{upm['username']}" if upm and upm.get(
                    'username') else str(upgraded_user)
            except BaseException:
                up_name = str(upgraded_user)
            time_str = create_time[:16] if create_time else "æœªçŸ¥"
            text += f"{i}. +{amount} U â€” å‡çº§ç”¨æˆ·: {up_name}\n"
            text += f"   {desc or ''}\n"
            text += f"   {time_str}\n\n"
        
        if len(records) > 20:
            text += f"... è¿˜æœ‰ {len(records) - 20} æ¡è®°å½•\n"
        
        buttons = [[Button.inline('ğŸ”™ è¿”å›', b'back_to_profile')]]
    
    try:
        await event.edit(text, buttons=buttons)
    except BaseException:
        await event.respond(text, buttons=buttons)
    await event.answer()


@rate_limit_callback
@multi_bot_on(events.CallbackQuery(pattern=b'withdraw'))
async def withdraw_callback(event):
    """æç°å›è°ƒ"""
    config = get_system_config()

    # å¤‡ç”¨å·æ˜ å°„ï¼šå§‹ç»ˆä½¿ç”¨ä¸»è´¦å·ID
    try:
        mapped_id = get_main_account_id(
            event.sender_id, getattr(
                event.sender, 'username', None))
        effective_user_id = mapped_id if mapped_id != event.sender_id else event.sender_id
    except BaseException:
        effective_user_id = event.sender_id

    member = DB.get_member(effective_user_id)
    if not member:
        await event.answer('è¯·å…ˆå‘é€ /start æ³¨å†Œ')
        return

    if member['balance'] < config['withdraw_threshold']:
        await event.respond(
            'ğŸ’³ æç°\n\n'
            f'âŒ ä½™é¢æœªè¾¾åˆ°æç°é—¨æ§›\n\n'
            f'å½“å‰ä½™é¢: {member["balance"]} U\n'
            f'æç°é—¨æ§›: {config["withdraw_threshold"]} U\n'
            f'è¿˜éœ€: {config["withdraw_threshold"] - member["balance"]} U'
        )
    else:
        waiting_for_withdraw_amount[event.sender_id] = True
        await event.respond(
            f'ğŸ’³ æç°ç”³è¯·\n\n'
            f'å½“å‰ä½™é¢: {member["balance"]} U\n'
            f'æç°é—¨æ§›: {config["withdraw_threshold"]} U\n\n'
            f'è¯·è¾“å…¥æç°é‡‘é¢ï¼š'
        )
    await event.answer()


@rate_limit_callback
@multi_bot_on(events.CallbackQuery(pattern=b'do_recharge'))
async def do_recharge_callback(event):
    """å……å€¼å›è°ƒ"""
    # è´¦å·å…³è”å¤„ç†ï¼ˆå¤‡ç”¨å·->ä¸»è´¦å·ï¼‰
    try:
        original_sender_id = event.sender_id
        event.sender_id = get_main_account_id(
            original_sender_id, getattr(
                event.sender, 'username', None))
    except BaseException:
        pass
    telegram_id = event.sender_id
    member = DB.get_member(telegram_id)
    
    if not member:
        await event.answer("âŒ ç”¨æˆ·ä¿¡æ¯ä¸å­˜åœ¨", alert=True)
        return
    
    waiting_for_recharge_amount[telegram_id] = True
    
    text = """ğŸ’° å……å€¼ä½™é¢

è¯·è¾“å…¥æ‚¨è¦å……å€¼çš„é‡‘é¢ï¼ˆUSDTï¼‰

ä¾‹å¦‚: 200

âš ï¸ æ³¨æ„:
â€¢ ä»…æ”¯æŒTRC-20ç½‘ç»œUSDT
â€¢ æœ€ä½å……å€¼é‡‘é¢: 10 USDT
â€¢ å……å€¼åè‡ªåŠ¨åˆ°è´¦"""
    
    try:
        await event.edit(text)
    except BaseException:
        await event.respond(text)
    await event.answer()


@rate_limit_callback
@multi_bot_on(events.CallbackQuery(pattern=b'open_vip'))
async def open_vip_callback(event):
    """å¼€é€šVIP"""
    # è´¦å·å…³è”å¤„ç†ï¼ˆå¤‡ç”¨å·->ä¸»è´¦å·ï¼‰
    original_sender_id = event.sender_id
    try:
        mapped_id = get_main_account_id(
            original_sender_id, getattr(
                event.sender, 'username', None))
        # å¼ºåˆ¶ä½¿ç”¨æ˜ å°„åçš„ä¸»è´¦å·ID
        telegram_id = mapped_id if mapped_id != original_sender_id else original_sender_id
    except BaseException:
        telegram_id = original_sender_id
    member = DB.get_member(telegram_id)
    
    if not member:
        await event.answer("âŒ ç”¨æˆ·ä¿¡æ¯ä¸å­˜åœ¨", alert=True)
        return
    
    if member.get('is_vip'):
        await event.answer("âœ… æ‚¨å·²ç»æ˜¯VIPä¼šå‘˜", alert=True)
        return
    
    config = get_system_config()
    vip_price = config.get('vip_price', 10)
    user_balance = member.get('balance', 0)
    need_recharge = vip_price - user_balance
    
    text = f"""ğŸ’ å¼€é€šVIPä¼šå‘˜

VIPä»·æ ¼: {vip_price} U
å½“å‰ä½™é¢: {user_balance} U
è¿˜éœ€å……å€¼: {need_recharge} U

å¼€é€šVIPåæ‚¨å°†è·å¾—:
âœ… æŸ¥çœ‹è£‚å˜æ•°æ®
âœ… è·å¾—ä¸‹çº§å¼€é€šVIPçš„å¥–åŠ±
âœ… åŠ å…¥ä¸Šçº§ç¾¤ç»„
âœ… æ¨å¹¿èµšé’±åŠŸèƒ½"""
    
    if user_balance >= vip_price:
        # ä½™é¢è¶³å¤Ÿï¼Œç›´æ¥å°è¯•å¼€é€šï¼ˆè·³è¿‡é¢å¤–ç¡®è®¤ï¼‰
        try:
            success, result = await process_vip_upgrade(telegram_id, vip_price, config)
            if success:
                # æ˜¾ç¤ºæˆåŠŸæç¤º
                stats = result.get('stats', {})
                new_balance = result.get('new_balance', 0)
                text = f'ğŸ‰ æ­å–œ! VIPå¼€é€šæˆåŠŸ!\n\næ‚¨ç°åœ¨å¯ä»¥ä½¿ç”¨æ‰€æœ‰VIPåŠŸèƒ½ã€‚\n\næ¶ˆè´¹: {vip_price} U\nå‰©ä½™ä½™é¢: {new_balance} U'
                try:
                    await event.edit(text)
                except BaseException:
                    await event.respond(text)
                await event.answer()
                return
            else:
                # å¦‚æœå¤„ç†å¤±è´¥ï¼Œå›é€€åˆ°å±•ç¤ºå……å€¼/ç¡®è®¤ç•Œé¢
                text += f"\n\nâŒ å¼€é€šå¤±è´¥: {result}\n"
                buttons = [
                    [Button.inline(f'ğŸ’° å……å€¼{need_recharge}Uå¼€é€šVIP', b'recharge_for_vip')]]
        except Exception as e:
            print(f"[open_vip] ç›´æ¥å¼€é€šå¤±è´¥: {e}")
            text += f"\n\nâŒ å¼€é€šå¤±è´¥ï¼Œè¯·ç¨åé‡è¯•"
            buttons = [
                [Button.inline(f'ğŸ’° å……å€¼{need_recharge}Uå¼€é€šVIP', b'recharge_for_vip')]]
    else:
        # ä½™é¢ä¸è¶³ï¼Œæ˜¾ç¤ºå……å€¼æŒ‰é’®
        text += f"\n\nâŒ ä½™é¢ä¸è¶³ï¼Œè¯·å…ˆå……å€¼"
        buttons = [
            [Button.inline(f'ğŸ’° å……å€¼{need_recharge}Uå¼€é€šVIP', b'recharge_for_vip')]]
    
    try:
        await event.edit(text, buttons=buttons)
    except BaseException:
        await event.respond(text, buttons=buttons)
    await event.answer()

# è¿”å›ä¸ªäººä¸­å¿ƒ


@rate_limit_callback
@multi_bot_on(events.CallbackQuery(pattern=b'back_to_profile'))
async def back_to_profile_callback(event):
    """è¿”å›ä¸ªäººä¸­å¿ƒ"""
    # è´¦å·å…³è”å¤„ç†ï¼ˆå¤‡ç”¨å·->ä¸»è´¦å·ï¼‰
    try:
        original_sender_id = event.sender_id
        event.sender_id = get_main_account_id(
            original_sender_id, getattr(
                event.sender, 'username', None))
    except BaseException:
        pass
    member = DB.get_member(event.sender_id)
    if not member:
        await event.answer("âŒ ç”¨æˆ·ä¿¡æ¯ä¸å­˜åœ¨", alert=True)
        return
    
    buttons = [
        [
            Button.inline(
                'ğŸ”— è®¾ç½®ç¾¤é“¾æ¥', b'set_group'), Button.inline(
                'âœï¸ è®¾ç½®å¤‡ç”¨å·', b'set_backup')], [
                    Button.inline(
                        'ğŸ“Š æ”¶ç›Šè®°å½•', b'earnings_history')], [
                            Button.inline(
                                'ğŸ’³ æç°', b'withdraw'), Button.inline(
                                    'ğŸ’° å……å€¼', b'do_recharge'), Button.inline(
                                        'ğŸ’ å¼€é€šVIP', b'open_vip')], ]
    
    # æ ¼å¼åŒ–å¤‡ç”¨å·æ˜¾ç¤ºï¼ˆæ˜¾ç¤ºç”¨æˆ·åè€Œä¸æ˜¯IDï¼‰
    backup_display = format_backup_account_display(
        member.get("backup_account"), member["telegram_id"])
    
    text = (
        f'ğŸ‘¤ ä¸ªäººä¸­å¿ƒ\n\n'
        f'ğŸ†” ID: {member["telegram_id"]}\n'
        f'ğŸ‘¤ ç”¨æˆ·å: @{member["username"]}\n'
        f'ğŸ’ VIPçŠ¶æ€: {"âœ… å·²å¼€é€š" if member["is_vip"] else "âŒ æœªå¼€é€š"}\n'
        f'ğŸ’° ä½™é¢: {member["balance"]} U\n'
        f'ğŸ“‰ é”™è¿‡ä½™é¢: {member["missed_balance"]} U\n'
        f'ğŸ’µ ç´¯è®¡æ”¶ç›Š: {member.get("total_earned", 0)} U\n'
        f'ğŸ”— ç¾¤é“¾æ¥: {member["group_link"] or "æœªè®¾ç½®"}\n'
        f'ğŸ“± å¤‡ç”¨å·: {backup_display}\n'
        f'ğŸ“… æ³¨å†Œæ—¶é—´: {member["register_time"][:10] if member["register_time"] else "æœªçŸ¥"}')
    
    try:
        await event.edit(text, buttons=buttons)
    except BaseException:
        await event.respond(text, buttons=buttons)
    await event.answer()


@rate_limit_callback
@multi_bot_on(events.CallbackQuery(data=b'recharge_for_vip'))
async def recharge_for_vip_callback(event):
    """å……å€¼å¼€é€šVIP - è°ƒç”¨å……å€¼è¾“å…¥é‡‘é¢åŠŸèƒ½"""
    # è´¦å·å…³è”å¤„ç†ï¼ˆå¤‡ç”¨å·->ä¸»è´¦å·ï¼‰
    try:
        original_sender_id = event.sender_id
        event.sender_id = get_main_account_id(
            original_sender_id, getattr(
                event.sender, 'username', None))
    except BaseException:
        pass
    telegram_id = event.sender_id
    member = DB.get_member(telegram_id)
    
    if not member:
        await event.answer("âŒ ç”¨æˆ·ä¿¡æ¯ä¸å­˜åœ¨", alert=True)
        return
    
    # è·å–VIPä»·æ ¼ï¼Œè®¡ç®—éœ€è¦å……å€¼çš„é‡‘é¢
    config = get_system_config()
    vip_price = config.get('vip_price', 10)
    user_balance = member.get('balance', 0)
    need_recharge = vip_price - user_balance
    
    if need_recharge <= 0:
        await event.answer("âœ… ä½™é¢å……è¶³ï¼Œå¯ä»¥ç›´æ¥å¼€é€šVIP", alert=True)
        return
    
    # è°ƒç”¨å……å€¼è®¢å•åˆ›å»ºå‡½æ•°ï¼ˆä¼ å…¥botå‚æ•°ï¼‰
    try:
        from .payment import create_recharge_order
        await create_recharge_order(bot, event, need_recharge, is_vip_order=True)
    except Exception as e:
        print(f"[å……å€¼VIPè®¢å•åˆ›å»ºå¤±è´¥] {e}")
        import traceback
        traceback.print_exc()
        await event.respond("âŒ åˆ›å»ºå……å€¼è®¢å•å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•")
    await event.answer()


@rate_limit_callback
@multi_bot_on(events.CallbackQuery(pattern=rb'verify_groups_.*'))
async def verify_groups_callback(event):
    """éªŒè¯ç”¨æˆ·æ˜¯å¦åŠ å…¥æ‰€æœ‰éœ€è¦åŠ å…¥çš„ç¾¤ç»„ï¼ˆä¸Šçº§ç¾¤ + æ¡æ¼ç¾¤ç»„ï¼Œå…±10ä¸ªï¼‰"""
    # è´¦å·å…³è”å¤„ç†ï¼ˆå¤‡ç”¨å·->ä¸»è´¦å·ï¼‰
    try:
        original_sender_id = event.sender_id
        event.sender_id = get_main_account_id(
            original_sender_id, getattr(
                event.sender, 'username', None))
    except BaseException:
        pass
    
    telegram_id = event.sender_id
    member = DB.get_member(telegram_id)
    
    if not member:
        await event.answer("âŒ ç”¨æˆ·ä¿¡æ¯ä¸å­˜åœ¨", alert=True)
        return
    
    # ã€æ ¸å¿ƒä¿®å¤ã€‘å¦‚æœè¯¥ç”¨æˆ·å·²ç»å®Œæˆè¿‡"åŠ ç¾¤ä»»åŠ¡"ï¼Œåˆ™æ°¸ä¹…é”æ­»ï¼Œä¸å†é‡æ–°æ£€æµ‹
    if member.get('is_joined_upline'):
        await event.answer("âœ… åŠ ç¾¤ä»»åŠ¡å·²å®Œæˆï¼ˆæ°¸ä¹…é”å®šï¼‰", alert=False)
        try:
            await event.edit("âœ… **åŠ ç¾¤ä»»åŠ¡å·²å®Œæˆ**\n\nğŸ‰ æ‚¨å·²å®ŒæˆåŠ å…¥æ‰€æœ‰éœ€è¦åŠ å…¥çš„ç¾¤ç»„ï¼\n\næ‚¨ç°åœ¨å¯ä»¥è·å¾—ä¸‹çº§å¼€é€šVIPçš„åˆ†çº¢äº†ï¼")
        except BaseException:
            pass
        return
    
    await event.answer("ğŸ” æ­£åœ¨æ£€æµ‹ç¾¤ç»„åŠ å…¥æƒ…å†µï¼Œè¯·ç¨å€™...", alert=False)
    
    # ã€æ ¸å¿ƒä¿®å¤ã€‘åŠ ç¾¤ä»»åŠ¡ = å¿…é¡»åŠ å…¥1-10å±‚çš„ç¾¤ç»„ï¼ˆæ¯å±‚ï¼šæœ‰ä¸Šçº§ä¸”å®Œæˆä»»åŠ¡ç”¨ä¸Šçº§ç¾¤ï¼Œå¦åˆ™ç”¨æ¡æ¼ç¾¤ï¼‰
    config = get_system_config()
    required_groups_count = min(config.get('level_count', 10), 10)
    
    groups_to_check = []
    
    # è·å–å®Œæ•´çš„10å±‚å…³ç³»
    from core_functions import get_upline_chain
    chain = get_upline_chain(telegram_id, required_groups_count)
    
    # è·å–æ‰€æœ‰æ¡æ¼ç¾¤ç»„
    fb_groups = get_fallback_resource('group')
    if not fb_groups:
        await event.respond("âŒ ç³»ç»Ÿé”™è¯¯ï¼šæ¡æ¼ç¾¤ç»„æœªé…ç½®ï¼Œè¯·è”ç³»ç®¡ç†å‘˜")
        return
    
    # æ„å»ºå±‚çº§æ˜ å°„ï¼šlevel -> ä¸Šçº§ä¿¡æ¯ï¼ˆå¦‚æœå­˜åœ¨ä¸”å®Œæˆä»»åŠ¡ï¼‰
    upline_map = {}
    for item in chain:
        if item.get('is_fallback'):
            continue
        level = item['level']
        upline_id = item['id']
        up_member = DB.get_member(upline_id)
        if up_member and up_member.get('group_link'):
            # æ£€æŸ¥ä¸Šçº§æ˜¯å¦å®Œæˆä»»åŠ¡
            try:
                conds = await check_user_conditions(bot, upline_id)
                if conds and conds['all_conditions_met']:
                    group_links = up_member.get('group_link', '').split('\n')
                    for link in group_links:
                        link = link.strip()
                        if link:
                            upline_map[level] = {
                                'link': link,
                                'upline_id': upline_id
                            }
                            break
            except Exception as e:
                print(f"[éªŒè¯åŠ ç¾¤] æ£€æŸ¥ç¬¬{level}å±‚ä¸Šçº§æ¡ä»¶å¤±è´¥: {e}")
    
    # æ„å»ºéœ€è¦æ£€æŸ¥çš„ç¾¤ç»„åˆ—è¡¨ï¼ˆæŒ‰æ˜¾ç¤ºé¡ºåºï¼Œé‡‡ç”¨ä¸ fission_handler ç›¸åŒçš„ä»åå‘å‰æ›¿æ¢ç­–ç•¥ï¼‰
    groups_to_check = [None] * required_groups_count

    # å…ˆæŠŠçœŸå®ä¸Šçº§æ”¾åˆ°å¯¹åº”æ˜¾ç¤ºä½ç½®ï¼ˆä¸Š1çº§ -> æœ€åä¸€ä¸ªä½ç½®ï¼Œå«å®æ—¶æ£€æµ‹ï¼‰
    for level, info in upline_map.items():
        try:
            pos = required_groups_count - level
            if pos < 0 or pos >= required_groups_count:
                continue

            # ã€æ ¸å¿ƒã€‘å®æ—¶æ£€æµ‹ä¸Šçº§ç¾¤æœ‰æ•ˆæ€§
            upline_id = info.get('upline_id')
            group_link = info['link']
            is_valid = False

            if upline_id:
                # è°ƒç”¨æ‡’åŠ è½½æ£€æµ‹
                is_valid = await verify_and_handle_upline_group(bot, upline_id, group_link, clients)

            if is_valid:
                groups_to_check[pos] = {
                    'display_index': pos + 1,
                    'link': group_link,
                    'level': level,
                    'type': 'upline',
                    'group_name': f"ç¬¬{level}å±‚ä¸Šçº§",
                    'upline_id': upline_id
                }
            # å¦‚æœæ£€æµ‹ä¸é€šè¿‡ï¼Œè¯¥ä½ç½®ç•™ç©ºï¼Œåç»­ç”¨æ¡æ¼è¡¥å…¨

        except Exception as e:
            print(f"[éªŒè¯åŠ ç¾¤] æ„å»ºä¸Šçº§æ˜ å°„å¤±è´¥: {e}")

    # è¡¥å…¨ç©ºä½ä¸ºæ¡æ¼ç¾¤ç»„
    for display_pos in range(required_groups_count):
        if groups_to_check[display_pos] is None:
            # å¯¹åº”çš„å±‚çº§ï¼ˆåå‘æ˜ å°„ï¼‰
            level_for_slot = required_groups_count - display_pos
            fb_index = (level_for_slot - 1) % len(fb_groups)
            fb_group = fb_groups[fb_index]
            group_link = fb_group.get('link', '').strip()
            if group_link:
                groups_to_check[display_pos] = {
                    'display_index': display_pos + 1,
                    'link': group_link,
                    'level': level_for_slot,
                    'type': 'fallback',
                    'username': fb_group.get('username', ''),
                    'group_name': fb_group.get('name', '')
                }
    
    # è¿‡æ»¤ç©º
    groups_to_check = [g for g in groups_to_check if g is not None]
    if not groups_to_check:
        await event.respond("âŒ æ²¡æœ‰å¯éªŒè¯çš„ç¾¤ç»„")
        return
    
    # å»é‡ç¾¤ç»„ï¼ˆæŒ‰ link ä¿æŒé¡ºåºï¼‰ï¼Œæ£€æµ‹ç”¨æˆ·æ˜¯å¦åœ¨ç¾¤ç»„ä¸­
    seen_links = set()
    dedup_groups = []
    for g in groups_to_check:
        link = g.get('link') or ''
        if link and link not in seen_links:
            dedup_groups.append(g)
            seen_links.add(link)

    not_joined = []
    joined = []
    
    for group_info in dedup_groups:
        group_link = group_info['link']
        print(
            f"[verify_groups] æ£€æŸ¥ç¾¤: display_index={group_info.get('display_index')} level={group_info.get('level')} link={group_link}")
        try:
            # æå–ç¾¤ç»„ç”¨æˆ·åæˆ–ID
            if 't.me/' in group_link:
                group_username = group_link.split(
                    't.me/')[-1].split('/')[0].split('?')[0].replace('+', '')
            elif group_link.startswith('@'):
                group_username = group_link[1:]
            else:
                group_username = group_link
                
            # è·³è¿‡ç§æœ‰ç¾¤é“¾æ¥ï¼ˆæ— æ³•é€šè¿‡ç”¨æˆ·åæ£€æŸ¥æˆå‘˜ï¼‰
            if group_username.startswith('+'):
                not_joined.append(group_info)
                continue
            
            # å°è¯•è·å–ç¾¤ç»„å®ä½“
            try:
                group_entity = await bot.get_entity(group_username)
                
                # è®°å½•æ›´å‹å¥½çš„ç¾¤åç§°ï¼Œæ–¹ä¾¿åé¢å±•ç¤ºï¼ˆä¼˜å…ˆä½¿ç”¨å®é™…ç¾¤ç»„åç§°ï¼‰
                try:
                    title = getattr(group_entity, 'title', None)
                    if title:
                        group_info['group_name'] = title
                except Exception:
                    pass
                
                # æ£€æŸ¥ç”¨æˆ·æ˜¯å¦åœ¨ç¾¤ç»„ä¸­
                try:
                    from telethon.tl.functions.channels import GetParticipantRequest
                    participant = await bot(GetParticipantRequest(
                        channel=group_entity,
                        participant=telegram_id
                    ))
                    joined.append(group_info)
                    print(f"[verify_groups] å·²æ£€æµ‹åˆ°ç”¨æˆ·åŠ å…¥: {group_username}")
                except Exception as part_err:
                    not_joined.append(group_info)
                    print(
                        f"[verify_groups] ç”¨æˆ·æœªåŠ å…¥: {group_username} ({part_err})")
            except Exception as e:
                # æ— æ³•è·å–ç¾¤ç»„ä¿¡æ¯ï¼Œå¯èƒ½æ˜¯ç§æœ‰ç¾¤æˆ–é“¾æ¥æ— æ•ˆ
                not_joined.append(group_info)
                print(f"[verify_groups] è·å–ç¾¤ä¿¡æ¯å¤±è´¥: {group_link} ({e})")
        except Exception as e:
            not_joined.append(group_info)
            print(f"[verify_groups] å†…éƒ¨å¼‚å¸¸: {e}")
    
    # æ„å»ºç»“æœæ¶ˆæ¯
    total_groups = len(dedup_groups)
    joined_count = len(joined)
    not_joined_count = max(total_groups - joined_count, 0)
    print(
        f"[verify_groups] ç»Ÿè®¡: total_groups={total_groups}, joined_count={joined_count}, not_joined_count={not_joined_count}")
    
    # ã€æ ¸å¿ƒä¿®å¤ã€‘æ›´æ–°æ•°æ®åº“ä¸­çš„ is_joined_upline æ ‡å¿—ï¼ˆæ°¸ä¹…é”æ­»ï¼‰
    # å¿…é¡»å…¨éƒ¨10ä¸ªç¾¤ç»„éƒ½åŠ å…¥æ‰ç®—å®Œæˆï¼Œä¸€æ—¦å®Œæˆæ°¸ä¹…é”æ­»
    is_completed = False
    try:
        # å¿…é¡»å…¨éƒ¨åŠ å…¥æ‰ç®—å®Œæˆ
        if total_groups == required_groups_count and joined_count == total_groups and not member.get(
                'is_joined_upline'):
            DB.update_member(telegram_id, is_joined_upline=1)
            is_completed = True
            print(f"[éªŒè¯åŠ ç¾¤] ç”¨æˆ· {telegram_id} å·²å®ŒæˆåŠ ç¾¤ä»»åŠ¡ï¼ŒçŠ¶æ€å·²æ°¸ä¹…é”å®š")
        elif member.get('is_joined_upline'):
            # å¦‚æœå·²ç»å®Œæˆè¿‡ï¼Œç›´æ¥æ ‡è®°ä¸ºå®Œæˆï¼ˆæ°¸ä¹…é”æ­»ï¼‰
            is_completed = True
    except Exception as e:
        print(f"[verify_groups] æ›´æ–° is_joined_upline å¤±è´¥: {e}")
    
    # æ„å»ºç»“æœæ¶ˆæ¯ - å§‹ç»ˆæ˜¾ç¤ºç»Ÿè®¡ä¿¡æ¯
    text = f"ğŸ” **ç¾¤ç»„åŠ å…¥éªŒè¯ç»“æœ**\n\n"
    text += f"ğŸ“Š **æ€»è®¡**: {total_groups} ä¸ªç¾¤ç»„\n"
    text += f"âœ… **å·²åŠ å…¥**: {joined_count} ä¸ª\n"
    text += f"âŒ **æœªåŠ å…¥**: {not_joined_count} ä¸ª\n\n"
    
    # å¦‚æœå·²å®Œæˆï¼Œæ˜¾ç¤ºå®Œæˆæç¤º
    if is_completed:
        text += "ğŸ‰ **æ­å–œï¼æ‚¨å·²åŠ å…¥æ‰€æœ‰éœ€è¦åŠ å…¥çš„ç¾¤ç»„ï¼**\n\n"
        text += "âœ… æ‚¨ç°åœ¨å¯ä»¥è·å¾—ä¸‹çº§å¼€é€šVIPçš„åˆ†çº¢äº†ï¼\n\n"
        if joined:
            text += "**å·²åŠ å…¥çš„ç¾¤ç»„åˆ—è¡¨ï¼š**\n"
            for g in joined:
                group_name = g.get('group_name') or (g['link'].split(
                    't.me/')[-1].split('/')[0] if 't.me/' in g['link'] else g['link'])
                idx = g.get('display_index', g.get('level', '?'))
                text += f"  âœ… {idx}. {group_name}\n"
    else:
        # æœªå®Œæˆæ—¶ï¼Œæ˜¾ç¤ºè¯¦ç»†æ£€æµ‹ç»“æœ
        if joined:
            text += f"âœ… **å·²åŠ å…¥çš„ç¾¤ç»„** ({joined_count}ä¸ª):\n"
            for g in joined:
                group_name = g.get('group_name') or (g['link'].split(
                    't.me/')[-1].split('/')[0] if 't.me/' in g['link'] else g['link'])
                idx = g.get('display_index', g.get('level', '?'))
                text += f"  âœ… {idx}. {group_name}\n"
            text += "\n"
        
        if not_joined:
            text += f"âŒ **æœªåŠ å…¥çš„ç¾¤ç»„** ({not_joined_count}ä¸ªï¼Œè¯·ç‚¹å‡»åŠ å…¥):\n"
            for g in not_joined:
                group_name = g.get('group_name') or (g['link'].split(
                    't.me/')[-1].split('/')[0] if 't.me/' in g['link'] else g['link'])
                idx = g.get('display_index', g.get('level', '?'))
                link = g['link']
                # ç¡®ä¿é“¾æ¥æ ¼å¼æ­£ç¡®ï¼Œé¿å…Markdownè§£æé”™è¯¯
                if link and (link.startswith(
                        'http://') or link.startswith('https://') or link.startswith('@')):
                    # å¯¹é“¾æ¥ä¸­çš„ç‰¹æ®Šå­—ç¬¦è¿›è¡Œè½¬ä¹‰
                    safe_link = link.replace('(', '\\(').replace(')', '\\)')
                    text += f"  âŒ {idx}. [{group_name}]({safe_link})\n"
                else:
                    # å¦‚æœé“¾æ¥æ ¼å¼ä¸æ­£ç¡®ï¼Œåªæ˜¾ç¤ºåç§°ä¸åŠ é“¾æ¥
                    text += f"  âŒ {idx}. {group_name}\n"
            text += "\nâš ï¸ **é‡è¦æç¤º**ï¼šè¯·åŠ å…¥ä»¥ä¸ŠæœªåŠ å…¥çš„ç¾¤ç»„ï¼Œæ‰èƒ½è·å¾—åˆ†çº¢ï¼"
    
    try:
        await event.edit(text, parse_mode='markdown')
    except Exception as e:
        print(f"[verify_groups] editå¤±è´¥ï¼Œå°è¯•respond: {e}")
        try:
            await event.respond(text, parse_mode='markdown')
        except Exception as e2:
            print(f"[verify_groups] respondä¹Ÿå¤±è´¥: {e2}")
            # å¦‚æœMarkdownä¹Ÿå¤±è´¥ï¼Œå°è¯•ä¸ä½¿ç”¨Markdown
            try:
                plain_text = text.replace(
                    '[',
                    '').replace(
                    ']',
                    '').replace(
                    '(',
                    '').replace(
                    ')',
                    '').replace(
                    '*',
                    '').replace(
                        '_',
                    '')
                await event.respond(plain_text)
            except Exception as e3:
                print(f"[verify_groups] æ‰€æœ‰å‘é€æ–¹å¼éƒ½å¤±è´¥: {e3}")
                await event.answer("éªŒè¯å®Œæˆï¼Œä½†æ˜¾ç¤ºç»“æœæ—¶å‡ºç°é”™è¯¯", alert=True)


@multi_bot_on(events.NewMessage(pattern='/bind_group'))
async def bind_group_cmd(event):
    """ç»‘å®šç¾¤ç»„å‘½ä»¤ (ä¿®å¤ï¼šä¼ å…¥ event.client)"""
    # ä¼ é€’ event.client ä½œä¸º bot å‚æ•°ï¼Œç¡®ä¿ä½¿ç”¨æ­£ç¡®çš„æœºå™¨äººå®ä¾‹æ£€æµ‹æƒé™
    await handle_bind_group(event, event.client, DB)


@multi_bot_on(events.NewMessage(pattern='/join_upline'))
async def join_upline_cmd(event):
    """åŠ å…¥ä¸Šå±‚ç¾¤å‘½ä»¤"""
    await handle_join_upline(event, event.client, DB, get_system_config)


@multi_bot_on(events.NewMessage(pattern='/check_status'))
async def check_status_cmd(event):
    """æ£€æŸ¥çŠ¶æ€å‘½ä»¤"""
    await handle_check_status(event, event.client, DB)


@multi_bot_on(events.NewMessage(pattern='/my_team'))
async def my_team_cmd(event):
    """æˆ‘çš„å›¢é˜Ÿå‘½ä»¤"""
    await handle_my_team(event, event.client, DB)

# ==================== å…¶ä»–äº‹ä»¶å¤„ç†å™¨ ====================


@multi_bot_on(events.NewMessage(pattern=BTN_VIEW_FISSION))
async def view_fission_handler(event):
    """æŸ¥çœ‹è£‚å˜æ•°æ®"""
    original_sender_id = event.sender_id
    print(f"[DEBUG] view_fission_handler: original_sender_id = {original_sender_id}")

    # å¤‡ç”¨å·æ˜ å°„ï¼šå§‹ç»ˆä½¿ç”¨ä¸»è´¦å·ID
    try:
        mapped_id = get_main_account_id(
            original_sender_id, getattr(
                event.sender, 'username', None))
        print(f"[DEBUG] view_fission_handler: mapped_id = {mapped_id}")
        # å¼ºåˆ¶ä½¿ç”¨æ˜ å°„åçš„ä¸»è´¦å·ID
        effective_user_id = mapped_id if mapped_id != original_sender_id else original_sender_id
    except BaseException as e:
        print(f"[DEBUG] view_fission_handler: get_main_account_id failed: {e}")
        effective_user_id = original_sender_id

    print(f"[DEBUG] view_fission_handler: effective_user_id = {effective_user_id}")
    
    config = get_system_config()
    member = DB.get_member(effective_user_id)
    print(f"[DEBUG] view_fission_handler: member found = {member is not None}")
    if not member:
        await event.respond('è¯·å…ˆå‘é€ /start æ³¨å†Œ')
        return

    if not member['is_vip']:
        # ä½¿ç”¨ç»Ÿä¸€çš„VIPå¼€é€šæç¤º
        await send_vip_required_prompt(event)
        return

    conn = get_db_conn()
    c = conn.cursor()

    text = 'ğŸ“Š æˆ‘çš„è£‚å˜æ•°æ®\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”\nğŸ¥‡å¯é€šè¿‡å±‚çº§è”ç³»ä¸‹å±‚å¸¦é¢†\nÂ Â Â Â  å›¢é˜Ÿè¿…é€Ÿè£‚å˜\n'

    total_members = 0
    total_vip = 0
    buttons = []

    # è·å–å„çº§ä¸‹çº§ç”¨æˆ·å¹¶ç”ŸæˆæŒ‰é’®ï¼ˆå›ºå®š10å±‚ï¼Œä»ç¬¬10å±‚åˆ°ç¬¬1å±‚ï¼‰
    level_counts = {}  # å­˜å‚¨æ¯ä¸€å±‚çš„äººæ•°

    # è®¡ç®—æ¯ä¸€å±‚çš„ä¸‹çº§äººæ•°
    current_level_users = [member['telegram_id']]  # ä»è‡ªå·±å¼€å§‹

    for level in range(1, 11):  # å›ºå®šè®¡ç®—10å±‚
        if not current_level_users:
            # å¦‚æœä¸Šä¸€å±‚æ²¡æœ‰ç”¨æˆ·ï¼Œè¿™ä¸€å±‚è‚¯å®šä¹Ÿæ˜¯0
            level_counts[level] = 0
            continue

        # æŸ¥è¯¢å½“å‰å±‚çº§çš„ä¸‹çº§ç”¨æˆ·
        placeholders = ','.join(['?' for _ in current_level_users])
        c.execute(f"""
            SELECT telegram_id FROM members WHERE referrer_id IN ({placeholders})
        """, current_level_users)

        next_level_users = [row[0] for row in c.fetchall()]
        level_count = len(next_level_users)

        level_counts[level] = level_count
        total_members += level_count

        # è®¡ç®—VIPæ•°é‡
        if next_level_users:
            placeholders = ','.join(['?' for _ in next_level_users])
            c.execute(f"""
                SELECT COUNT(*) FROM members WHERE telegram_id IN ({placeholders}) AND is_vip = 1
            """, next_level_users)
            level_vip = c.fetchone()[0]
        else:
            level_vip = 0

        total_vip += level_vip

        # ä¸ºä¸‹ä¸€å±‚å¾ªç¯å‡†å¤‡æ•°æ®
        current_level_users = next_level_users

    # ç”ŸæˆæŒ‰é’®ï¼ˆä»ç¬¬10å±‚åˆ°ç¬¬1å±‚å€’åºæ˜¾ç¤ºï¼‰
    # ã€ä¿®æ”¹1ã€‘ç”ŸæˆæŒ‰é’®ï¼ˆä»ç¬¬1å±‚åˆ°ç¬¬10å±‚æ­£åºæ˜¾ç¤ºï¼‰
    for level in range(1, 11):
        level_count = level_counts.get(level, 0)
        btn_text = f'ç¬¬{level}å±‚: {level_count}äºº'
        buttons.append([Button.inline(btn_text, f'flv_{level}_1'.encode())])

    conn.close()

    text += f'â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n'
    text += f'ğŸ“ˆ å›¢é˜Ÿæ€»è®¡ï¼š{total_members}äºº\n'
    text += f'ğŸ’ VIPä¼šå‘˜ï¼š{total_vip}äºº\n'

    buttons.append([Button.inline('ğŸ  ä¸»èœå•', b'fission_main_menu')])

    await event.respond(text, buttons=buttons)


@rate_limit_callback
@multi_bot_on(events.CallbackQuery(pattern=rb'flv_(\d+)_(\d+)'))
async def flv_level_callback(event):
    """æŸ¥çœ‹æŒ‡å®šå±‚çš„ä¸‹çº§æˆå‘˜åˆ—è¡¨ï¼šflv_{level}_{page}"""
    try:
        import re
        m = re.match(rb'flv_(\d+)_(\d+)', event.data)
        if not m:
            await event.answer('å‚æ•°é”™è¯¯', alert=True)
            return
        level = int(m.group(1))
        page = int(m.group(2))
        if page < 1:
            page = 1

        telegram_id = get_main_account_id(
            event.sender_id, getattr(
                event.sender, 'username', None))
        conn = get_db_conn()
        c = conn.cursor()

        # é€å±‚æŸ¥æ‰¾ä¸‹çº§ï¼šä»å½“å‰ç”¨æˆ·å¼€å§‹ï¼Œå¾ªç¯ level æ¬¡
        current_ids = [telegram_id]
        for _ in range(level):
            if not current_ids:
                break
            placeholders = ','.join(['?'] * len(current_ids))
            c.execute(
                f"SELECT telegram_id FROM members WHERE referrer_id IN ({placeholders})",
                current_ids)
            rows = c.fetchall()
            current_ids = [r[0] for r in rows]

        members = []
        if current_ids:
            placeholders = ','.join(['?'] * len(current_ids))
            c.execute(
                f"SELECT telegram_id, username, is_vip FROM members WHERE telegram_id IN ({placeholders}) ORDER BY id DESC",
                current_ids)
            rows = c.fetchall()
            for r in rows:
                members.append(
                    {'telegram_id': r[0], 'username': r[1] or '', 'is_vip': bool(r[2])})

        conn.close()

        per_page = 15
        total = len(members)
        pages = (total + per_page - 1) // per_page if total > 0 else 1
        page = max(1, min(page, pages if pages > 0 else 1))
        start = (page - 1) * per_page
        end = start + per_page
        page_items = members[start:end]

        if not page_items:
            await event.answer(f'ç¬¬{level}å±‚æš‚æ— æˆå‘˜', alert=True)
            return

        text = f'ğŸ“‹ ç¬¬{level}å±‚æˆå‘˜ï¼ˆç¬¬{page}/{pages}é¡µï¼‰\n\n'
        for idx, m in enumerate(page_items, start + 1):
            name_display = f'@{m["username"]}' if m['username'] else str(
                m['telegram_id'])
            vip_tag = ' VIP' if m['is_vip'] else ''
            text += f'{idx}. {name_display} {vip_tag}\n'

        # æ„å»ºåˆ†é¡µå’Œè¿”å›æŒ‰é’®ï¼ˆä¸åœ¨ä¸‹é¢æ˜¾ç¤ºæ¯ä¸ªæˆå‘˜çš„è·³è½¬æŒ‰é’®ï¼‰
        btns = []
        nav = []
        if page > 1:
            nav.append(
                Button.inline(
                    'â¬…ï¸ ä¸Šé¡µ',
                    f'flv_{level}_{page-1}'.encode()))
        if page < pages:
            nav.append(
                Button.inline(
                    'ä¸‹é¡µ â¡ï¸',
                    f'flv_{level}_{page+1}'.encode()))
        if nav:
            btns.append(nav)
        btns.append([Button.inline('ğŸ”™ è¿”å›', b'fission_main_menu')])

        try:
            await event.edit(text, buttons=btns)
        except BaseException:
            await event.respond(text, buttons=btns)
    except Exception as e:
        print(f"[flv_callback] é”™è¯¯: {e}")
        await event.answer('åŠ è½½å¤±è´¥', alert=True)


@rate_limit_callback
@multi_bot_on(events.CallbackQuery(pattern=b'fission_main_menu'))
async def fission_main_menu_callback(event):
    """è¿”å›ä¸»èœå•"""
    try:
        # è·å–ç”¨æˆ·ä¿¡æ¯
        telegram_id = get_main_account_id(
            event.sender_id, getattr(
                event.sender, 'username', None))
        member = DB.get_member(telegram_id)

        if not member:
            await event.answer("âŒ ç”¨æˆ·ä¿¡æ¯ä¸å­˜åœ¨", alert=True)
            return

        # ç”Ÿæˆä¸»èœå•å†…å®¹ï¼ˆä¸start_handlerç›¸åŒï¼‰
        sys_config = get_system_config()
        pinned_ad = sys_config.get('pinned_ad', '')

        welcome_text = (
            f'ğŸ‘‹ æ¬¢è¿ä½¿ç”¨è£‚å˜æ¨å¹¿æœºå™¨äºº!\n\n'
            f'ğŸ‘¤ å½“å‰æ˜¾ç¤ºèº«ä»½ID: `{telegram_id}`\n'
            f'ğŸ’ VIPçŠ¶æ€: {"âœ… å·²å¼€é€š" if member["is_vip"] else "âŒ æœªå¼€é€š"}\n'
            f'ğŸ’° ä½™é¢: {member["balance"]} U\n\n'
            f'è¯·é€‰æ‹©åŠŸèƒ½:'
        )

        if pinned_ad:
            welcome_text += f'\n\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\nğŸ“¢ {pinned_ad}'

        # ç¼–è¾‘å½“å‰æ¶ˆæ¯ä¸ºæ–°çš„ä¸»èœå•å†…å®¹
        await event.edit(welcome_text, buttons=get_main_keyboard(telegram_id))

    except Exception as e:
        print(f"[fission_main_menu] é”™è¯¯: {e}")
        await event.answer('è¿”å›å¤±è´¥', alert=True)


@rate_limit_callback
@multi_bot_on(events.CallbackQuery(pattern=b'back_handler'))
async def back_handler_callback(event):
    """Callback ç‰ˆæœ¬çš„è¿”å›ä¸»èœå•"""
    await event.delete()
    # è§¦å‘ /start æ•ˆæœæˆ–å‘é€ä¸»èœå•
    await start_handler(event)


@multi_bot_on(events.NewMessage(pattern=BTN_PROMOTE))
async def promote_handler(event):
    """èµšé’±æ¨å¹¿"""
    try:
        original_sender_id = event.sender_id
        event.sender_id = get_main_account_id(
            original_sender_id, getattr(
                event.sender, 'username', None))
    except BaseException:
        pass
    
    config = get_system_config()
    member = DB.get_member(event.sender_id)
    if not member:
        await event.respond('è¯·å…ˆå‘é€ /start æ³¨å†Œ')
        return
    
    # ã€ä¿®å¤ã€‘ç§»é™¤äº†å¼ºåˆ¶VIPæ£€æŸ¥ï¼ŒéVIPä¹Ÿå¯ä»¥æ¨å¹¿èµšé’±
    
    # æœªå®Œæˆä¸Šçº§åŠ ç¾¤ä»»åŠ¡
    if not member.get('is_joined_upline', 0):
        await event.respond(
            "æŠ±æ­‰ï¼Œæ‚¨è¿˜æ²¡åŠ å…¥ä¸Šçº§ç¾¤ï¼Œä¸èƒ½ä½¿ç”¨æ­¤åŠŸèƒ½\n\n"
            "è¯·å…ˆæŒ‰ç…§è¦æ±‚åŠ å…¥ 10 çº§å…± 10 ä¸ªä¸Šçº§ç¾¤ï¼Œ\n"
            "å®Œæˆåå†å›æ¥ä½¿ç”¨æ¨å¹¿åŠŸèƒ½ã€‚",
            buttons=[[Button.inline('ğŸ” éªŒè¯æœªåŠ ç¾¤', f'verify_groups_{event.sender_id}'.encode())]]
        )
        return
    
    # æœªç»‘å®šè‡ªå·±ç¾¤
    if not member.get('group_link'):
        await event.respond(
            "æŠ±æ­‰ï¼Œæ‚¨è¿˜æ²¡æœ‰ç»‘å®šè‡ªå·±çš„ç¾¤ï¼Œä¸èƒ½ä½¿ç”¨æ­¤åŠŸèƒ½\n\n"
            "è¯·å…ˆç»‘å®šè‡ªå·±çš„ç¾¤ï¼Œå¹¶ç¡®ä¿å·²å°†æœºå™¨äººæ‹‰å…¥ç¾¤å¹¶è®¾ç½®ä¸ºç®¡ç†å‘˜ã€‚",
            buttons=[[Button.inline('ğŸ”— ç»‘å®šæˆ‘çš„ç¾¤', b'set_group')]]
        )
        return
    
    # ç”Ÿæˆæ¨å¹¿é“¾æ¥
    bot_info = await event.client.get_me()
    invite_link = f'https://t.me/{bot_info.username}?start={event.sender_id}'
    
    text = f'ğŸ’° èµšé’±æ¨å¹¿\n\n'
    text += f'æ‚¨çš„ä¸“å±æ¨å¹¿é“¾æ¥:\n{invite_link}\n\n'
    text += f'ğŸ“Š æ¨å¹¿è§„åˆ™:\n'
    text += f'â€¢ æ¯æœ‰ä¸€äººé€šè¿‡æ‚¨çš„é“¾æ¥å¼€é€šVIP\n'
    text += f'â€¢ æ‚¨å°†è·å¾— {config["level_reward"]} U å¥–åŠ±\n'
    text += f'â€¢ æœ€å¤šå¯è·å¾— {config["level_count"]} å±‚ä¸‹çº§å¥–åŠ±\n\n'
    text += f'ğŸ’¡ åˆ†äº«æ­¤é“¾æ¥ç»™å¥½å‹å³å¯å¼€å§‹èµšé’±!'
    
    # ã€ä¿®æ”¹3ã€‘æ”¹ä¸ºè°ƒç”¨TelegramåŸç”Ÿåˆ†äº«åŠŸèƒ½
    share_text = f"ã€èµ„æºè”ç›ŸÂ·è£‚å˜æœºå™¨äººã€‘å¼€å¯æ‚¨çš„ä¸“å±ç¦åˆ©ğŸ«\n\nğŸ§§åŠ å…¥ğŸ¤–å±äºæ‚¨æ°¸ä¹…æœºå™¨äººå·¥å…·ï¼Œè‡ªåŠ¨è¿…é€Ÿå¸®æ‚¨å¿«é€Ÿè£‚å˜èµ„æºï¼è§£å†³æ‚¨äººè„‰é—®é¢˜ã€‚\n\nğŸ‘‰ å‰æ²¿äº’åŠ¨å·¥å…·æ¯ä¸ªäººåŠ å…¥æ‚¨ç¾¤èƒ½ä¸»åŠ¨ç»™ä½ 1U ï¼ğŸ’µ\n\nğŸ‘‰ å¿«é€Ÿè£‚å˜èµ„æºç²‰ä¸ ğŸš€ï¼Œæ— éœ€ç»å°½è„‘æ±æ¨å¹¿ç²‰ä¸ï¼\n\nğŸ‰ åˆ†äº«é‚€è¯·æœ‹å‹ä¸€èµ·å‘å±•ï¼Œå¿«é€Ÿå‘å±•å›¢é˜Ÿå±äºè‡ªå·±è£‚å˜æœºå™¨äºº\n\nğŸ‰ã€èµ„æºè”ç›ŸÂ·è£‚å˜æœºå™¨äººã€‘â€”â€” è¶…å‰æ²¿ç§‘æŠ€ã€å·¥å…·ã€åçº§è£‚å˜å¿«é€Ÿå‘å±•èµ„æºï¼\n\nğŸ‘‡ ç‚¹å‡»é“¾æ¥è·å–å·¥å…·ï¼š\n{invite_link}"
    share_url = f"https://t.me/share/url?text={quote(share_text)}"

    await event.respond(text, buttons=[[Button.url('ğŸ“¤ ç«‹å³æ¨å¹¿ (é€‰æ‹©å¥½å‹/ç¾¤)', share_url)]])


@multi_bot_on(events.NewMessage(pattern=BTN_RESOURCES))
async def resources_handler(event):
    """è¡Œä¸šèµ„æº"""
    try:
        original_sender_id = event.sender_id
        event.sender_id = get_main_account_id(
            original_sender_id, getattr(
                event.sender, 'username', None))
    except BaseException:
        pass
    await show_resource_categories(event, page=1, is_new=True)


async def show_resource_categories(event, page=1, is_new=False):
    """æ˜¾ç¤ºèµ„æºåˆ†ç±»ï¼ˆæ–‡æœ¬åˆ—è¡¨ï¼Œåˆ†é¡µï¼Œæ¯é¡µ25æ¡ï¼‰"""
    categories = DB.get_resource_categories(0)

    if not categories:
        msg = 'ğŸ¯è¡Œä¸šèµ„æº\n\næš‚æ— èµ„æºåˆ†ç±»'
        if is_new:
            await event.respond(msg)
        else:
            await event.edit(msg)
        return

    # æ–‡æœ¬åˆ—è¡¨åˆ†é¡µï¼šæ¯é¡µ25ä¸ªåˆ†ç±»ï¼ˆé€‚åˆæ˜¾ç¤ºä¸ºåˆ—è¡¨ï¼‰
    per_page = 25
    total = len(categories)
    total_pages = (total + per_page - 1) // per_page
    page = max(1, min(page, total_pages))

    start = (page - 1) * per_page
    end = start + per_page
    page_categories = categories[start:end]

    # æ„å»ºç®€æ´çš„é¡µé¢ï¼Œåªæ˜¾ç¤ºæ ‡é¢˜å’Œæè¿°ï¼Œé€šè¿‡æŒ‰é’®é€‰æ‹©åˆ†ç±»
    text = f'ğŸ¯è¡Œä¸šèµ„æº\né€šè¿‡ç§‘æŠ€åˆ›æ–°ï¼Œä¸ºå¹¿å¤§è¡Œä¸šä¼™ä¼´ "åŠ©åŠ›"\nä¸ºä¸šå†…ä¼ é€’æ›´å¤šçš„ä»·å€¼ğŸ’µ\nğŸ•µâ€â™‚é€šè¿‡ä¸‹æ–¹é€‰æ‹©è‡ªå·±è¡Œä¸šå¯»æ‰¾å®è´µèµ„æº\nå¦‚éœ€å…¥é©»è¯·è”ç³»å®¢æœğŸ‘©â€ğŸ’»ğŸ§‘â€ğŸ’»ğŸ‘¨â€ğŸ’»'

    buttons = []

    # æ¯è¡Œ3ä¸ªæŒ‰é’®æ’åˆ—
    current_row = []
    for cat in page_categories:
        current_row.append(
            Button.inline(
                cat["name"],
                f'cat_{cat["id"]}'.encode()))
        if len(current_row) == 3:
            buttons.append(current_row)
            current_row = []
    # å¤„ç†å‰©ä½™çš„æŒ‰é’®
    if current_row:
        buttons.append(current_row)

    # åˆ†é¡µæ§åˆ¶æŒ‰é’®
    nav = []
    if page > 1:
        nav.append(Button.inline('< ä¸Šä¸€é¡µ', f'catpg_{page-1}'.encode()))
    if page < total_pages:
        nav.append(Button.inline('ä¸‹ä¸€é¡µ >', f'catpg_{page+1}'.encode()))
    if nav:
        buttons.append(nav)

    buttons.append([Button.inline('< è¿”å›', b'res_back_main')])

    try:
        if is_new:
            await event.respond(text, buttons=buttons)
        else:
            await event.edit(text, buttons=buttons)
    except BaseException:
        # fallback without buttons
        if is_new:
            await event.respond(text)
        else:
            await event.edit(text)


# ç‚¹å‡»åˆ†ç±»å›è°ƒï¼šæ˜¾ç¤ºè¯¥åˆ†ç±»ä¸‹çš„èµ„æº
@rate_limit_callback
@multi_bot_on(events.CallbackQuery(pattern=rb'cat_(\d+)'))
async def category_callback(event):
    try:
        data = event.data.decode()
        cid = int(data.replace('cat_', ''))
        # ä½¿ç”¨DB.get_resourcesè¿›è¡Œåˆ†é¡µè¯»å–
        per_page = 25
        page = 1
        result = DB.get_resources(cid, page=page, per_page=per_page)

        items = result.get('items', [])
        total = result.get('total', 0)
        pages = result.get('pages', 1)

        if not items:
            await event.answer('è¯¥åˆ†ç±»æš‚æ— èµ„æº', alert=True)
            return

        def fmt_count(n):
            try:
                n = int(n)
            except BaseException:
                return str(n)
            if n >= 1000:
                v = round(n / 1000.0, 1)
                if v.is_integer():
                    return f'{int(v)}K'
                return f'{v}K'
            return str(n)

        # æ„å»ºæ–‡æœ¬åˆ—è¡¨ï¼ˆæ¯è¡ŒåŒ…å«å›¾æ ‡ã€åç§°ã€äººæ•°å’Œé“¾æ¥ï¼‰
        text_lines = [
            f'ğŸ“‚ èµ„æºåˆ—è¡¨ï¼ˆåˆ†ç±»ID: {cid}ï¼‰\nå…± {total} æ¡ï¼Œæ˜¾ç¤ºç¬¬ {page}/{pages} é¡µ\n']
        for it in items:
            icon = 'ğŸ‘¥' if (it.get('type') or '').lower() == 'group' else 'ğŸ“£'
            name = it.get('name') or 'æœªå‘½å'
            link = it.get('link') or ''
            count_str = fmt_count(it.get('count') or 0)
            # å®‰å…¨è½¬ä¹‰ä¸­æ‹¬å·å’Œåœ†æ‹¬å· in markdown link text
            safe_name = name.replace('[', '\\[').replace(']', '\\]').replace(
                '(', '\\(').replace(')', '\\)')
            if link:
                text_lines.append(f'{icon} [{safe_name}]({link}) {count_str}')
            else:
                text_lines.append(f'{icon} {safe_name} {count_str}')

        text = '\n'.join(text_lines)

        # æ„å»ºåˆ†é¡µæŒ‰é’®
        btns = []
        nav = []
        if page > 1:
            nav.append(
                Button.inline(
                    '< ä¸Šä¸€é¡µ',
                    f'res_page_{cid}_{page-1}'.encode()))
        if page < pages:
            nav.append(
                Button.inline(
                    'ä¸‹ä¸€é¡µ >',
                    f'res_page_{cid}_{page+1}'.encode()))
        if nav:
            btns.append(nav)
        btns.append([Button.inline('ğŸ”™ è¿”å›åˆ†ç±»', b'back_to_categories')])

        try:
            await event.edit(text, buttons=btns, parse_mode='markdown')
        except BaseException:
            await event.respond(text, buttons=btns, parse_mode='markdown')
    except Exception as e:
        print(f"[category_callback] é”™è¯¯: {e}")
        await event.answer('åŠ è½½å¤±è´¥', alert=True)


@rate_limit_callback
@multi_bot_on(events.CallbackQuery(pattern=rb'back_to_categories'))
async def back_to_categories_callback(event):
    """è¿”å›åˆ†ç±»åˆ—è¡¨ï¼ˆåŒ show_resource_categories ç¬¬1é¡µï¼‰"""
    try:
        await show_resource_categories(event, page=1, is_new=False)
        await event.answer()
    except Exception as e:
        print(f"[back_to_categories] é”™è¯¯: {e}")
        await event.answer('è¿”å›å¤±è´¥', alert=True)


@rate_limit_callback
@multi_bot_on(events.CallbackQuery(pattern=rb'res_page_(\d+)_(\d+)'))
async def resource_page_callback(event):
    """å¤„ç†èµ„æºé¡µé¢æŒ‰é’®"""


@rate_limit_callback
@multi_bot_on(events.CallbackQuery(data=b'res_back_main'))
async def resource_back_main_callback(event):
    """å¤„ç†èµ„æºé¡µé¢è¿”å›ä¸»èœå•æŒ‰é’®"""
    # è´¦å·å…³è”å¤„ç†ï¼ˆå¤‡ç”¨å·->ä¸»è´¦å·ï¼‰
    original_sender_id = event.sender_id
    try:
        mapped_id = get_main_account_id(
            original_sender_id, getattr(event.sender, 'username', None))
        telegram_id = mapped_id if mapped_id != original_sender_id else original_sender_id
    except BaseException:
        telegram_id = original_sender_id

    member = DB.get_member(telegram_id)
    if not member:
        await event.answer("âŒ ç”¨æˆ·ä¿¡æ¯ä¸å­˜åœ¨", alert=True)
        return

    # è¿”å›ä¸»èœå•ï¼ˆè¿™é‡Œåº”è¯¥è°ƒç”¨æ˜¾ç¤ºä¸»èœå•çš„é€»è¾‘ï¼‰
    # ç®€å•èµ·è§ï¼Œå…ˆç»™ä¸ªæç¤º
    await event.answer("è¿”å›ä¸»èœå•", alert=True)


@rate_limit_callback
@multi_bot_on(events.CallbackQuery(pattern=rb'catpg_(\d+)'))
async def category_page_callback(event):
    """å¤„ç†åˆ†ç±»é¡µé¢åˆ†é¡µæŒ‰é’®"""
    try:
        data = event.data.decode()
        page = int(data.replace('catpg_', ''))

        # è´¦å·å…³è”å¤„ç†ï¼ˆå¤‡ç”¨å·->ä¸»è´¦å·ï¼‰
        original_sender_id = event.sender_id
        try:
            mapped_id = get_main_account_id(
                original_sender_id, getattr(event.sender, 'username', None))
            telegram_id = mapped_id if mapped_id != original_sender_id else original_sender_id
        except BaseException:
            telegram_id = original_sender_id

        # è·å–åˆ†ç±»å¹¶æ˜¾ç¤ºå¯¹åº”é¡µé¢çš„åˆ†ç±»
        categories = DB.get_categories()
        if not categories:
            await event.answer("æš‚æ— åˆ†ç±»", alert=True)
            return

        # è®¡ç®—åˆ†é¡µ
        per_page = 15  # æ¯é¡µæ˜¾ç¤ºçš„åˆ†ç±»æ•°é‡
        total_categories = len(categories)
        total_pages = (total_categories + per_page - 1) // per_page

        if page < 1 or page > total_pages:
            await event.answer("æ— æ•ˆé¡µé¢", alert=True)
            return

        start_idx = (page - 1) * per_page
        end_idx = start_idx + per_page
        page_categories = categories[start_idx:end_idx]

        # æ„å»ºé¡µé¢å†…å®¹ï¼ˆå¤ç”¨show_resourceså‡½æ•°çš„é€»è¾‘ï¼‰
        text = f'ğŸ¯è¡Œä¸šèµ„æº\nè¿‡ç§‘æŠ€åˆ›æ–°ï¼Œä¸ºå¹¿å¤§è¡Œä¸šä¼™ä¼´ "åŠ©åŠ›"\nä¸ºä¸šå†…ä¼ é€’æ›´å¤šçš„ä»·å€¼ğŸ’µ\nğŸ•µâ€â™‚é€šè¿‡ä¸‹æ–¹é€‰æ‹©è‡ªå·±è¡Œä¸šå¯»æ‰¾å®è´µèµ„æº\nå¦‚éœ€å…¥é©»è¯·è”ç³»å®¢æœğŸ‘©â€ğŸ’»ğŸ§‘â€ğŸ’»ğŸ‘¨â€ğŸ’»'

        buttons = []

        # æ¯è¡Œ3ä¸ªæŒ‰é’®æ’åˆ—
        current_row = []
        for cat in page_categories:
            current_row.append(
                Button.inline(
                    cat["name"],
                    f'cat_{cat["id"]}'.encode()))
            if len(current_row) == 3:
                buttons.append(current_row)
                current_row = []
        # å¤„ç†å‰©ä½™çš„æŒ‰é’®
        if current_row:
            buttons.append(current_row)

        # åˆ†é¡µæ§åˆ¶æŒ‰é’®
        nav = []
        if page > 1:
            nav.append(Button.inline('< ä¸Šä¸€é¡µ', f'catpg_{page-1}'.encode()))
        if page < total_pages:
            nav.append(Button.inline('ä¸‹ä¸€é¡µ >', f'catpg_{page+1}'.encode()))
        if nav:
            buttons.append(nav)

        buttons.append([Button.inline('< è¿”å›', b'res_back_main')])

        await event.edit(text, buttons=buttons)

    except Exception as e:
        print(f"åˆ†ç±»åˆ†é¡µå¤„ç†é”™è¯¯: {e}")
        await event.answer("å¤„ç†å¤±è´¥", alert=True)
    """åˆ†é¡µèµ„æºæ˜¾ç¤ºï¼šres_page_{category_id}_{page}"""
    try:
        data = event.data.decode()
        parts = data.replace('res_page_', '').split('_')
        cid = int(parts[0])
        page = int(parts[1])
        per_page = 25
        result = DB.get_resources(cid, page=page, per_page=per_page)
        items = result.get('items', [])
        total = result.get('total', 0)
        pages = result.get('pages', 1)

        if not items:
            await event.answer('è¯¥é¡µæš‚æ— èµ„æº', alert=True)
            return

        def fmt_count(n):
            try:
                n = int(n)
            except BaseException:
                return str(n)
            if n >= 1000:
                v = round(n / 1000.0, 1)
                if v.is_integer():
                    return f'{int(v)}K'
                return f'{v}K'
            return str(n)

        text_lines = [
            f'ğŸ“‚ èµ„æºåˆ—è¡¨ï¼ˆåˆ†ç±»ID: {cid}ï¼‰\nå…± {total} æ¡ï¼Œæ˜¾ç¤ºç¬¬ {page}/{pages} é¡µ\n']
        for it in items:
            icon = 'ğŸ‘¥' if (it.get('type') or '').lower() == 'group' else 'ğŸ“£'
            name = it.get('name') or 'æœªå‘½å'
            link = it.get('link') or ''
            count_str = fmt_count(it.get('count') or 0)
            safe_name = name.replace('[', '\\[').replace(']', '\\]').replace(
                '(', '\\(').replace(')', '\\)')
            if link:
                text_lines.append(
                    f'{icon} [{safe_name} ({count_str})]({link})')
            else:
                text_lines.append(f'{icon} {safe_name} ({count_str})')

        text = '\n'.join(text_lines)
        btns = []
        nav = []
        if page > 1:
            nav.append(
                Button.inline(
                    '< ä¸Šä¸€é¡µ',
                    f'res_page_{cid}_{page-1}'.encode()))
        if page < pages:
            nav.append(
                Button.inline(
                    'ä¸‹ä¸€é¡µ >',
                    f'res_page_{cid}_{page+1}'.encode()))
        if nav:
            btns.append(nav)
        btns.append([Button.inline('ğŸ”™ è¿”å›åˆ†ç±»', b'back_to_categories')])

        try:
            await event.edit(text, buttons=btns, parse_mode='markdown')
        except BaseException:
            await event.respond(text, buttons=btns, parse_mode='markdown')
    except Exception as e:
        print(f"[resource_page_callback] é”™è¯¯: {e}")
        await event.answer('åŠ è½½å¤±è´¥', alert=True)


@multi_bot_on(events.NewMessage(pattern=BTN_SUPPORT))
async def support_handler(event):
    """åœ¨çº¿å®¢æœ"""
    try:
        original_sender_id = event.sender_id
        event.sender_id = get_main_account_id(
            original_sender_id, getattr(
                event.sender, 'username', None))
    except BaseException:
        pass
    
    # è·å–å®¢æœåˆ—è¡¨
    services = DB.get_customer_services()
    
    if not services:
        # å¦‚æœæ²¡æœ‰å®¢æœï¼Œæ˜¾ç¤ºåå°é…ç½®çš„æ–‡æœ¬
        config = get_system_config()
        await event.respond(config['support_text'])
        return
    
    # æ„å»ºå®¢æœåˆ—è¡¨
    text = 'ğŸ‘©â€ğŸ’¼ åœ¨çº¿å®¢æœ\n\nè¯·é€‰æ‹©å®¢æœè¿›è¡Œå’¨è¯¢:\n\n'
    buttons = []
    
    for service in services:
        text += f'â€¢ {service["name"]}\n'
        # è½¬æ¢é“¾æ¥æ ¼å¼
        link = service['link']
        if link.startswith('@'):
            link = f'https://t.me/{link[1:]}'
        elif not link.startswith('http'):
            link = f'https://t.me/{link}'
        
        buttons.append([Button.url(f'ğŸ’¬ è”ç³» {service["name"]}', link)])
    
    await event.respond(text, buttons=buttons, parse_mode='md')


@multi_bot_on(events.NewMessage(pattern=BTN_VIP))
async def vip_handler(event):
    """å¼€é€šä¼šå‘˜"""
    original_sender_id = event.sender_id

    # å¤‡ç”¨å·æ˜ å°„ï¼šå§‹ç»ˆä½¿ç”¨ä¸»è´¦å·ID
    try:
        mapped_id = get_main_account_id(
            original_sender_id, getattr(
                event.sender, 'username', None))
        # å¼ºåˆ¶ä½¿ç”¨æ˜ å°„åçš„ä¸»è´¦å·ID
        effective_user_id = mapped_id if mapped_id != original_sender_id else original_sender_id
    except BaseException:
        effective_user_id = original_sender_id
    
    member = DB.get_member(effective_user_id)
    if not member:
        await event.respond('è¯·å…ˆå‘é€ /start æ³¨å†Œ')
        return
    
    if member['is_vip']:
        await event.respond(
            'ğŸ’ æ‚¨å·²ç»æ˜¯VIPä¼šå‘˜!\n\n'
            f'å¼€é€šæ—¶é—´: {member["vip_time"][:10] if member["vip_time"] else "æœªçŸ¥"}'
        )
        return
    
    # è·å–æœ€æ–°é…ç½®
    config = get_system_config()
    
    # æ£€æŸ¥ä½™é¢æ˜¯å¦è¶³å¤Ÿ
    if member['balance'] >= config['vip_price']:
        await event.respond(
            f'ğŸ’ å¼€é€šVIPä¼šå‘˜\n\n'
            f'ğŸ… VIPä»·æ ¼: {config["vip_price"]} U\n'
            f'ğŸ¦ å½“å‰ä½™é¢: {member["balance"]} U\n\n'
            f'--------------------\n\n'
            f'å¼€é€šVIPåæ‚¨å°†è·å¾—:\n'
            f'âœ… æŸ¥çœ‹è£‚å˜æ•°æ®\n'
            f'âœ… åçº§è£‚å˜VIPå¥–åŠ±\n'
            f'âœ… åŠ å…¥ä¸Šçº§ç¾¤ç»„\n'
            f'âœ… æœºå™¨äººæ¨é€ç¾¤è£‚å˜\n'
            f'âœ… æ‹“å±•èµ„æºè£‚å˜è´¢å¯Œ\n\n'
            f'âœ… ä½™é¢å……è¶³ï¼Œå¯ä»¥ç›´æ¥å¼€é€š',
            buttons=[[Button.inline('ğŸ’³ ç¡®è®¤å¼€é€š', b'confirm_vip')]]
        )
    else:
        await event.respond(
            f'ğŸ’ å¼€é€šVIPä¼šå‘˜\n\n'
            f'ğŸ… VIPä»·æ ¼: {config["vip_price"]} U\n'
            f'ğŸ¦ å½“å‰ä½™é¢: {member["balance"]} U\n'
            f'ğŸ’¹ è¿˜éœ€å……å€¼: {config["vip_price"] - member["balance"]} U\n\n'
            f'--------------------\n\n'
            f'å¼€é€šVIPåæ‚¨å°†è·å¾—:\n'
            f'âœ… æŸ¥çœ‹è£‚å˜æ•°æ®\n'
            f'âœ… åçº§è£‚å˜VIPå¥–åŠ±\n'
            f'âœ… åŠ å…¥ä¸Šçº§ç¾¤ç»„\n'
            f'âœ… æœºå™¨äººæ¨é€ç¾¤è£‚å˜\n'
            f'âœ… æ‹“å±•èµ„æºè£‚å˜è´¢å¯Œ\n\n'
            f'âŒ ä½™é¢ä¸è¶³ï¼Œè¯·å…ˆå……å€¼',
            buttons=[[Button.inline(f'ğŸ’° å……å€¼ {config["vip_price"]} U å¼€é€šVIP', b'recharge_for_vip')]]
        )


@multi_bot_on(events.NewMessage(pattern=BTN_MY_PROMOTE))
async def my_promote_handler(event):
    """æˆ‘çš„æ¨å¹¿"""
    original_sender_id = event.sender_id
    print(f"[DEBUG] my_promote_handler: original_sender_id = {original_sender_id}")

    # å¤‡ç”¨å·æ˜ å°„ï¼šå§‹ç»ˆä½¿ç”¨ä¸»è´¦å·ID
    try:
        mapped_id = get_main_account_id(
            original_sender_id, getattr(
                event.sender, 'username', None))
        print(f"[DEBUG] my_promote_handler: mapped_id = {mapped_id}")
        # å¼ºåˆ¶ä½¿ç”¨æ˜ å°„åçš„ä¸»è´¦å·ID
        effective_user_id = mapped_id if mapped_id != original_sender_id else original_sender_id
    except BaseException as e:
        print(f"[DEBUG] my_promote_handler: get_main_account_id failed: {e}")
        effective_user_id = original_sender_id

    print(f"[DEBUG] my_promote_handler: effective_user_id = {effective_user_id}")
    
    config = get_system_config()
    member = DB.get_member(effective_user_id)
    print(f"[DEBUG] my_promote_handler: member found = {member is not None}")
    if not member:
        await event.respond('è¯·å…ˆå‘é€ /start æ³¨å†Œ')
        return
    
    # ã€ä¿®å¤ã€‘ç§»é™¤äº†å¼ºåˆ¶VIPæ£€æŸ¥ï¼ŒéVIPä¹Ÿå¯ä»¥æŸ¥çœ‹è‡ªå·±çš„æ¨å¹¿æ•°æ®
    
    # è·å–ä¸‹çº§ç»Ÿè®¡
    counts = DB.get_downline_count(event.sender_id, config['level_count'])
    total_members = sum(c['total'] for c in counts)
    total_vip = sum(c['vip'] for c in counts)
    
    # ç”Ÿæˆæ¨å¹¿é“¾æ¥
    bot_info = await event.client.get_me()
    invite_link = f'https://t.me/{bot_info.username}?start={event.sender_id}'
    
    text = f'ğŸ æˆ‘çš„æ¨å¹¿\n\n'
    text += f'ğŸ“Š æ¨å¹¿ç»Ÿè®¡:\n'
    text += f'ğŸ’æ€»ä¸‹çº§: {total_members} äºº\n'
    text += f'ğŸ’ VIPä¸‹çº§: {total_vip} äºº\n'
    text += f'ğŸ’ç´¯è®¡æ”¶ç›Š: {member["balance"]} U\n'
    text += f'ğŸ’é”™è¿‡æ”¶ç›Š: {member["missed_balance"]} U\n\n'
    text += f'ğŸ”— æ‚¨çš„æ¨å¹¿é“¾æ¥:\n{invite_link}\n\n'
    text += f'ğŸ’¡ åˆ†äº«é“¾æ¥é‚€è¯·å¥½å‹ï¼Œå¯è¿…é€Ÿè£‚å˜\nåçº§å¥½å‹å¼€é€šVIPæ‚¨éƒ½å¯è·å¾— {config["level_reward"]} U å¥–åŠ±!'
    
    # ã€ä¿®æ”¹3ã€‘æ”¹ä¸ºè°ƒç”¨TelegramåŸç”Ÿåˆ†äº«åŠŸèƒ½
    share_text = f"ã€èµ„æºè”ç›ŸÂ·è£‚å˜æœºå™¨äººã€‘å¼€å¯æ‚¨çš„ä¸“å±ç¦åˆ©ğŸ«\n\nğŸ§§åŠ å…¥ğŸ¤–å±äºæ‚¨æ°¸ä¹…æœºå™¨äººå·¥å…·ï¼Œè‡ªåŠ¨è¿…é€Ÿå¸®æ‚¨å¿«é€Ÿè£‚å˜èµ„æºï¼è§£å†³æ‚¨äººè„‰é—®é¢˜ã€‚\n\nğŸ‘‰ å‰æ²¿äº’åŠ¨å·¥å…·æ¯ä¸ªäººåŠ å…¥æ‚¨ç¾¤èƒ½ä¸»åŠ¨ç»™ä½ 1U ï¼ğŸ’µ\n\nğŸ‘‰ å¿«é€Ÿè£‚å˜èµ„æºç²‰ä¸ ğŸš€ï¼Œæ— éœ€ç»å°½è„‘æ±æ¨å¹¿ç²‰ä¸ï¼\n\nğŸ‰ åˆ†äº«é‚€è¯·æœ‹å‹ä¸€èµ·å‘å±•ï¼Œå¿«é€Ÿå‘å±•å›¢é˜Ÿå±äºè‡ªå·±è£‚å˜æœºå™¨äºº\n\nğŸ‰ã€èµ„æºè”ç›ŸÂ·è£‚å˜æœºå™¨äººã€‘â€”â€” è¶…å‰æ²¿ç§‘æŠ€ã€å·¥å…·ã€åçº§è£‚å˜å¿«é€Ÿå‘å±•èµ„æºï¼\n\nğŸ‘‡ ç‚¹å‡»é“¾æ¥è·å–å·¥å…·ï¼š\n{invite_link}"
    share_url = f"https://t.me/share/url?text={quote(share_text)}"

    buttons = [[Button.url('ğŸ“¤ ç«‹å³æ¨å¹¿ (é€‰æ‹©å¥½å‹/ç¾¤)', share_url)]]
    
    await event.respond(text, buttons=buttons, parse_mode='md')


@multi_bot_on(events.NewMessage(pattern=BTN_BACK))
async def back_handler(event):
    """è¿”å›ä¸»èœå•"""
    try:
        original_sender_id = event.sender_id
        event.sender_id = get_main_account_id(
            original_sender_id, getattr(
                event.sender, 'username', None))
    except BaseException:
        pass
    
    member = DB.get_member(event.sender_id)
    if not member:
        await event.respond('è¯·å…ˆå‘é€ /start æ³¨å†Œ')
        return
    
    await event.respond(
        f'ğŸ¤– è£‚å˜æ¨å¹¿æœºå™¨äºº\n\n'
        f'ğŸ‘¤ ç”¨æˆ·: @{member["username"]}\n'
        f'ğŸ’ VIPçŠ¶æ€: {"âœ… å·²å¼€é€š" if member["is_vip"] else "âŒ æœªå¼€é€š"}\n'
        f'ğŸ’° ä½™é¢: {member["balance"]} U\n\n'
        f'è¯·é€‰æ‹©åŠŸèƒ½:',
        buttons=get_main_keyboard(event.sender_id)
    )


@multi_bot_on(events.NewMessage(pattern=BTN_ADMIN))
async def admin_handler(event):
    """ç®¡ç†åå°"""
    try:
        original_sender_id = event.sender_id
        event.sender_id = get_main_account_id(
            original_sender_id, getattr(
                event.sender, 'username', None))
    except BaseException:
        pass
    
    if event.sender_id not in ADMIN_IDS:
        return
    
    # è·å–ç³»ç»Ÿé…ç½®
    config = get_system_config()
    
    text = f'âš™ï¸ ç®¡ç†åå°\n\n'
    text += f'å½“å‰è®¾ç½®:\n'
    text += f'ğŸ“Š å±‚æ•°: {config["level_count"]} å±‚\n'
    text += f'ğŸ’° æ¯å±‚è¿”åˆ©: {config["level_reward"]} U\n'
    text += f'ğŸ’ VIPä»·æ ¼: {config["vip_price"]} U\n'
    _fb_group = get_fallback_resource("group")
    if _fb_group:
        text += f"\n\nğŸ’¡ æ¨èç¾¤ç»„:\n{_fb_group}"
    text += f'ğŸ’³ æç°é—¨æ§›: {config["withdraw_threshold"]} U\n'
    text += f'ğŸ’µ USDTåœ°å€: {config["usdt_address"][:10] if config["usdt_address"] else "æœªè®¾ç½®"}...{config["usdt_address"][-10:] if config["usdt_address"] and len(config["usdt_address"]) > 20 else ""}\n\n'
    text += f'å®¢æœæ–‡æœ¬:\n{config["support_text"]}\n\n'
    from .config import USE_PROXY, PUBLIC_BASE_URL
    web_url = PUBLIC_BASE_URL or ('http://localhost:5051' if USE_PROXY else '')
    if web_url:
        text += f'ğŸŒ Webç®¡ç†åå°: {web_url}'
    
    buttons = [
        [
            Button.inline(
                'ğŸ“Š è®¾ç½®å±‚æ•°', b'admin_set_level'), Button.inline(
                'ğŸ’° è®¾ç½®è¿”åˆ©', b'admin_set_reward')], [
                    Button.inline(
                        'ğŸ’ è®¾ç½®VIPä»·æ ¼', b'admin_set_vip_price'), Button.inline(
                            'ğŸ’³ è®¾ç½®æç°é—¨æ§›', b'admin_set_withdraw')], [
                                Button.inline(
                                    'ğŸ‘©â€ğŸ’¼ è®¾ç½®å®¢æœæ–‡æœ¬', b'admin_set_support'), Button.inline(
                                        'ğŸ’« æŸ¥çœ‹ä¼šå‘˜ç»Ÿè®¡', b'admin_stats')], [
                                            Button.inline(
                                                'ğŸ æ‰‹åŠ¨å……å€¼VIP', b'admin_manual_vip'), Button.inline(
                                                    'ğŸ“¢ ç”¨æˆ·å¹¿æ’­', b'admin_broadcast')]]
    
    await event.respond(text, buttons=buttons, parse_mode='md')

# ==================== ç¾¤ç»„æ¬¢è¿å’Œè‡ªåŠ¨æ³¨å†Œ ====================


@multi_bot_on(events.Raw(types=(UpdateChannelParticipant,
              UpdateChatParticipantAdmin)))
async def raw_permission_handler(event):
    """
    ã€æ ¸å¿ƒä¿®å¤ã€‘ç›‘å¬åŸå§‹æ›´æ–°ï¼Œä¸“é—¨æ•è·æƒé™å˜æ›´ã€‚
    Telegram åœ¨è¶…çº§ç¾¤ä¸­ï¼Œç®¡ç†å‘˜å˜æ›´ä¸ºæ™®é€šæˆå‘˜æ—¶ï¼Œä¼šå‘é€ UpdateChannelParticipantã€‚
    """
    try:
        # å¤„ç†ä¸åŒæ ¼å¼çš„äº‹ä»¶å¯¹è±¡ï¼šæœ‰äº›æœ‰updateå±æ€§ï¼Œæœ‰äº›ç›´æ¥å°±æ˜¯æ›´æ–°å¯¹è±¡
        update = event.update if hasattr(event, 'update') else event

        # 1. å¤„ç†è¶…çº§ç¾¤ç»„/é¢‘é“æˆå‘˜å˜æ›´ (è¿™æ˜¯æœ€å¸¸è§çš„æƒ…å†µ)
        if isinstance(update, UpdateChannelParticipant):
            # è·å–å˜åŠ¨çš„ç”¨æˆ·ID
            user_id = update.user_id
            channel_id = update.channel_id

            # æ£€æŸ¥æ˜¯å¦æ˜¯æˆ‘ä»¬çš„æœºå™¨äºº
            is_our_bot = False
            target_bot = None
            for client in clients:
                try:
                    me = await client.get_me()
                    if me.id == user_id:
                        is_our_bot = True
                        target_bot = client
                        break
                except BaseException:
                    continue

            if not is_our_bot:
                return

            # åˆ†ææ–°æ—§çŠ¶æ€
            prev = update.prev_participant
            new_p = update.new_participant

            was_admin = isinstance(
                prev, (ChannelParticipantAdmin, ChannelParticipantCreator))
            is_now_admin = isinstance(
                new_p, (ChannelParticipantAdmin, ChannelParticipantCreator))

            # å…³é”®åˆ¤å®šï¼šä¹‹å‰æ˜¯ç®¡ç†å‘˜ï¼Œç°åœ¨ä¸æ˜¯äº†
            if was_admin and not is_now_admin:
                print(f"[Rawæ£€æµ‹] ğŸš¨ è¶…çº§ç¾¤ {channel_id}: æœºå™¨äºº {user_id} è¢«æ’¤é”€ç®¡ç†å‘˜")
                await notify_group_binding_invalid(channel_id, user_id, "ç®¡ç†å‘˜æƒé™è¢«æ’¤é”€", target_bot)

        # 2. å¤„ç†æ™®é€šç¾¤ç»„ç®¡ç†å‘˜å˜æ›´
        elif isinstance(update, UpdateChatParticipantAdmin):
            user_id = update.user_id
            chat_id = update.chat_id
            is_admin = update.is_admin

            # æ£€æŸ¥æ˜¯å¦æ˜¯æˆ‘ä»¬çš„æœºå™¨äººè¢«å–æ¶ˆäº†ç®¡ç†å‘˜
            is_our_bot = False
            target_bot = None
            for client in clients:
                try:
                    me = await client.get_me()
                    if me.id == user_id:
                        is_our_bot = True
                        target_bot = client
                        break
                except BaseException:
                    continue

            if is_our_bot and not is_admin:
                print(f"[Rawæ£€æµ‹] ğŸš¨ æ™®é€šç¾¤ {chat_id}: æœºå™¨äºº {user_id} è¢«æ’¤é”€ç®¡ç†å‘˜")
                await notify_group_binding_invalid(chat_id, user_id, "ç®¡ç†å‘˜æƒé™è¢«æ’¤é”€", target_bot)

    except Exception as e:
        print(f"[Rawæ£€æµ‹] é”™è¯¯: {e}")

# ==================== æƒé™æ£€æŸ¥å’Œé€šçŸ¥å‡½æ•° ====================


async def check_permission_changes():
    """å®šæœŸæ£€æŸ¥æ‰€æœ‰ç»‘å®šç¾¤ç»„çš„æœºå™¨äººæƒé™çŠ¶æ€"""
    try:
        print("[æƒé™æ£€æŸ¥] å¼€å§‹å®šæœŸæƒé™çŠ¶æ€æ£€æŸ¥...")

        # è·å–æ‰€æœ‰æœ‰ç¾¤ç»„ç»‘å®šçš„ç”¨æˆ·
        conn = get_db_conn()
        c = conn.cursor()

        c.execute("""
            SELECT DISTINCT mg.telegram_id, mg.group_id, mg.group_name, m.username
            FROM member_groups mg
            JOIN members m ON mg.telegram_id = m.telegram_id
            WHERE mg.is_bot_admin = 1
        """)

        bound_groups = c.fetchall()
        conn.close()

        print(f"[æƒé™æ£€æŸ¥] æ‰¾åˆ° {len(bound_groups)} ä¸ªéœ€è¦æ£€æŸ¥çš„ç¾¤ç»„ç»‘å®š")

        for user_id, group_id, group_name, username in bound_groups:
            try:
                # æ‰¾åˆ°å¯¹åº”çš„æœºå™¨äºº
                target_bot = None
                for client in clients:
                    try:
                        me = await client.get_me()
                        if me.id == user_id:
                            target_bot = client
                            break
                    except BaseException:
                        continue

                if not target_bot:
                    print(f"[æƒé™æ£€æŸ¥] æœªæ‰¾åˆ°ç”¨æˆ· {user_id} å¯¹åº”çš„æœºå™¨äººï¼Œè·³è¿‡")
                    continue

                # æ£€æŸ¥æƒé™çŠ¶æ€
                try:
                    perms = await target_bot.get_permissions(group_id, user_id)
                    is_admin = perms.is_admin or perms.is_creator

                    if not is_admin:
                        print(
                            f"[æƒé™æ£€æŸ¥] ğŸš¨ å‘ç°æœºå™¨äºº {user_id} åœ¨ç¾¤ç»„ {group_id} å¤±å»ç®¡ç†å‘˜æƒé™")

                        # è§¦å‘å…¨å±€çŠ¶æ€åˆ·æ–°
                        permission_check_triggered = True

                        # å‘é€é€šçŸ¥ - è½¬æ¢group_idæ ¼å¼ç”¨äºåŒ¹é…
                        raw_chat_id = int(
                            str(group_id).replace(
                                '-100',
                                '')) if str(group_id).startswith('-100') else group_id
                        await notify_group_binding_invalid(raw_chat_id, user_id, "å®šæœŸæ£€æŸ¥å‘ç°ç®¡ç†å‘˜æƒé™è¢«æ’¤é”€", target_bot)

                        # æ›´æ–°æ•°æ®åº“çŠ¶æ€ - æ·»åŠ é‡è¯•æœºåˆ¶
                        max_db_retries = 3
                        for db_attempt in range(max_db_retries):
                            try:
                                conn = get_db_conn()
                                c = conn.cursor()
                                c.execute(
                                    'UPDATE member_groups SET is_bot_admin = 0 WHERE telegram_id = ? AND group_id = ?',
                                    (user_id,
                                     group_id))
                                c.execute(
                                    'UPDATE members SET is_bot_admin = 0 WHERE telegram_id = ?', (user_id,))
                                conn.commit()
                                conn.close()
                                break
                            except Exception as db_err:
                                if conn:
                                    try:
                                        conn.close()
                                    except BaseException:
                                        pass
                                if 'locked' in str(db_err).lower(
                                ) and db_attempt < max_db_retries - 1:
                                    print(
                                        f'[æƒé™æ£€æŸ¥] æ•°æ®åº“é”å®šï¼Œé‡è¯• {db_attempt + 1}/{max_db_retries}: {db_err}')
                                    await asyncio.sleep(0.5)
                                    continue
                                else:
                                    print(f'[æƒé™æ£€æŸ¥] æ›´æ–°æ•°æ®åº“å¤±è´¥: {db_err}')
                                    break

                        print(f"[æƒé™æ£€æŸ¥] å·²æ›´æ–°æ•°æ®åº“çŠ¶æ€å¹¶å‘é€é€šçŸ¥")
                    else:
                        print(
                            f"[æƒé™æ£€æŸ¥] âœ… æœºå™¨äºº {user_id} åœ¨ç¾¤ç»„ {group_id} ä»å…·æœ‰ç®¡ç†å‘˜æƒé™")

                except Exception as perm_err:
                    print(
                        f"[æƒé™æ£€æŸ¥] æ£€æŸ¥æœºå™¨äºº {user_id} åœ¨ç¾¤ç»„ {group_id} æƒé™å¤±è´¥: {perm_err}")
                    # å¦‚æœæ£€æŸ¥å¤±è´¥ï¼Œå¯èƒ½æ„å‘³ç€æœºå™¨äººè¢«è¸¢å‡º
                    raw_chat_id = int(
                        str(group_id).replace(
                            '-100',
                            '')) if str(group_id).startswith('-100') else group_id
                    await notify_group_binding_invalid(raw_chat_id, user_id, "å®šæœŸæ£€æŸ¥å‘ç°æœºå™¨äººæ— æ³•è®¿é—®ç¾¤ç»„ï¼Œå¯èƒ½å·²è¢«è¸¢å‡º", target_bot)

            except Exception as e:
                print(f"[æƒé™æ£€æŸ¥] æ£€æŸ¥ç”¨æˆ· {user_id} æƒé™å¤±è´¥: {e}")

        print("[æƒé™æ£€æŸ¥] å®šæœŸæƒé™æ£€æŸ¥å®Œæˆ")

    except Exception as e:
        print(f"[æƒé™æ£€æŸ¥] å®šæœŸæ£€æŸ¥è¿‡ç¨‹å‡ºé”™: {e}")


async def check_and_notify_permission_change(
        bot, user_id, chat_id, update_type):
    """æ£€æŸ¥æœºå™¨äººæƒé™çŠ¶æ€å¹¶å‘é€é€šçŸ¥"""
    try:
        # æ„å»ºå®Œæ•´çš„chat_id
        full_chat_id = int(f"-100{chat_id}") if chat_id > 0 else chat_id

        print(f'[æƒé™æ£€æŸ¥] æ­£åœ¨éªŒè¯æœºå™¨äºº {user_id} åœ¨ç¾¤ç»„ {full_chat_id} çš„æƒé™...')

        # è°ƒç”¨APIæ£€æŸ¥å½“å‰æƒé™
        perms = await bot.get_permissions(full_chat_id, user_id)
        is_admin = perms.is_admin or perms.is_creator

        print(f'[æƒé™æ£€æŸ¥] å½“å‰æƒé™çŠ¶æ€: admin={is_admin}')

        if not is_admin:
            print(f'[æƒé™æ£€æŸ¥] âœ… ç¡®è®¤æœºå™¨äººå·²å¤±å»ç®¡ç†å‘˜æƒé™ï¼Œå‘é€é€šçŸ¥')

            # è§¦å‘å…¨å±€çŠ¶æ€åˆ·æ–°
            global permission_check_triggered
            permission_check_triggered = True

            # å‘é€é€šçŸ¥ - ä½¿ç”¨åŸå§‹chat_idè¿›è¡ŒåŒ¹é…
            await notify_group_binding_invalid(chat_id, user_id, f"æœºå™¨äººç®¡ç†å‘˜æƒé™è¢«æ’¤é”€ ({update_type})", bot)
        else:
            print(f'[æƒé™æ£€æŸ¥] æœºå™¨äººä»å…·æœ‰ç®¡ç†å‘˜æƒé™')

    except Exception as e:
        print(f'[æƒé™æ£€æŸ¥] æƒé™éªŒè¯å¤±è´¥: {e}')
        # ä¿å®ˆå¤„ç†ï¼šå¦‚æœéªŒè¯å¤±è´¥ï¼Œå‡è®¾æƒé™è¢«æ’¤é”€
        print(f'[æƒé™æ£€æŸ¥] ç”±äºéªŒè¯å¤±è´¥ï¼Œä¿å®ˆå¤„ç†ä¸ºæƒé™è¢«æ’¤é”€')
        await notify_group_binding_invalid(chat_id, user_id, f"æœºå™¨äººæƒé™éªŒè¯å¤±è´¥ï¼Œå¯èƒ½å·²è¢«æ’¤é”€ ({update_type})", bot)

# ==================== å¤‡ç”¨Rawäº‹ä»¶ç›‘å¬å™¨ ====================


@multi_bot_on(events.ChatAction)
async def group_welcome_handler(event):
    """å¤„ç†ç¾¤ç»„ç›¸å…³äº‹ä»¶ï¼šåŠ å…¥ã€ç¦»å¼€ã€æƒé™å˜åŒ–ç­‰"""
    global permission_check_triggered
    try:
        print(
            f'[ChatAction] æ”¶åˆ°äº‹ä»¶: {type(event.action_message.action).__name__ if event.action_message else "æ— "}')
        
        # æ£€æŸ¥æ˜¯å¦æ˜¯ç”¨æˆ·åŠ å…¥äº‹ä»¶
        if event.user_joined or event.user_added:
            sys_config = get_system_config()
            
            # è·å–æ–°æˆå‘˜ä¿¡æ¯
            user = await event.get_user()
            if not user:
                print('[ç¾¤äº‹ä»¶] æ— æ³•è·å–ç”¨æˆ·ä¿¡æ¯')
                return
            
            new_user_id = user.id
            new_username = user.username or f'user_{new_user_id}'
            user_name = user.first_name or ''
            if user.last_name:
                user_name += f' {user.last_name}'
            user_name = user_name.strip() or f'ç”¨æˆ·{new_user_id}'
            
            # è·å–ç¾¤ä¿¡æ¯
            chat = await event.get_chat()
            chat_id = chat.id if chat else None
            print(f'[ç¾¤äº‹ä»¶] ç¾¤ID={chat_id}, æ–°ç”¨æˆ·={new_user_id}({new_username})')
            
            # ===== è‡ªåŠ¨æ³¨å†ŒåŠŸèƒ½ =====
            auto_register_enabled = sys_config.get(
                'auto_register_enabled', '0')
            print(f'[è‡ªåŠ¨æ³¨å†Œ] å¼€å…³çŠ¶æ€={auto_register_enabled}')
            
            if auto_register_enabled == '1' or auto_register_enabled == 1:
                try:
                    # è·å–é‚€è¯·è€…ID - å°è¯•å¤šç§æ–¹å¼
                    added_by = None
                    
                    # æ–¹å¼1: event.added_by
                    if hasattr(event, 'added_by') and event.added_by:
                        added_by = event.added_by
                        print(f'[è‡ªåŠ¨æ³¨å†Œ] æ–¹å¼1è·å–é‚€è¯·è€…: {added_by}')
                    
                    # æ–¹å¼2: action_message.action
                    if not added_by and hasattr(
                            event, 'action_message') and event.action_message:
                        action = event.action_message.action
                        print(f'[è‡ªåŠ¨æ³¨å†Œ] actionç±»å‹: {type(action).__name__}')
                        if hasattr(action, 'inviter_id') and action.inviter_id:
                            added_by = action.inviter_id
                            print(f'[è‡ªåŠ¨æ³¨å†Œ] æ–¹å¼2aè·å–é‚€è¯·è€…: {added_by}')
                    
                    # æ–¹å¼3: ä»æ¶ˆæ¯å‘é€è€…è·å–
                    if not added_by and event.action_message:
                        from_id = event.action_message.from_id
                        if from_id:
                            if hasattr(from_id, 'user_id'):
                                added_by = from_id.user_id
                            elif hasattr(from_id, 'id'):
                                added_by = from_id.id
                            elif isinstance(from_id, int):
                                added_by = from_id
                            print(f'[è‡ªåŠ¨æ³¨å†Œ] æ–¹å¼3è·å–é‚€è¯·è€…: {added_by}')
                    
                    # ç¡®ä¿ added_by æ˜¯æ•´æ•°ID
                    if added_by and not isinstance(added_by, int):
                        if hasattr(added_by, 'id'):
                            added_by = added_by.id
                        elif hasattr(added_by, 'user_id'):
                            added_by = added_by.user_id
                        print(f'[è‡ªåŠ¨æ³¨å†Œ] è½¬æ¢åé‚€è¯·è€…ID: {added_by}')
                    
                    # æ–¹å¼4: å¦‚æœæ˜¯é€šè¿‡ç¾¤é“¾æ¥åŠ å…¥ï¼Œå°è¯•æ‰¾ç¾¤ä¸»
                    if not added_by and chat_id:
                        conn = get_db_conn()
                        c = conn.cursor()
                        c.execute(
                            'SELECT telegram_id FROM members WHERE group_link LIKE ?', (f'%{chat_id}%',))
                        owner = c.fetchone()
                        conn.close()
                        if owner:
                            added_by = owner[0]
                            print(f'[è‡ªåŠ¨æ³¨å†Œ] æ–¹å¼4è·å–ç¾¤ä¸»: {added_by}')
                    
                    print(f'[è‡ªåŠ¨æ³¨å†Œ] æœ€ç»ˆé‚€è¯·è€…={added_by}, æ–°ç”¨æˆ·={new_user_id}')
                    
                    if added_by and added_by != new_user_id:
                        # æ£€æŸ¥é‚€è¯·è€…æ˜¯å¦æ˜¯ä¼šå‘˜
                        inviter = DB.get_member(added_by)
                        print(f'[è‡ªåŠ¨æ³¨å†Œ] é‚€è¯·è€…æ˜¯ä¼šå‘˜: {inviter is not None}')
                        if inviter:
                            # ===== æ£€æµ‹é‚€è¯·è€…ç¾¤ç»„ç»‘å®šçŠ¶æ€ =====
                            inviter_group_valid = await check_user_group_binding_status(inviter['telegram_id'], clients)
                            if not inviter_group_valid:
                                print(f'[è‡ªåŠ¨æ³¨å†Œ] é‚€è¯·è€… {added_by} ç¾¤ç»„ç»‘å®šå¤±æ•ˆï¼Œè·³è¿‡è‡ªåŠ¨æ³¨å†Œ')
                                # ç”±äºç¾¤ç»„ç»‘å®šå¤±æ•ˆï¼Œè·³è¿‡è‡ªåŠ¨æ³¨å†Œ
                                return

                            # æ£€æŸ¥æ–°ç”¨æˆ·æ˜¯å¦å·²æ³¨å†Œ
                            existing = DB.get_member(new_user_id)
                            print(f'[è‡ªåŠ¨æ³¨å†Œ] æ–°ç”¨æˆ·å·²æ³¨å†Œ: {existing is not None}')
                            if not existing:
                                # æ³¨å†Œæ–°ç”¨æˆ·ä¸ºé‚€è¯·è€…çš„ä¸‹çº§
                                DB.create_member(
                                    new_user_id, new_username, added_by)
                                print(
                                    f'âœ… è‡ªåŠ¨æ³¨å†ŒæˆåŠŸ: {new_username} æˆä¸º {inviter["username"]} çš„ä¸‹çº§')
                                
                                # é€šçŸ¥é‚€è¯·è€…
                                try:
                                    await bot.send_message(
                                        added_by,
                                        (
                                            "ğŸ“¨ é‚€è¯·æˆåŠŸé€šçŸ¥\n\n"
                                            f"ğŸ‘¥ æ‚¨çš„ä¸‹çº§æ–°æˆå‘˜åŠ å…¥ï¼š[{user_name}](tg://user?id={new_user_id})\n"
                                            "ğŸ¯ æ‚¨çš„ç›´æ¨å¥½å‹æ•°é‡ +1\n\n"
                                            "ğŸ’¡ å¿«å»å¸¦é¢†ä»–å¼€é€š VIPï¼Œå‘å±•æ›´å¤šå›¢é˜Ÿå§ï½"
                                        ),
                                        parse_mode='markdown'
                                    )
                                    print(f'âœ… å·²é€šçŸ¥é‚€è¯·è€… {added_by}')
                                except Exception as notify_err:
                                    print(f'é€šçŸ¥é‚€è¯·è€…å¤±è´¥: {notify_err}')
                            else:
                                print(f'[è‡ªåŠ¨æ³¨å†Œ] è·³è¿‡: ç”¨æˆ·å·²å­˜åœ¨')
                        else:
                            print(f'[è‡ªåŠ¨æ³¨å†Œ] è·³è¿‡: é‚€è¯·è€…ä¸æ˜¯ä¼šå‘˜')
                    else:
                        print(f'[è‡ªåŠ¨æ³¨å†Œ] è·³è¿‡: æ— æ³•è·å–é‚€è¯·è€…æˆ–æ˜¯è‡ªå·±')
                except Exception as e:
                    print(f'è‡ªåŠ¨æ³¨å†Œå¤„ç†å¤±è´¥: {e}')
                    import traceback
                    traceback.print_exc()
            
            # ===== æ¬¢è¿è¯­åŠŸèƒ½ =====
            welcome_enabled = sys_config.get('welcome_enabled', '1')
            if welcome_enabled == '1' or welcome_enabled == 1:
                welcome_message = sys_config.get('welcome_message', '')
                
                if welcome_message:
                    # æ›¿æ¢æ¬¢è¿è¯­ä¸­çš„å˜é‡
                    msg = welcome_message.replace('{name}', user_name)
                    msg = msg.replace(
                        '{username}', f'@{new_username}' if user.username else user_name)
                    msg = msg.replace('{id}', str(new_user_id))
                    
                    await event.respond(f'ğŸ‘‹ {msg}')

        # ===== æœºå™¨äººç¦»å¼€/æƒé™å˜åŒ–æ£€æµ‹ =====
        elif event.user_left or event.user_kicked:
            # æ£€æŸ¥æ˜¯å¦æœ‰æœºå™¨äººè¢«è¸¢å‡º
            if hasattr(event, 'user_id'):
                kicked_user_id = event.user_id
                print(f'[æœºå™¨äººæ£€æµ‹] ç”¨æˆ·ç¦»å¼€/è¢«è¸¢å‡º: {kicked_user_id}')

                # æ£€æŸ¥æ˜¯å¦æ˜¯æˆ‘ä»¬çš„æœºå™¨äººè¢«è¸¢å‡º
                if not clients:
                    print(f'[æœºå™¨äººæ£€æµ‹] âš ï¸ è­¦å‘Šï¼šclientsåˆ—è¡¨ä¸ºç©ºï¼Œæ— æ³•æ£€æµ‹æœºå™¨äººçŠ¶æ€')
                    print(f'[æœºå™¨äººæ£€æµ‹] å½“å‰æ´»è·ƒæœºå™¨äººæ•°é‡: {len(clients)}')
                    return

                bot_ids = []
                for client in clients:
                    try:
                        bot_ids.append((await client.get_me()).id)
                    except Exception as e:
                        print(f'[æœºå™¨äººæ£€æµ‹] è·å–æœºå™¨äººIDå¤±è´¥: {e}')
                        continue

                print(f'[æœºå™¨äººæ£€æµ‹] å½“å‰æ´»è·ƒæœºå™¨äººID: {bot_ids}')

                if kicked_user_id in bot_ids:
                    print(f'[æœºå™¨äººæ£€æµ‹] âœ… æ£€æµ‹åˆ°æˆ‘ä»¬çš„æœºå™¨äººè¢«è¸¢å‡ºç¾¤ç»„: {kicked_user_id}')
                    # æ‰¾åˆ°è¢«è¸¢å‡ºçš„æœºå™¨äººå®ä¾‹
                    kicked_bot = None
                    for client in clients:
                        try:
                            if (await client.get_me()).id == kicked_user_id:
                                kicked_bot = client
                                break
                        except Exception as e:
                            continue

                    # ã€ä¿®æ”¹ã€‘ä¼˜å…ˆä½¿ç”¨è¢«è¸¢å‡ºçš„æœºå™¨äººå‘é€ç§èŠé€šçŸ¥ï¼ˆå› ä¸ºæ˜¯PMç»™ç”¨æˆ·ï¼Œä¸éœ€è¦åœ¨ç¾¤é‡Œå‘ï¼‰
                    # åªæœ‰å½“æ‰¾ä¸åˆ°è¯¥æœºå™¨äººå®ä¾‹æ—¶ï¼Œæ‰ä½¿ç”¨å…¶ä»–æœºå™¨äººå…œåº•
                    notify_bot = kicked_bot if kicked_bot else (clients[0] if clients else None)

                    await notify_group_binding_invalid(event.chat_id, kicked_user_id, "æœºå™¨äººè¢«è¸¢å‡ºç¾¤ç»„", notify_bot)
                    return
                else:
                    print(f'[æœºå™¨äººæ£€æµ‹] æ™®é€šç”¨æˆ·ç¦»å¼€/è¢«è¸¢å‡º: {kicked_user_id}')

        # ===== å¢å¼ºï¼šæœºå™¨äººç®¡ç†å‘˜æƒé™æ’¤é”€æ£€æµ‹ =====
        print(
            f'[æƒé™æ£€æµ‹] ChatActionè¯¦æƒ…: user_id={getattr(event, "user_id", None)}, '
            f'user_joined={event.user_joined}, user_left={event.user_left}, '
            f'action={type(event.action_message.action).__name__ if event.action_message else "None"}')

        # è·å–ç¾¤ç»„ID - ç”¨äºæƒé™æ£€æŸ¥
        chat_id = getattr(event, 'chat_id', None)
        if not chat_id and hasattr(event, 'chat'):
            chat_id = event.chat.id

        # é‡è¦ä¿®å¤ï¼šåªæœ‰åœ¨æœºå™¨äººè¢«ç§»é™¤/ç¦»å¼€æ—¶æ‰è¿›è¡Œæƒé™æ£€æŸ¥
        # æœºå™¨äººè¢«æ·»åŠ æ—¶ä¸åº”è¯¥è§¦å‘æƒé™æ’¤é”€é€šçŸ¥
        should_check_permissions = False

        # æ£€æŸ¥æ˜¯å¦æ˜¯æœºå™¨äººç¦»å¼€/è¢«è¸¢å‡ºçš„äº‹ä»¶
        if event.user_left or (
            hasattr(
                event,
                'user_kicked') and event.user_kicked):
            # åªæœ‰å½“ç”¨æˆ·ç¦»å¼€æ—¶ï¼Œæ‰æ£€æŸ¥æ˜¯å¦æ˜¯æˆ‘ä»¬çš„æœºå™¨äºº
            user_id = getattr(event, 'user_id', None)
            if user_id:
                # æ£€æŸ¥æ˜¯å¦æ˜¯æˆ‘ä»¬çš„æœºå™¨äºº
                is_our_bot = False
                for client in clients:
                    try:
                        me = await client.get_me()
                        if me.id == user_id:
                            is_our_bot = True
                            break
                    except BaseException:
                        continue

                if is_our_bot:
                    print(f'[æƒé™æ£€æµ‹] æ£€æµ‹åˆ°æœ¬æœºæœºå™¨äºº {user_id} ç¦»å¼€ç¾¤ç»„ {chat_id}ï¼Œå¼€å§‹æƒé™æ£€æŸ¥')
                    should_check_permissions = True
        elif event.action_message and hasattr(event.action_message.action, 'users'):
            # æ£€æŸ¥æ˜¯å¦æ˜¯MessageActionChatDeleteUser (ç”¨æˆ·è¢«ç§»é™¤)
            action_type = type(event.action_message.action).__name__
            if action_type == 'MessageActionChatDeleteUser':
                print(f'[æƒé™æ£€æµ‹] æ£€æµ‹åˆ°ç”¨æˆ·è¢«ç§»é™¤äº‹ä»¶ï¼Œæ£€æŸ¥æ˜¯å¦æ˜¯æœºå™¨äºº')
                # æ£€æŸ¥è¢«ç§»é™¤çš„ç”¨æˆ·æ˜¯å¦æ˜¯æˆ‘ä»¬çš„æœºå™¨äºº
                removed_users = getattr(
                    event.action_message.action, 'users', [])
                for removed_user_id in removed_users:
                    is_our_bot = False
                    for client in clients:
                        try:
                            me = await client.get_me()
                            if me.id == removed_user_id:
                                is_our_bot = True
                                break
                        except BaseException:
                            continue

                    if is_our_bot:
                        print(f'[æƒé™æ£€æµ‹] æ£€æµ‹åˆ°æœ¬æœºæœºå™¨äºº {removed_user_id} è¢«ç§»é™¤ï¼Œå‡†å¤‡æƒé™æ£€æŸ¥')
                        should_check_permissions = True
                        break

        # åªæœ‰åœ¨ç¡®è®¤æœºå™¨äººç¦»å¼€/è¢«ç§»é™¤æ—¶æ‰è¿›è¡Œæƒé™æ£€æŸ¥
        if should_check_permissions and chat_id:
            print(f'[æƒé™æ£€æµ‹] ç¾¤ç»„ID: {chat_id}ï¼Œå¯¹ç¦»å¼€çš„æœºå™¨äººè¿›è¡Œæƒé™æ£€æŸ¥')

            # åªæ£€æŸ¥è¢«ç§»é™¤çš„æœºå™¨äººï¼Œä¸æ£€æŸ¥æ‰€æœ‰æœºå™¨äºº
            user_id = getattr(event, 'user_id', None)
            if not user_id and event.action_message and hasattr(
                    event.action_message.action, 'users'):
                # ä»MessageActionChatDeleteUserä¸­è·å–ç”¨æˆ·ID
                removed_users = getattr(
                    event.action_message.action, 'users', [])
                if removed_users:
                    user_id = removed_users[0]  # é€šå¸¸åªæœ‰ä¸€ä¸ªç”¨æˆ·

            if user_id:
                # æ‰¾åˆ°å¯¹åº”çš„æœºå™¨äººå®¢æˆ·ç«¯
                target_bot = None
                for client in clients:
                    try:
                        me = await client.get_me()
                        if me.id == user_id:
                            target_bot = client
                            break
                    except BaseException:
                        continue

                if target_bot:
                    # è½¬æ¢chat_idæ ¼å¼
                    full_chat_id = int(
                        f"-100{chat_id}") if chat_id > 0 else chat_id

                    try:
                        # æ£€æŸ¥å½“å‰æƒé™çŠ¶æ€ - ç”±äºæœºå™¨äººå·²è¢«ç§»é™¤ï¼Œè¿™é€šå¸¸ä¼šå¤±è´¥
                        perms = await target_bot.get_permissions(full_chat_id, user_id)
                        is_admin = perms.is_admin or perms.is_creator

                        print(
                            f'[æƒé™æ£€æµ‹] æœºå™¨äºº {user_id} åœ¨ç¾¤ç»„ {full_chat_id} çš„æƒé™çŠ¶æ€: admin={is_admin}')

                        if not is_admin:
                            print(f'[æƒé™æ£€æµ‹] âœ… ç¡®è®¤æœºå™¨äºº {user_id} å¤±å»ç®¡ç†å‘˜æƒé™ï¼Œå‘é€é€šçŸ¥')

                            # è§¦å‘å…¨å±€çŠ¶æ€åˆ·æ–°
                            permission_check_triggered = True

                            # å‘é€é€šçŸ¥
                            await notify_group_binding_invalid(chat_id, user_id, f"ChatActionäº‹ä»¶æ£€æµ‹åˆ°æœºå™¨äººè¢«ç§»é™¤æˆ–ç¦»å¼€", target_bot)

                    except Exception as perm_err:
                        print(f'[æƒé™æ£€æµ‹] æœºå™¨äºº {user_id} æƒé™æ£€æŸ¥å¤±è´¥: {perm_err}')
                        # æƒé™æ£€æŸ¥å¤±è´¥é€šå¸¸æ„å‘³ç€æœºå™¨äººå·²è¢«ç§»é™¤æˆ–æƒé™è¢«æ’¤é”€
                        print(f'[æƒé™æ£€æµ‹] ç”±äºæƒé™æ£€æŸ¥å¤±è´¥ï¼Œç¡®è®¤æœºå™¨äºº {user_id} æƒé™è¢«æ’¤é”€ï¼Œå‘é€é€šçŸ¥')

                        # è§¦å‘å…¨å±€çŠ¶æ€åˆ·æ–°
                        permission_check_triggered = True

                        # å‘é€é€šçŸ¥
                        await notify_group_binding_invalid(chat_id, user_id, f"æœºå™¨äººè¢«ç§»é™¤æˆ–æƒé™æ£€æŸ¥å¤±è´¥", target_bot)
                else:
                    print(f'[æƒé™æ£€æµ‹] æœªæ‰¾åˆ°å¯¹åº”çš„æœºå™¨äººå®¢æˆ·ç«¯')
            else:
                print(f'[æƒé™æ£€æµ‹] æ— æ³•ç¡®å®šè¢«ç§»é™¤çš„æœºå™¨äººID')

        # ä¿ç•™åŸæœ‰çš„ç‰¹å®šç”¨æˆ·æ£€æµ‹é€»è¾‘ï¼ˆä½œä¸ºå¤‡ç”¨ï¼‰
        user_id = getattr(event, 'user_id', None)
        if user_id:
            # æ£€æŸ¥æ˜¯å¦æ˜¯æˆ‘ä»¬çš„æœºå™¨äºº
            is_our_bot = False
            target_bot = None
            for client in clients:
                try:
                    me = await client.get_me()
                    if me.id == user_id:
                        is_our_bot = True
                        target_bot = client
                        break
                except BaseException:
                    continue

            if is_our_bot and target_bot:
                action_type = type(
                    event.action_message.action).__name__ if event.action_message else "Unknown"
                print(
                    f'[æƒé™æ£€æµ‹] æ£€æµ‹åˆ°æœ¬æœºæœºå™¨äºº {user_id} çš„ChatActionäº‹ä»¶: {action_type}')

        # ===== ç¾¤ç»„è§£æ•£æ£€æµ‹ =====
        if hasattr(event, 'chat_deleted') and event.chat_deleted:
            print(f'[ç¾¤ç»„æ£€æµ‹] ç¾¤ç»„è¢«è§£æ•£: {event.chat_id}')
            # é€šçŸ¥æ‰€æœ‰ç»‘å®šæ­¤ç¾¤ç»„çš„ç”¨æˆ·
            await notify_group_binding_invalid(event.chat_id, None, "ç¾¤ç»„å·²è¢«è§£æ•£")
            return

    except Exception as e:
        print(f'ç¾¤äº‹ä»¶å¤„ç†å¤±è´¥: {e}')

# ==================== å®Œæ•´çš„æ¶ˆæ¯å¤„ç†å™¨ ====================


@multi_bot_on(events.NewMessage())
async def message_handler(event):
    """å®Œæ•´çš„æ¶ˆæ¯å¤„ç†å™¨ - å¤„ç†æç°ã€ç®¡ç†å‘˜è®¾ç½®ã€ç¾¤é“¾æ¥ç­‰"""
    # è´¦å·å…³è”å¤„ç†
    try:
        original_sender_id = event.sender_id
        event.sender_id = get_main_account_id(
            original_sender_id, getattr(
                event.sender, 'username', None))
    except BaseException:
        pass
    
    # å¿½ç•¥å‘½ä»¤å’ŒæŒ‰é’®æ–‡å­—
    if not event.message.text:
        return
    
    text = event.message.text.strip()
    sender_id = event.sender_id
    
    # å¤„ç†æç°é‡‘é¢è¾“å…¥
    if sender_id in waiting_for_withdraw_amount:
        del waiting_for_withdraw_amount[sender_id]
        try:
            amount = float(text)
            config = get_system_config()
            member = DB.get_member(sender_id)
            
            if amount < config['withdraw_threshold']:
                await event.respond(f'âŒ æç°é‡‘é¢ä¸èƒ½å°äº {config["withdraw_threshold"]} U')
                return
            
            if amount > member['balance']:
                await event.respond(f'âŒ ä½™é¢ä¸è¶³\n\nå½“å‰ä½™é¢: {member["balance"]} U')
                return
            
            withdraw_temp_data[sender_id] = amount
            waiting_for_withdraw_address[sender_id] = True
            await event.respond(
                f'ğŸ’³ æç°ç”³è¯·\n\n'
                f'æç°é‡‘é¢: {amount} U\n\n'
                f'è¯·è¾“å…¥æ‚¨çš„USDTæ”¶æ¬¾åœ°å€ï¼ˆTRC20ï¼‰ï¼š'
            )
        except ValueError:
            await event.respond('âŒ è¯·è¾“å…¥æœ‰æ•ˆçš„æ•°å­—é‡‘é¢')
        return
    
    # å¤„ç†æç°åœ°å€è¾“å…¥
    if sender_id in waiting_for_withdraw_address:
        del waiting_for_withdraw_address[sender_id]
        usdt_address = text.strip()
        
        if not usdt_address or len(usdt_address) < 20:
            await event.respond('âŒ è¯·è¾“å…¥æœ‰æ•ˆçš„USDTåœ°å€')
            return
        
        amount = withdraw_temp_data.get(sender_id, 0)
        if amount <= 0:
            await event.respond('âŒ æç°é‡‘é¢é”™è¯¯ï¼Œè¯·é‡æ–°ç”³è¯·')
            return
        
        del withdraw_temp_data[sender_id]
        
        try:
            import datetime
            import time
            
            # é‡è¯•æœºåˆ¶å¤„ç†æ•°æ®åº“é”
            max_retries = 3
            for retry in range(max_retries):
                try:
                    conn = get_db_conn()
                    conn.execute("PRAGMA busy_timeout = 5000")
                    c = conn.cursor()
                    
                    # æ‰£é™¤ä½™é¢
                    c.execute(
                        "UPDATE members SET balance = balance - ? WHERE telegram_id = ?",
                        (amount,
                         sender_id))
                    
                    # æ’å…¥æç°è®°å½•
                    now = get_cn_time()
                    
                    # æ£€æŸ¥è¡¨æ˜¯å¦æœ‰usdt_addresså­—æ®µ
                    c.execute("PRAGMA table_info(withdrawals)")
                    columns = [col[1] for col in c.fetchall()]
                    if 'usdt_address' in columns:
                        c.execute(
                            "INSERT INTO withdrawals (member_id, amount, usdt_address, status, create_time) VALUES (?, ?, ?, 'pending', ?)",
                            (sender_id,
                             amount,
                             usdt_address,
                             now))
                    else:
                        c.execute(
                            "INSERT INTO withdrawals (member_id, amount, status, create_time) VALUES (?, ?, 'pending', ?)",
                            (sender_id,
                             amount,
                             now))
                    
                    conn.commit()
                    
                    # è·å–æ–°ä½™é¢
                    c.execute(
                        "SELECT balance FROM members WHERE telegram_id = ?", (sender_id,))
                    new_balance = c.fetchone()[0]
                    conn.close()
                    break
                    
                except Exception as e:
                    if 'locked' in str(e) and retry < max_retries - 1:
                        time.sleep(0.5)
                        continue
                    else:
                        raise
            
            await event.respond(
                f'âœ… æç°ç”³è¯·å·²æäº¤\n\n'
                f'æç°é‡‘é¢: {amount} U\n'
                f'æ”¶æ¬¾åœ°å€: {usdt_address}\n'
                f'å‰©ä½™ä½™é¢: {new_balance} U\n\n'
                f'â³ è¯·ç­‰å¾…ç®¡ç†å‘˜å®¡æ ¸\n'
                f'å®¡æ ¸ç»“æœå°†é€šè¿‡æœºå™¨äººé€šçŸ¥æ‚¨'
            )
        except Exception as e:
            await event.respond(f'âŒ æç°ç”³è¯·å¤±è´¥: {str(e)}')
        return
    
    # å¿½ç•¥å‘½ä»¤
    if text.startswith('/'):
        if text == '/cancel':
            waiting_for_group_link.pop(sender_id, None)
            waiting_for_backup.pop(sender_id, None)
            waiting_for_recharge_amount.pop(sender_id, None)
            admin_waiting.pop(sender_id, None)
            await event.respond('å·²å–æ¶ˆæ“ä½œ', buttons=get_main_keyboard(sender_id))
        return
    
    # å¿½ç•¥ä¸»èœå•æŒ‰é’®
    if text in [
            BTN_PROFILE,
            BTN_FISSION,
            BTN_VIEW_FISSION,
            BTN_RESOURCES,
            BTN_PROMOTE,
            BTN_SUPPORT,
            BTN_BACK,
            BTN_ADMIN,
            BTN_VIP,
            BTN_MY_PROMOTE]:
        return
    
    # ç®¡ç†å‘˜è®¾ç½®å¤„ç†
    if sender_id in admin_waiting:
        wait_type = admin_waiting[sender_id]
        config = get_system_config()
        
        if wait_type == 'level_count':
            try:
                value = int(text)
                if 1 <= value <= 20:
                    from database import update_system_config
                    update_system_config('level_count', value)
                    # åˆå§‹åŒ–æˆ–è°ƒæ•´æ¯å±‚é‡‘é¢é…ç½®ä¸ºå½“å‰æ¯å±‚è¿”åˆ©ï¼ˆæˆ–1ï¼‰* value å±‚ï¼Œä¾¿äºå‰ç«¯æ˜¾ç¤º
                    try:
                        import json
                        per_level = float(config.get('level_reward', 1))
                        amounts = [per_level for _ in range(value)]
                        update_system_config(
                            'level_amounts', json.dumps(amounts))
                    except Exception as e:
                        print(f"[admin_set_level] æ— æ³•åˆå§‹åŒ– level_amounts: {e}")
                    del admin_waiting[sender_id]
                    await event.respond(f'âœ… å±‚æ•°è®¾ç½®æˆåŠŸ!\n\nå½“å‰å±‚æ•°: {value} å±‚')
                else:
                    await event.respond('âŒ è¯·è¾“å…¥1-20ä¹‹é—´çš„æ•°å­—')
            except ValueError:
                await event.respond('âŒ è¯·è¾“å…¥æœ‰æ•ˆçš„æ•°å­—')
            return
        
        elif wait_type == 'level_reward':
            try:
                value = float(text)
                if value > 0:
                    from database import update_system_config
                    update_system_config('level_reward', value)
                    del admin_waiting[sender_id]
                    await event.respond(f'âœ… è¿”åˆ©è®¾ç½®æˆåŠŸ!\n\næ¯å±‚è¿”åˆ©: {value} U')
                else:
                    await event.respond('âŒ è¯·è¾“å…¥å¤§äº0çš„æ•°å­—')
            except ValueError:
                await event.respond('âŒ è¯·è¾“å…¥æœ‰æ•ˆçš„æ•°å­—')
            return
        
        elif wait_type == 'vip_price':
            try:
                value = float(text)
                if value > 0:
                    from database import update_system_config
                    update_system_config('vip_price', value)
                    del admin_waiting[sender_id]
                    await event.respond(f'âœ… VIPä»·æ ¼è®¾ç½®æˆåŠŸ!\n\nå½“å‰ä»·æ ¼: {value} U')
                else:
                    await event.respond('âŒ è¯·è¾“å…¥å¤§äº0çš„æ•°å­—')
            except ValueError:
                await event.respond('âŒ è¯·è¾“å…¥æœ‰æ•ˆçš„æ•°å­—')
            return
        
        elif wait_type == 'withdraw_threshold':
            try:
                value = float(text)
                if value >= 0:
                    from database import update_system_config
                    update_system_config('withdraw_threshold', value)
                    del admin_waiting[sender_id]
                    await event.respond(f'âœ… æç°é—¨æ§›è®¾ç½®æˆåŠŸ!\n\nå½“å‰é—¨æ§›: {value} U')
                else:
                    await event.respond('âŒ è¯·è¾“å…¥å¤§äºç­‰äº0çš„æ•°å­—')
            except ValueError:
                await event.respond('âŒ è¯·è¾“å…¥æœ‰æ•ˆçš„æ•°å­—')
            return
        
        elif wait_type == 'support_text':
            from database import update_system_config
            update_system_config('support_text', text)
            del admin_waiting[sender_id]
            await event.respond(f'âœ… å®¢æœæ–‡æœ¬è®¾ç½®æˆåŠŸ!\n\nå½“å‰æ–‡æœ¬:\n{text}')
            return
        
        elif wait_type == 'manual_vip':
            # æ‰‹åŠ¨å……å€¼VIP - è°ƒç”¨ç»Ÿä¸€å¤„ç†å‡½æ•°
            target_user = None
            
            # å°è¯•æŒ‰ç”¨æˆ·IDæŸ¥æ‰¾
            try:
                user_id = int(text.strip())
                target_user = DB.get_member(user_id)
                if not target_user:
                    await event.respond(f'âŒ æœªæ‰¾åˆ°ç”¨æˆ·ID: {user_id}\n\nè¯¥ç”¨æˆ·å¯èƒ½æœªä½¿ç”¨è¿‡æœºå™¨äºº')
                    return
            except ValueError:
                # æŒ‰ç”¨æˆ·åæŸ¥æ‰¾
                username = text.strip().lstrip('@')
                conn = get_db_conn()
                c = conn.cursor()
                c.execute(
                    'SELECT * FROM members WHERE username = ?', (username,))
                row = c.fetchone()
                conn.close()
                
                if row:
                    target_user = {
                        'id': row[0],
                        'telegram_id': row[1],
                        'username': row[2],
                        'backup_account': row[3],
                        'referrer_id': row[4],
                        'balance': row[5],
                        'missed_balance': row[6],
                        'group_link': row[7],
                        'is_vip': row[8],
                        'register_time': row[9],
                        'vip_time': row[10]}
                else:
                    await event.respond(f'âŒ æœªæ‰¾åˆ°ç”¨æˆ·å: @{username}\n\nè¯¥ç”¨æˆ·å¯èƒ½æœªä½¿ç”¨è¿‡æœºå™¨äºº')
                    return
            
            # æ£€æŸ¥æ˜¯å¦å·²ç»æ˜¯VIP
            if target_user['is_vip']:
                await event.respond(
                    f'âš ï¸ ç”¨æˆ·å·²æ˜¯VIP\n\n'
                    f'ç”¨æˆ·ID: {target_user["telegram_id"]}\n'
                    f'ç”¨æˆ·å: @{target_user["username"]}\n'
                    f'VIPå¼€é€šæ—¶é—´: {target_user["vip_time"][:10] if target_user["vip_time"] else "æœªçŸ¥"}'
                )
                del admin_waiting[sender_id]
                return
            
            # ã€æ ¸å¿ƒä¿®å¤ã€‘è°ƒç”¨ç»Ÿä¸€å¤„ç†å‡½æ•°
            success, result = await admin_manual_vip_handler(target_user['telegram_id'], config)
            
            if success:
                stats = result['stats']
                await event.respond(
                    f'âœ… VIPå……å€¼æˆåŠŸ!\n\n'
                    f'ç”¨æˆ·ID: {target_user["telegram_id"]}\n'
                    f'ç”¨æˆ·å: @{target_user["username"]}\n'
                    f'ç”¨æˆ·å·²æ”¶åˆ°å¼€é€šé€šçŸ¥'
                )
            else:
                await event.respond(f'âŒ {result}')
            
            del admin_waiting[sender_id]
            return
        
        elif wait_type == 'broadcast':
            # ç”¨æˆ·å¹¿æ’­
            broadcast_message = text
            
            # è·å–æ‰€æœ‰ç”¨æˆ·
            conn = get_db_conn()
            c = conn.cursor()
            c.execute('SELECT telegram_id, username FROM members')
            all_users = c.fetchall()
            conn.close()
            
            if not all_users:
                await event.respond('âŒ æš‚æ— ç”¨æˆ·')
                del admin_waiting[sender_id]
                return
            
            # å‘é€ç¡®è®¤æ¶ˆæ¯
            await event.respond(
                f'ğŸ“¢ å¼€å§‹å¹¿æ’­...\n\n'
                f'ç›®æ ‡ç”¨æˆ·æ•°: {len(all_users)} äºº\n'
                f'é¢„è®¡è€—æ—¶: {len(all_users) * 0.05:.1f} ç§’\n\n'
                f'å¹¿æ’­å†…å®¹:\n'
                f'---\n{broadcast_message}\n---\n\n'
                f'æ­£åœ¨å‘é€ä¸­ï¼Œè¯·ç¨å€™...'
            )
            
            # å‘é€å¹¿æ’­
            success_count = 0
            failed_count = 0
            
            for user_id, username in all_users:
                try:
                    await bot.send_message(
                        user_id,
                        f'ğŸ“¢ ç³»ç»Ÿå¹¿æ’­\n\n{broadcast_message}',
                        parse_mode='markdown'
                    )
                    success_count += 1
                    await asyncio.sleep(0.05)
                except Exception as e:
                    failed_count += 1
                    print(f"å‘é€å¹¿æ’­ç»™ç”¨æˆ· {user_id} (@{username}) å¤±è´¥: {e}")
            
            # å‘é€ç»Ÿè®¡ç»“æœ
            await event.respond(
                f'âœ… å¹¿æ’­å‘é€å®Œæˆ!\n\n'
                f'ğŸ“Š å‘é€ç»Ÿè®¡:\n'
                f'â€¢ æ€»ç”¨æˆ·æ•°: {len(all_users)} äºº\n'
                f'â€¢ å‘é€æˆåŠŸ: {success_count} äºº\n'
                f'â€¢ å‘é€å¤±è´¥: {failed_count} äºº\n'
                f'â€¢ æˆåŠŸç‡: {success_count / len(all_users) * 100:.1f}%\n\n'
                f'ğŸ’¡ å¤±è´¥åŸå› å¯èƒ½:\n'
                f'â€¢ ç”¨æˆ·å·²åˆ é™¤æˆ–æ‹‰é»‘æœºå™¨äºº\n'
                f'â€¢ ç”¨æˆ·è´¦å·è¢«å°ç¦\n'
                f'â€¢ ç”¨æˆ·éšç§è®¾ç½®é™åˆ¶'
            )
            
            del admin_waiting[sender_id]
            return
    
    # å¤„ç†å……å€¼é‡‘é¢è¾“å…¥
    if sender_id in waiting_for_recharge_amount and waiting_for_recharge_amount[sender_id]:
        try:
            amount = float(text)
            if amount <= 0:
                await event.respond('âŒ é‡‘é¢å¿…é¡»å¤§äº0')
                return
            if amount > 99999:
                await event.respond('âŒ å•æ¬¡å……å€¼é‡‘é¢ä¸èƒ½è¶…è¿‡99999 U')
                return
            
            del waiting_for_recharge_amount[sender_id]
            await create_recharge_order(bot, event, amount)
        except ValueError:
            await event.respond('âŒ è¯·è¾“å…¥æœ‰æ•ˆçš„æ•°å­—')
        return
    
    # è®¾ç½®å¤‡ç”¨å·
    if sender_id in waiting_for_backup and waiting_for_backup[sender_id]:
        backup_raw = text.strip().lstrip('@')
        backup_id = None
        backup_username = None
        
        # å°è¯•è§£ææ•°å­—ID
        if backup_raw.isdigit():
            backup_id = int(backup_raw)
        
        # æ— è®ºæ˜¯IDè¿˜æ˜¯ç”¨æˆ·åï¼Œéƒ½å°è¯•é€šè¿‡ Telegram è·å–å®ä½“
        try:
            entity_query = backup_id if backup_id is not None else backup_raw
            entity = await bot.get_entity(entity_query)
            if getattr(entity, 'id', None):
                backup_id = entity.id
                backup_username = getattr(entity, 'username', None)
        except Exception as e:
            print(f"[å¤‡ç”¨å·è§£æå¤±è´¥] {e}")
        
        if not backup_id:
            await event.respond('âŒ æœªæ‰¾åˆ°è¯¥å¤‡ç”¨å·ï¼Œè¯·å‘é€æ­£ç¡®çš„ç”¨æˆ·åæˆ–ID')
            return
        
        success, message = link_account(sender_id, backup_id, backup_username)
        del waiting_for_backup[sender_id]
        await event.respond(message)
        return
    
    # è®¾ç½®ç¾¤é“¾æ¥
    if sender_id in waiting_for_group_link and waiting_for_group_link[sender_id]:
        link = text
        # åªå…è®¸ http(s)://t.me/ å¼€å¤´çš„é“¾æ¥
        if link.startswith('http://t.me/') or link.startswith('https://t.me/'):
            # éªŒè¯ç¾¤é“¾æ¥ï¼ˆä½¿ç”¨å¤šæœºå™¨äººé€»è¾‘ï¼‰
            print(f'[ç¾¤ç»‘å®š] å¼€å§‹å¤„ç†é“¾æ¥: {link}')
            bot_client = event.client if hasattr(event, 'client') else bot
            print(f'[ç¾¤ç»‘å®š] ä½¿ç”¨æœºå™¨äººå®¢æˆ·ç«¯: {bot_client}')
            verification_result = await verify_group_link(bot_client, link, clients)
            print(f'[ç¾¤ç»‘å®š] verify_group_linkç»“æœ: {verification_result}')
            print(
                f'[ç¾¤ç»‘å®š] group_id: {verification_result.get("group_id")}, success: {verification_result.get("success")}')
            
            if verification_result['success']:
                # è·å– verify_group_link è¿”å›çš„ ID (ç°åœ¨æ ¸å¿ƒå‡½æ•°ä¿è¯æˆåŠŸå³è¿”å›ID)
                group_id = verification_result.get('group_id')
                group_name = verification_result.get('group_name')
                is_admin_flag = 1 if verification_result.get(
                    'admin_checked') else 0
                
                print(
                    f'[ç¾¤ç»‘å®š] å‡†å¤‡å­˜å‚¨: user={sender_id}, group_id={group_id}, link={link}')

                # æ›´æ–°æ•°æ®åº“ - åˆ†æ­¥éª¤è¿›è¡Œï¼Œç¡®ä¿æ¯ä¸€æ­¥éƒ½æˆåŠŸ
                try:
                    # 1. æ›´æ–°membersè¡¨
                    print('[ç¾¤ç»‘å®š] æ›´æ–°membersè¡¨...')
                    DB.update_member(
                        sender_id,
                        group_link=link,
                        is_group_bound=1,
                        is_bot_admin=is_admin_flag)
                    print('[ç¾¤ç»‘å®š] âœ… membersè¡¨æ›´æ–°æˆåŠŸ')

                    # 2. æ›´æ–°member_groupsè¡¨
                    print('[ç¾¤ç»‘å®š] æ›´æ–°member_groupsè¡¨...')
                    sender_username = getattr(
                        event.sender, 'username', None) if hasattr(
                        event, 'sender') else None
                    from database import upsert_member_group
                    upsert_member_group(
                        sender_id,
                        link,
                        sender_username,
                        is_bot_admin=is_admin_flag,
                        group_id=group_id)
                    print('[ç¾¤ç»‘å®š] âœ… member_groupsè¡¨æ›´æ–°æˆåŠŸ')

                    # 3. å¦‚æœæœ‰ç¾¤åï¼Œæ›´æ–°ç¾¤å
                    if group_name and group_id:
                        print(f'[ç¾¤ç»‘å®š] æ›´æ–°ç¾¤å: {group_name}')
                        conn = get_db_conn()
                        c = conn.cursor()
                        c.execute(
                            "UPDATE member_groups SET group_name = ? WHERE group_id = ?",
                            (group_name,
                             group_id))
                        conn.commit()
                        conn.close()
                        print('[ç¾¤ç»‘å®š] âœ… ç¾¤åæ›´æ–°æˆåŠŸ')

                    print(
                        f'[ç¾¤ç»‘å®š] ğŸ‰ ç»‘å®šå®Œæˆ! user={sender_id}, group_id={group_id}')

                except Exception as sync_err:
                    print(f'[ç»‘å®šç¾¤å†™å…¥æ•°æ®åº“å¤±è´¥] {sync_err}')
                    import traceback
                    traceback.print_exc()
                    # å¦‚æœæ•°æ®åº“æ“ä½œå¤±è´¥ï¼Œä¸æ˜¾ç¤ºæˆåŠŸæ¶ˆæ¯
                    await event.respond(f'âŒ ç»‘å®šå¤±è´¥: {str(sync_err)}')
                    return

                del waiting_for_group_link[sender_id]
                
                # æ„é€ æç¤ºæ–‡æ¡ˆ
                if verification_result.get('admin_checked'):
                    await event.respond(
                        f'âœ… ç¾¤é“¾æ¥è®¾ç½®æˆåŠŸ!\n\n'
                        f'é“¾æ¥: {link}\n'
                        f'âœ… æœºå™¨äººå·²åœ¨ç¾¤å†…\n'
                        f'âœ… æœºå™¨äººå…·æœ‰ç®¡ç†å‘˜æƒé™'
                    )
                else:
                    await event.respond(
                        f'âœ… ç¾¤ç»„é“¾æ¥å·²è®°å½•\n\n'
                        f'é“¾æ¥: {link}\n\n'
                        f'â„¹ï¸ ç”±äºæ˜¯ç§æœ‰é‚€è¯·é“¾æ¥ï¼ŒTelegram é™åˆ¶æ— æ³•è‡ªåŠ¨æ£€æµ‹æ˜¯å¦åŠ ç¾¤ / æ˜¯å¦è®¾ç½®ç¾¤ç®¡ã€‚\n'
                        f'ğŸ‘‰ å»ºè®®ä¸ºè¯¥ç¾¤è®¾ç½®ä¸€ä¸ªå…¬å¼€ç”¨æˆ·åï¼Œå¹¶å‘é€å…¬å¼€ç¾¤é“¾æ¥ï¼ˆä¾‹å¦‚ https://t.me/ç¾¤ç”¨æˆ·åï¼‰ï¼Œ\n'
                        f'è¿™æ ·ç³»ç»Ÿæ‰èƒ½è‡ªåŠ¨æ£€æµ‹æ‚¨æ˜¯å¦å·²åŠ ç¾¤å¹¶ä¸”æœºå™¨äººæ˜¯å¦ä¸ºç¾¤ç®¡ã€‚'
                    )
            else:
                reason = verification_result.get("message", "æœªçŸ¥é”™è¯¯")
                await event.respond(
                    f'âŒ ç¾¤é“¾æ¥éªŒè¯å¤±è´¥\n\n'
                    f'åŸå› : {reason}\n\n'
                    f'è¯·ç¡®ä¿:\n'
                    f'1. æœºå™¨äººå·²è¢«æ·»åŠ åˆ°ç¾¤å†…\n'
                    f'2. æœºå™¨äººå…·æœ‰ç®¡ç†å‘˜æƒé™\n\n'
                    f'3. ä½¿ç”¨ http://t.me/ç¾¤ç”¨æˆ·å æˆ– https://t.me/ç¾¤ç”¨æˆ·å çš„å…¬å¼€ç¾¤é“¾æ¥\n\n'
                    f'å®Œæˆåè¯·é‡æ–°å‘é€ç¾¤é“¾æ¥'
                )
        else:
            await event.respond('âŒ é“¾æ¥æ ¼å¼ä¸æ­£ç¡®ï¼Œè¯·å‘é€æ­£ç¡®çš„Telegramç¾¤é“¾æ¥\nä¾‹å¦‚: http://t.me/ç¾¤ç”¨æˆ·å æˆ– https://t.me/ç¾¤ç”¨æˆ·å')
        return

# ==================== é€šçŸ¥é˜Ÿåˆ—å¤„ç† ====================


async def process_notify_queue():
    """å¤„ç†é€šçŸ¥é˜Ÿåˆ—"""
    while True:
        try:
            await asyncio.sleep(1)
            while notify_queue:
                item = notify_queue.pop(0)
                try:
                    await bot.send_message(item['member_id'], item['message'])
                    print(f"âœ… é€šçŸ¥å·²å‘é€: ç”¨æˆ·{item['member_id']}")
                except Exception as e:
                    print(f"å‘é€é€šçŸ¥å¤±è´¥: {e}")
        except Exception as e:
            print(f"[é€šçŸ¥é˜Ÿåˆ—] é”™è¯¯: {e}")
            await asyncio.sleep(5)

# ==================== åå°å®šæ—¶ä»»åŠ¡ ====================


async def auto_broadcast_timer():
    """å®šæ—¶è‡ªåŠ¨ç¾¤å‘ - æ ¹æ® assignment ä¸­æ¯æ¡æ¶ˆæ¯çš„ broadcast_interval å’Œ last_sent_time è°ƒåº¦å‘é€"""
    import json
    from datetime import datetime

    check_interval_seconds = 10  # æ¯10ç§’æ‰«æä¸€æ¬¡
    
    while True:
        try:
            await asyncio.sleep(check_interval_seconds)
            now_ts = time.time()
            print("[å®šæ—¶ç¾¤å‘] æ‰«æåˆ†é…ä»»åŠ¡...", flush=True)
            
            conn = get_db_conn()
            c = conn.cursor()
            
            # å…¨å±€å¼€å…³ï¼šå…è®¸ç®¡ç†å‘˜å…³é—­å®šæ—¶åˆ†å‘
            c.execute(
                "SELECT value FROM system_config WHERE key = 'broadcast_enabled'")
            row = c.fetchone()
            broadcast_enabled = row[0] == '1' if row else True
            if not broadcast_enabled:
                conn.close()
                continue
            
            # æŸ¥è¯¢æ‰€æœ‰å¯ç”¨åˆ†é…ï¼šå…³è”
            # member_groupsã€broadcast_assignmentsã€broadcast_messages
            c.execute("""
                SELECT ba.id, ba.group_id, ba.message_id, ba.last_sent_time,
                       mg.group_link, mg.group_name,
                       bm.content, bm.image_url, bm.video_url, bm.buttons, bm.buttons_per_row, bm.broadcast_interval, bm.create_time
                FROM broadcast_assignments ba
                JOIN broadcast_messages bm ON ba.message_id = bm.id
                JOIN member_groups mg ON ba.group_id = mg.id
                WHERE ba.is_active = 1 AND bm.is_active = 1 AND mg.schedule_broadcast = 1
                ORDER BY bm.create_time ASC, bm.id ASC
            """)
            rows = c.fetchall()

            if not rows:
                conn.close()
                continue
            
            to_enqueue = []
            for r in rows:
                assign_id, group_id, message_id, last_sent_time, group_link, group_name, content, image_url, video_url, buttons_json, buttons_per_row, b_interval, bm_create = r
                try:
                    interval_minutes = int(b_interval) if b_interval else 120
                except BaseException:
                    interval_minutes = 120
                interval_seconds = interval_minutes * 60

                # parse last_sent_time (ISO) to timestamp
                last_ts = 0
                if last_sent_time:
                    try:
                        # handle timezone-aware ISO strings
                        dt = datetime.fromisoformat(last_sent_time)
                        last_ts = dt.timestamp()
                    except Exception:
                        try:
                            last_ts = float(last_sent_time)
                        except BaseException:
                            last_ts = 0

                # if never sent or interval elapsed, enqueue
                if now_ts - last_ts >= interval_seconds:
                    # prepare message content (simple: content only;
                    # buttons/media handled by process_broadcast_queue)
                    to_enqueue.append({
                        'assign_id': assign_id,
                        'group_id': group_id,
                        'group_link': group_link,
                        'group_name': group_name,
                        'message_id': message_id,
                        'content': content or '',
                        'image_url': image_url or '',
                        'video_url': video_url or '',
                        'buttons': buttons_json or '',
                        'buttons_per_row': buttons_per_row or 2
                    })

            # æ’å…¥åˆ° broadcast_queue å¹¶æ›´æ–° last_sent_time
            if to_enqueue:
                now_iso = get_cn_time()
                for item in to_enqueue:
                    try:
                        # insert queue entry (store JSON if item contains
                        # media)
                        import json as _json
                        msg_payload = _json.dumps({
                            'content': item.get('content') or '',
                            'image_url': item.get('image_url') or '',
                            'video_url': item.get('video_url') or '',
                            'buttons': item.get('buttons') or '',
                            'buttons_per_row': item.get('buttons_per_row') or 2
                        }, ensure_ascii=False)
                        c.execute(
                            'INSERT INTO broadcast_queue (group_link, group_name, message, status, create_time) VALUES (?, ?, ?, ?, ?)',
                            (item['group_link'],
                             item['group_name'],
                                msg_payload,
                                'pending',
                                now_iso))
                        # update last_sent_time for assignment
                        c.execute(
                            'UPDATE broadcast_assignments SET last_sent_time = ? WHERE id = ?',
                            (now_iso,
                             item['assign_id']))
                    except Exception as e:
                        print(
                            f"[å®šæ—¶ç¾¤å‘] å…¥é˜Ÿå¤±è´¥ assign_id={item.get('assign_id')}: {e}")
                conn.commit()
                print(f"[å®šæ—¶ç¾¤å‘] å·²å…¥é˜Ÿ {len(to_enqueue)} æ¡æ¶ˆæ¯")
            
            conn.close()
        except Exception as e:
            print(f"[å®šæ—¶ç¾¤å‘] é”™è¯¯: {e}")
            await asyncio.sleep(30)


async def process_broadcast_queue():
    """å¤„ç†ç¾¤å‘é˜Ÿåˆ—ï¼ˆæ•°æ®åº“é˜Ÿåˆ—ï¼‰"""
    while True:
        try:
            await asyncio.sleep(5)  # æ¯5ç§’æ£€æŸ¥ä¸€æ¬¡
            conn = get_db_conn()
            c = conn.cursor()
            
            # è·å–å¾…å‘é€çš„ä»»åŠ¡
            c.execute(
                "SELECT id, group_link, group_name, message FROM broadcast_queue WHERE status = 'pending' LIMIT 10")
            tasks = c.fetchall()
            
            for task in tasks:
                task_id, group_link, group_name, message = task
                try:
                    if group_link and 't.me/' in group_link:
                        chat_username = group_link.split(
                            't.me/')[-1].split('/')[0].split('?')[0]
                        if not chat_username.startswith('+'):
                            # æ”¯æŒ message å­˜å‚¨ä¸ºçº¯æ–‡æœ¬æˆ– JSON å­—ç¬¦ä¸²ï¼ˆåŒ…å«
                            # content/image_url/video_url/buttonsï¼‰
                            send_text = None
                            send_image = None
                            send_video = None
                            send_buttons = None
                            try:
                                import json as _json
                                parsed = _json.loads(message)
                                if isinstance(parsed, dict):
                                    send_text = parsed.get('content') or ''
                                    send_image = parsed.get('image_url') or ''
                                    send_video = parsed.get('video_url') or ''
                                    send_buttons = parsed.get('buttons') or ''
                                else:
                                    send_text = str(parsed)
                            except Exception:
                                send_text = message

                            # send file if image or video present
                            if send_image:
                                file_path = send_image
                                if send_image.startswith('/static/uploads/'):
                                    # prefer local file path using UPLOAD_DIR
                                    # from config
                                    try:
                                        from config import UPLOAD_DIR
                                        filename = os.path.basename(send_image)
                                        local_path = os.path.join(
                                            UPLOAD_DIR, filename)
                                    except Exception:
                                        local_path = os.path.join(os.path.dirname(
                                            os.path.dirname(__file__)), send_image.lstrip('/'))

                                    if os.path.exists(local_path):
                                        await bot.send_file(f'@{chat_username}', local_path, caption=send_text)
                                    else:
                                        # fallback to sending as URL and log
                                        # error
                                        print(
                                            f"[ç¾¤å‘é”™è¯¯] æ‰¾ä¸åˆ°æœ¬åœ°å›¾ç‰‡æ–‡ä»¶: {local_path}")
                                        await bot.send_message(f'@{chat_username}', send_text + '\n' + send_image)
                                else:
                                    await bot.send_message(f'@{chat_username}', send_text + '\n' + send_image)
                            elif send_video:
                                file_path = send_video
                                if send_video.startswith('/static/uploads/'):
                                    try:
                                        from config import UPLOAD_DIR
                                        filename = os.path.basename(send_video)
                                        local_path = os.path.join(
                                            UPLOAD_DIR, filename)
                                    except Exception:
                                        local_path = os.path.join(os.path.dirname(
                                            os.path.dirname(__file__)), send_video.lstrip('/'))

                                    if os.path.exists(local_path):
                                        await bot.send_file(f'@{chat_username}', local_path, caption=send_text)
                                    else:
                                        print(
                                            f"[ç¾¤å‘é”™è¯¯] æ‰¾ä¸åˆ°æœ¬åœ°è§†é¢‘æ–‡ä»¶: {local_path}")
                                        await bot.send_message(f'@{chat_username}', send_text + '\n' + send_video)
                                else:
                                    await bot.send_message(f'@{chat_username}', send_text + '\n' + send_video)
                            else:
                                # try to build buttons if any
                                buttons_obj = None
                                if send_buttons:
                                    try:
                                        import json as _json2
                                        btns = _json2.loads(send_buttons)
                                        per_row = 2
                                        # if buttons_per_row present in parsed,
                                        # use it
                                        if isinstance(
                                                parsed, dict) and parsed.get('buttons_per_row'):
                                            per_row = int(
                                                parsed.get('buttons_per_row') or per_row)
                                        rows = []
                                        row_buf = []
                                        for b in btns:
                                            if b.get('name') and b.get('url'):
                                                row_buf.append(
                                                    Button.url(b['name'], b['url']))
                                                if len(row_buf) >= per_row:
                                                    rows.append(row_buf)
                                                    row_buf = []
                                        if row_buf:
                                            rows.append(row_buf)
                                        if rows:
                                            buttons_obj = rows
                                    except Exception:
                                        buttons_obj = None

                                if buttons_obj:
                                    await bot.send_message(f'@{chat_username}', send_text, buttons=buttons_obj)
                                else:
                                    await bot.send_message(f'@{chat_username}', send_text)

                            c.execute(
                                "UPDATE broadcast_queue SET status = 'sent', result = 'å‘é€æˆåŠŸ' WHERE id = ?",
                                (task_id,
                                 ))
                            print(f"[ç¾¤å‘é˜Ÿåˆ—] å·²å‘é€åˆ° {group_name}")
                        else:
                            c.execute(
                                "UPDATE broadcast_queue SET status = 'failed', result = 'ç§æœ‰ç¾¤é“¾æ¥' WHERE id = ?",
                                (task_id,
                                 ))
                    else:
                        c.execute(
                            "UPDATE broadcast_queue SET status = 'failed', result = 'æ— æ•ˆé“¾æ¥' WHERE id = ?",
                            (task_id,
                             ))
                except Exception as e:
                    c.execute(
                        "UPDATE broadcast_queue SET status = 'failed', result = ? WHERE id = ?",
                        (str(e)[
                            :200],
                            task_id))
                    print(f"[ç¾¤å‘é˜Ÿåˆ—] å‘é€åˆ° {group_name} å¤±è´¥: {e}")
                
                conn.commit()
                await asyncio.sleep(1)  # æ¯æ¡æ¶ˆæ¯é—´éš”1ç§’ï¼Œé¿å…é¢‘ç‡é™åˆ¶
            
            conn.close()
        except Exception as e:
            print(f"[ç¾¤å‘é˜Ÿåˆ—] å¤„ç†é”™è¯¯: {e}")
            await asyncio.sleep(10)


async def process_broadcasts():
    """å®šæœŸæ£€æŸ¥å¹¶å¤„ç†å¾…å‘é€çš„ç¾¤å‘ä»»åŠ¡ï¼ˆå†…å­˜é˜Ÿåˆ—ï¼‰"""
    while True:
        try:
            if pending_broadcasts:
                task = pending_broadcasts.pop(0)
                task_type = task.get('type', 'broadcast')
                
                # å¤„ç†ç½®é¡¶å¹¿å‘Šä»»åŠ¡
                if task_type == 'pinned_ad':
                    content = task['content']
                    groups = task['groups']  # [(telegram_id, group_link), ...]
                    
                    print(f'å¼€å§‹å‘å¸ƒç½®é¡¶å¹¿å‘Šåˆ° {len(groups)} ä¸ªç¾¤')
                    success_count = 0
                    fail_count = 0
                    
                    for telegram_id, group_link in groups:
                        try:
                            if not group_link:
                                continue
                            # ä»ç¾¤é“¾æ¥æå–ç¾¤IDæˆ–ç”¨æˆ·å
                            if group_link.startswith('https://t.me/'):
                                group_username = group_link.replace(
                                    'https://t.me/', '')
                            elif group_link.startswith('@'):
                                group_username = group_link
                            else:
                                group_username = group_link
                            
                            # å‘é€å¹¿å‘Šæ¶ˆæ¯
                            msg = await bot.send_message(group_username, f'ğŸ“¢ å…¬å‘Š\n\n{content}')
                            
                            # å°è¯•ç½®é¡¶æ¶ˆæ¯ï¼ˆéœ€è¦ç®¡ç†å‘˜æƒé™ï¼‰
                            try:
                                await bot.pin_message(group_username, msg.id, notify=False)
                            except Exception as pin_err:
                                print(f'ç½®é¡¶å¤±è´¥(å¯èƒ½æ— æƒé™): {pin_err}')
                            
                            success_count += 1
                            await asyncio.sleep(0.5)
                        except Exception as e:
                            fail_count += 1
                            print(f'å‘é€åˆ°ç¾¤ç»„å¤±è´¥ {group_link}: {e}')
                    
                    print(f'ç½®é¡¶å¹¿å‘Šå‘å¸ƒå®Œæˆ: æˆåŠŸ{success_count}ä¸ªç¾¤ï¼Œå¤±è´¥{fail_count}ä¸ª')
                
                # å¤„ç†æ™®é€šç¾¤å‘ä»»åŠ¡
                else:
                    log_id = task.get('log_id')
                    message_content = task.get('message_content', '')
                    group_links = task.get('group_links', [])
                    
                    print(f'å¼€å§‹ç¾¤å‘åˆ°ç¾¤ç»„: {len(group_links)}ä¸ªç¾¤')
                    success_count = 0
                    fail_count = 0
                    
                    for group_link in group_links:
                        try:
                            # ä»ç¾¤é“¾æ¥æå–ç¾¤IDæˆ–ç”¨æˆ·å
                            if group_link.startswith('https://t.me/'):
                                group_username = group_link.replace(
                                    'https://t.me/', '')
                            elif group_link.startswith('@'):
                                group_username = group_link
                            else:
                                group_username = '@' + group_link
                            
                            await bot.send_message(group_username, message_content)
                            success_count += 1
                            await asyncio.sleep(0.5)
                        except Exception as e:
                            fail_count += 1
                            print(f'å‘é€åˆ°ç¾¤ç»„å¤±è´¥ {group_link}: {e}')
                    
                    # æ›´æ–°æ—¥å¿—çŠ¶æ€
                    if log_id:
                        conn = get_db_conn()
                        c = conn.cursor()
                        c.execute('''
                            UPDATE broadcast_logs 
                            SET status = 'completed', 
                                sent_count = ?, 
                                failed_count = ?
                            WHERE id = ?
                        ''', (success_count, fail_count, log_id))
                        conn.commit()
                        conn.close()
                    
                    print(f'ç¾¤ç»„ç¾¤å‘å®Œæˆ: æˆåŠŸå‘é€åˆ°{success_count}ä¸ªç¾¤ï¼Œå¤±è´¥{fail_count}ä¸ª')
            
            await asyncio.sleep(1)  # æ¯ç§’æ£€æŸ¥ä¸€æ¬¡
        except Exception as e:
            print(f'ç¾¤å‘ä»»åŠ¡å¤„ç†å¼‚å¸¸: {e}')
            await asyncio.sleep(5)


async def check_member_status_task():
    """
    ã€æ ¸å¿ƒä¿®å¤ã€‘å®šæœŸè½®è¯¢ï¼Œä½œä¸º Raw äº‹ä»¶çš„å…œåº•ã€‚
    æ¯ 30 ç§’æ£€æŸ¥ä¸€æ¬¡æ‰€æœ‰ç»‘å®šäº†ç¾¤ç»„çš„æœºå™¨äººæƒé™ã€‚
    """
    while True:
        try:
            await asyncio.sleep(30)
            print("[è½®è¯¢æ£€æµ‹] å¼€å§‹æ£€æŸ¥æ‰€æœ‰ç¾¤ç»„æƒé™...")
            
            conn = get_db_conn()
            c = conn.cursor()
            # ã€ä¿®å¤ã€‘è·å–æ‰€æœ‰ç»‘å®šäº†ç¾¤ç»„çš„è®°å½•ï¼Œä¸ä»…ä»…æ˜¯ç®¡ç†å‘˜çš„
            c.execute(
                "SELECT telegram_id, group_id, group_link, is_bot_admin FROM member_groups WHERE group_id IS NOT NULL")
            groups = c.fetchall()
            conn.close()

            for uid, gid, link, current_is_admin in groups:
                if not gid and not link:
                    continue

                # ç¡®å®šè¦æ£€æŸ¥çš„ç¾¤æ ‡è¯†ç¬¦ (IDä¼˜å…ˆï¼Œå…¶æ¬¡é“¾æ¥)
                target = gid if gid else link

                # ä½¿ç”¨å¤šæœºå™¨äººæ£€æŸ¥
                is_in, admin_bot_id = await check_any_bot_in_group(clients, target)

                # è·å–æ•°æ®åº“ä¸­å½“å‰çš„ç®¡ç†å‘˜çŠ¶æ€
                db_is_admin = current_is_admin or 0

                if is_in and admin_bot_id:
                    # æœºå™¨äººåœ¨ç¾¤é‡Œä¸”æ˜¯ç®¡ç†å‘˜
                    if db_is_admin == 0:
                        # æ•°æ®åº“çŠ¶æ€éœ€è¦æ›´æ–°ä¸ºç®¡ç†å‘˜
                        print(f"[è½®è¯¢æ£€æµ‹] âœ… ç”¨æˆ· {uid} çš„ç¾¤ç»„ {gid} æƒé™æ­£å¸¸ï¼Œæ›´æ–°æ•°æ®åº“")
                        conn = get_db_conn()
                        c = conn.cursor()
                        c.execute(
                            'UPDATE member_groups SET is_bot_admin = 1 WHERE group_id = ? AND telegram_id = ?',
                            (gid,
                             uid))
                        c.execute(
                            'UPDATE members SET is_bot_admin = 1 WHERE telegram_id = ?', (uid,))
                        conn.commit()
                        conn.close()
                else:
                    # ä¸åœ¨ç¾¤é‡Œï¼Œæˆ–è€…åœ¨ç¾¤é‡Œä½†ä¸æ˜¯ç®¡ç†å‘˜
                    if db_is_admin == 1:
                        # æƒé™ä¸¢å¤±ï¼Œéœ€è¦é€šçŸ¥å¹¶æ›´æ–°æ•°æ®åº“
                        print(
                            f"[è½®è¯¢æ£€æµ‹] âš ï¸ ç”¨æˆ· {uid} çš„ç¾¤ç»„ {gid} æƒé™å¼‚å¸¸ (åœ¨ç¾¤:{is_in}, ç®¡ç†:{admin_bot_id})")

                        # æ‰¾åˆ°ä¸€ä¸ªå¯ç”¨çš„ bot ç”¨äºå‘é€é€šçŸ¥
                        notify_bot = clients[0] if clients else None

                        # è§¦å‘é€šçŸ¥
                        raw_chat_id = gid if gid else 0
                        await notify_group_binding_invalid(raw_chat_id, uid, "ç³»ç»Ÿæ£€æµ‹å‘ç°æœºå™¨äººæƒé™ä¸¢å¤±", notify_bot)

                        # æ›´æ–°æ•°æ®åº“çŠ¶æ€
                        conn = get_db_conn()
                        c = conn.cursor()
                        if gid:
                            c.execute(
                                'UPDATE member_groups SET is_bot_admin = 0 WHERE group_id = ?', (gid,))
                        c.execute(
                            'UPDATE members SET is_bot_admin = 0 WHERE telegram_id = ?', (uid,))
                        conn.commit()
                        conn.close()

                await asyncio.sleep(0.5)  # é¿å…é€Ÿç‡é™åˆ¶

        except Exception as e:
            print(f"[è½®è¯¢æ£€æµ‹] å¼‚å¸¸: {e}")
            await asyncio.sleep(10)


async def check_permission_changes():
    """å®šæœŸæ£€æŸ¥ç»‘å®šç¾¤ç»„æƒé™"""
    try:
        conn = get_db_conn()
        c = conn.cursor()
        c.execute(
            "SELECT telegram_id, group_id FROM member_groups WHERE is_bot_admin = 1")
        rows = c.fetchall()
        conn.close()

        for uid, gid in rows:
            if not gid:
                continue
            target_bot = None
            for client in clients:
                try:
                    me = await client.get_me()
                    if me.id == uid:
                        target_bot = client
                        break
                except BaseException:
                    continue
            
            if not target_bot:
                continue
            
            try:
                full_chat_id = int(f"-100{gid}") if gid > 0 else gid
                perms = await target_bot.get_permissions(full_chat_id, uid)
                if not (perms.is_admin or perms.is_creator):
                    print(f"[æƒé™æ£€æŸ¥] æœºå™¨äºº {uid} åœ¨ç¾¤ {gid} å¤±å»æƒé™")
                    await notify_group_binding_invalid(gid, uid, "å®šæœŸæ£€æŸ¥å‘ç°æƒé™ä¸¢å¤±", target_bot)
                    conn = get_db_conn()
                    c = conn.cursor()
                    c.execute(
                        'UPDATE member_groups SET is_bot_admin = 0 WHERE telegram_id = ? AND group_id = ?',
                        (uid,
                         gid))
                    c.execute(
                        'UPDATE members SET is_bot_admin = 0 WHERE telegram_id = ?', (uid,))
                    conn.commit()
                    conn.close()
            except BaseException:
                pass
    except Exception as e:
        print(f"[æƒé™æ£€æŸ¥] é”™è¯¯: {e}")


def run_bot():
    """Bot å¯åŠ¨å…¥å£"""
    print("ğŸš€ Telegram Bots (Multi) å¯åŠ¨ä¸­...")

    if not clients:
        print("âŒ æ²¡æœ‰æ´»è·ƒçš„æœºå™¨äººå®¢æˆ·ç«¯ï¼Œè·³è¿‡Botå¯åŠ¨")
        print("ğŸ’¡ è¯·åœ¨Webåå°çš„æœºå™¨äººè®¾ç½®ä¸­æ·»åŠ å¹¶å¯ç”¨æœºå™¨äºº")
        return

    try:
        # å¯åŠ¨åå°ä»»åŠ¡
        loop = asyncio.get_event_loop()
        loop.create_task(process_notify_queue())
        loop.create_task(auto_broadcast_timer())
        loop.create_task(check_member_status_task())
        loop.create_task(process_broadcast_queue())
        loop.create_task(process_broadcasts())

        async def _process_recharge_queue_worker():
            while True:
                try:
                    if process_recharge_queue:
                        item = process_recharge_queue.pop(0)
                        await process_recharge(item.get('member_id'), item.get('amount'), item.get('is_vip_order'))
                except Exception as e:
                    print(f"[å……å€¼é˜Ÿåˆ—] å¤„ç†å¤±è´¥: {e}")
                await asyncio.sleep(1)

        loop.create_task(_process_recharge_queue_worker())

        # åœ¨æœºå™¨äººå¯åŠ¨ååŒæ­¥ä¼šå‘˜ç¾¤ç»„æ•°æ® (å»¶è¿Ÿæ‰§è¡Œï¼Œç¡®ä¿è¿æ¥å®Œæˆ)
        async def sync_after_start():
            global clients  # å£°æ˜å…¨å±€å˜é‡
            try:
                # ç­‰å¾…ä¸€æ®µæ—¶é—´ï¼Œç¡®ä¿æœºå™¨äººå®Œå…¨è¿æ¥
                await asyncio.sleep(10)
                print("ğŸ”„ åŒæ­¥ä¼šå‘˜ç¾¤ç»„æ•°æ®...")

                # æ£€æŸ¥æœºå™¨äººè¿æ¥çŠ¶æ€ (æœºå™¨äººAPIå…¼å®¹çš„æ£€æŸ¥)
                connected_clients = []
                for i, client in enumerate(clients):
                    try:
                        # æœºå™¨äººåªèƒ½ä½¿ç”¨å…è®¸çš„APIæ–¹æ³•ï¼šget_me()
                        me = await client.get_me()
                        if me and me.id:
                            connected_clients.append(client)
                            print(f"âœ… æœºå™¨äºº {i+1} è¿æ¥æ­£å¸¸ (ID: {me.id})")
                        else:
                            print(f"âš ï¸ æœºå™¨äºº {i+1} æ— æ³•è·å–æœºå™¨äººä¿¡æ¯")
                    except Exception as e:
                        print(f"âš ï¸ æœºå™¨äºº {i+1} è¿æ¥å¼‚å¸¸: {e}")

                if not connected_clients:
                    print("âŒ æ²¡æœ‰å¯ç”¨çš„æœºå™¨äººè¿æ¥ï¼Œè·³è¿‡åŒæ­¥")
                    return

                print(f"ğŸ“Š å…±æœ‰ {len(connected_clients)} ä¸ªæœºå™¨äººå¯ç”¨äºåŒæ­¥")

                try:
                    from .database import sync_member_groups_from_members
                    # ä¼ é€’å·²è¿æ¥çš„å®¢æˆ·ç«¯åˆ—è¡¨ç»™åŒæ­¥å‡½æ•°
                    await sync_member_groups_from_members(connected_clients)
                    print("âœ… ä¼šå‘˜ç¾¤ç»„æ•°æ®åŒæ­¥å®Œæˆ")
                except Exception as e:
                    print(f"âš ï¸ ä¼šå‘˜ç¾¤ç»„æ•°æ®åŒæ­¥å¤±è´¥: {e}")
                    import traceback
                    traceback.print_exc()

            except Exception as e:
                print(f"âš ï¸ ä¼šå‘˜ç¾¤ç»„æ•°æ®åŒæ­¥å¤±è´¥: {e}")
                import traceback
                traceback.print_exc()

        loop.create_task(sync_after_start())

        print("âœ… æ‰€æœ‰åå°ä»»åŠ¡å·²æŒ‚è½½")
        print(f"âœ… {len(clients)} ä¸ªæœºå™¨äººæ­£åœ¨ç›‘å¬æ¶ˆæ¯...")

        # æ‰€æœ‰æœºå™¨äººå…±äº«åŒä¸€ä¸ªäº‹ä»¶å¾ªç¯å¹¶å‘è¿è¡Œ
        print("ğŸ”„ æ­£åœ¨è¿æ¥åˆ°TelegramæœåŠ¡å™¨...")

        async def run_all_bots():
            """è¿è¡Œæ‰€æœ‰æœºå™¨äººç›´åˆ°æ–­å¼€"""
            try:
                # å®¢æˆ·ç«¯å·²ç»åœ¨åˆå§‹åŒ–æ—¶å¯åŠ¨äº†ï¼Œè¿™é‡Œåªéœ€è¦ç­‰å¾…æ–­å¼€
                print("ğŸ”„ æ‰€æœ‰æœºå™¨äººæ­£åœ¨è¿è¡Œï¼Œç­‰å¾…æ¶ˆæ¯...")

                # ç­‰å¾…ä»»ä¸€å®¢æˆ·ç«¯æ–­å¼€
                disconnect_futures = [
                    client.disconnected for client in clients]
                done, pending = await asyncio.wait(disconnect_futures, return_when=asyncio.FIRST_COMPLETED)

                print("ğŸ›‘ ä¸€ä¸ªæˆ–å¤šä¸ªæœºå™¨äººå·²æ–­å¼€è¿æ¥ï¼Œæ­£åœ¨åœæ­¢å…¶ä»–æœºå™¨äºº...")
                # å–æ¶ˆå…¶ä»–å¾…å¤„ç†çš„ Future
                for future in pending:
                    if not future.done():
                        future.cancel()

            except Exception as e:
                print(f"âŒ å¤šæœºå™¨äººè¿è¡Œå¤±è´¥: {e}")
                import traceback
                traceback.print_exc()

        # è¿è¡Œæ‰€æœ‰æœºå™¨äºº
        try:
            loop.run_until_complete(run_all_bots())
        except KeyboardInterrupt:
            print("ğŸ›‘ æ”¶åˆ°åœæ­¢ä¿¡å·ï¼Œæ­£åœ¨å…³é—­æœºå™¨äºº...")
        except Exception as e:
            print(f"âŒ æœºå™¨äººè¿è¡Œå¤±è´¥: {e}")
            import traceback
            traceback.print_exc()

    except Exception as e:
        print(f"âŒ æœºå™¨äººè¿è¡Œè¿‡ç¨‹ä¸­å‡ºç°é”™è¯¯: {e}")
        import traceback
        traceback.print_exc()
        print("ğŸ’¡ æœºå™¨äººå·²åœæ­¢ï¼Œä½†WebæœåŠ¡å¯èƒ½ä»åœ¨è¿è¡Œ")


async def add_bot_dynamically(db_id, token):
    try:
        session_name = f'bot_{db_id}'
        session_path = os.path.join(SESSION_DIR, session_name)
        print(f"[åŠ¨æ€æ·»åŠ ] æ­£åœ¨å¯åŠ¨ Bot ID {db_id} (Session: {session_name})...")

        client = TelegramClient(session_path, API_ID, API_HASH, proxy=proxy)
        await client.start(bot_token=token)

        for handler, event_builder in registered_handlers:
            client.add_event_handler(handler, event_builder)

        clients.append(client)
        global bot
        if bot is None:
            bot = client

        print(f"[åŠ¨æ€æ·»åŠ ] âœ… å¯åŠ¨æˆåŠŸ: {token[:10]}...")
        return True, "å¯åŠ¨æˆåŠŸ"
    except Exception as e:
        print(f"[åŠ¨æ€æ·»åŠ ] âŒ å¯åŠ¨å¤±è´¥ (ID: {db_id}): {e}")
        return False, str(e)


# å¯¼å‡º
__all__ = [
    'bot', 'clients', 'process_vip_upgrade', 'process_recharge',
    'admin_manual_vip_handler', 'get_main_account_id', 'run_bot',
    'pending_broadcasts', 'notify_queue',
    'add_bot_dynamically',
    # åå°ä»»åŠ¡ï¼ˆä¾›è°ƒè¯•ä½¿ç”¨ï¼‰
    'auto_broadcast_timer',
    'process_broadcast_queue',
    'process_broadcasts',
    'check_member_status_task',
    'process_notify_queue'
]

--- File: ./app/run.py ---
"""
å¯åŠ¨å…¥å£ - ç»Ÿä¸€å¯åŠ¨Botå’ŒWebåå°
"""
import threading
import time
# ã€æ³¨æ„ã€‘è¿™é‡Œå¿…é¡»åŠ ç‚¹ . è¡¨ç¤ºä»å½“å‰åŒ…å¯¼å…¥
from .database import init_db, sync_member_groups_from_members
from .bot_logic import run_bot
from .config import PUBLIC_BASE_URL

def main():
    print("=" * 60)
    print("ğŸ¤– è£‚å˜æ¨å¹¿æœºå™¨äººç³»ç»Ÿå¯åŠ¨ä¸­...")
    print("=" * 60)
    print()
    
    # 1. åˆå§‹åŒ–æ•°æ®åº“
    print("ğŸ“Š åˆå§‹åŒ–æ•°æ®åº“...")
    init_db()
    print("âœ… æ•°æ®åº“åˆå§‹åŒ–å®Œæˆ")
    
    # åŒæ­¥å·²æœ‰ä¼šå‘˜ç¾¤é“¾æ¥åˆ° member_groups
    print("ğŸ”„ åŒæ­¥ä¼šå‘˜ç¾¤ç»„æ•°æ®...")
    print("â„¹ï¸ è·³è¿‡å¯åŠ¨æ—¶çš„ç¾¤ç»„æ•°æ®åŒæ­¥ï¼Œå°†åœ¨æœºå™¨äººå¯åŠ¨åè¿›è¡Œ")
    print()
    
    # 2. å¯åŠ¨ Web åå° (åœ¨ç‹¬ç«‹çº¿ç¨‹ä¸­)
    print("ğŸŒ å¯åŠ¨Webç®¡ç†åå°...")
    web_thread = None
    try:
        # ã€æ³¨æ„ã€‘è¿™é‡Œçš„å¯¼å…¥ä¹Ÿå»ºè®®æ£€æŸ¥ä¸€ä¸‹ web_app.py å†…éƒ¨æ˜¯å¦ä½¿ç”¨äº†ç›¸å¯¹å¯¼å…¥
        from .web_app import run_web
        web_thread = threading.Thread(target=run_web, daemon=True)
        web_thread.start()
        print("âœ… Webç®¡ç†åå°å·²å¯åŠ¨ (ç«¯å£: 5051)")
    except Exception as e:
        print(f"âš ï¸ Webåå°å¯åŠ¨å¤±è´¥: {e}")
        print("ç»§ç»­å¯åŠ¨Bot...")
    print()
    
    # 3. å¯åŠ¨ Bot (ä¸»çº¿ç¨‹)
    print("ğŸš€ Telegramæœºå™¨äººå¯åŠ¨ä¸­...")
    print()
    print("=" * 60)
    print("ğŸ“± è®¿é—®åœ°å€ï¼š")
    print("   Webåå°: http://localhost:5051")
    if PUBLIC_BASE_URL:
        print(f"   å…¬ç½‘åœ°å€: {PUBLIC_BASE_URL}")
    print("=" * 60)
    print()
    
    try:
        run_bot()

        # ä¿æ´»é€»è¾‘
        print("â„¹ï¸ BotæœåŠ¡æœªå¯åŠ¨æˆ–å·²ç»“æŸï¼Œä¸»è¿›ç¨‹è¿›å…¥ä¿æ´»æ¨¡å¼ä»¥ç»´æŒWebåå°è¿è¡Œ...")
        while True:
            time.sleep(10)

    except KeyboardInterrupt:
        print("\nğŸ›‘ æ”¶åˆ°åœæ­¢ä¿¡å·ï¼Œæ­£åœ¨å…³é—­æœåŠ¡...")
        if web_thread and web_thread.is_alive():
            print("æ­£åœ¨åœæ­¢WebæœåŠ¡å™¨...")
        print("âœ… æœåŠ¡å·²åœæ­¢")
    except Exception as e:
        print(f"âŒ æœºå™¨äººå¯åŠ¨å¤±è´¥: {e}")
        import traceback
        traceback.print_exc()

        if web_thread and web_thread.is_alive():
            print("ğŸ’¡ WebæœåŠ¡å¯èƒ½ä»åœ¨è¿è¡Œï¼Œå¯ä»¥å•ç‹¬è®¿é—®ç®¡ç†åå°")
            print("â„¹ï¸ ä¸»è¿›ç¨‹è¿›å…¥ä¿æ´»æ¨¡å¼ä»¥ç»´æŒWebåå°è¿è¡Œ...")
            while True:
                time.sleep(10)
        else:
            print("âŒ æ‰€æœ‰æœåŠ¡å¯åŠ¨å¤±è´¥ï¼Œè¯·æ£€æŸ¥é…ç½®å’Œç½‘ç»œè¿æ¥")

if __name__ == '__main__':
    main()
--- File: ./app/web_app.py ---
"""
Webåå°å±‚ - ç»Ÿä¸€ç®¡ç†æ‰€æœ‰Flaskè·¯ç”±
æ‰€æœ‰è·¯ç”±éƒ½åœ¨æ­¤æ–‡ä»¶ä¸­ç›´æ¥å®šä¹‰ï¼Œä¸å†ä¾èµ–å¤–éƒ¨è·¯ç”±æ–‡ä»¶
"""
import os
import uuid
import json  # ç¡®ä¿å¯¼å…¥json
from datetime import datetime, timedelta
from flask import Flask, render_template, jsonify, request, redirect, url_for
from flask_login import LoginManager, login_required, logout_user, current_user
from werkzeug.security import generate_password_hash, check_password_hash

from .database import DB, WebDB, AdminUser, get_system_config, get_db_conn, get_cn_time, update_system_config
from .config import UPLOAD_DIR, BASE_DIR, PUBLIC_BASE_URL

# å»¶è¿Ÿå¯¼å…¥botï¼Œé¿å…å¾ªç¯ä¾èµ–
try:
    from .bot_logic import bot, process_recharge, admin_manual_vip_handler, notify_queue, pending_broadcasts
except ImportError:
    # å¦‚æœå¯¼å…¥å¤±è´¥ï¼Œè®¾ç½®ä¸ºNoneï¼Œåç»­ä½¿ç”¨æ—¶å†å¯¼å…¥
    bot = None
    process_recharge = None
    admin_manual_vip_handler = None
    notify_queue = []
    # æ³¨æ„ï¼šè¿™é‡Œä¸åº”è¯¥é‡æ–°èµ‹å€¼pending_broadcastsï¼Œå¦åˆ™ä¼šè¦†ç›–å¯¼å…¥çš„å˜é‡
    if 'pending_broadcasts' not in globals():
        pending_broadcasts = []

# åˆå§‹åŒ–Flask
template_dir = os.path.join(os.path.dirname(os.path.dirname(__file__)), 'templates')
static_dir = os.path.join(os.path.dirname(os.path.dirname(__file__)), 'static')
app = Flask(__name__, template_folder=template_dir, static_folder=static_dir)
app.secret_key = 'fission-bot-secret-key-2025'
app.config['REMEMBER_COOKIE_DURATION'] = timedelta(days=90)
app.config['TEMPLATES_AUTO_RELOAD'] = True
app.jinja_env.auto_reload = True

login_manager = LoginManager()
login_manager.init_app(app)
login_manager.login_view = 'login'

@login_manager.user_loader
def load_user(user_id):
    return WebDB.get_user_by_id(int(user_id))

# For API routes, return JSON 401 instead of redirecting to login page (prevents HTML responses on fetch)
@app.before_request
def api_require_login_for_api():
    try:
        # ã€æ ¸å¿ƒä¿®å¤ã€‘å®šä¹‰ç™½åå•ï¼Œå…è®¸æ”¯ä»˜å›è°ƒä¸ç™»å½•ä¹Ÿèƒ½è®¿é—®
        whitelist = [
            '/api/payment/notify',     # æ”¯ä»˜å›è°ƒ
            '/api/payment/test',       # æµ‹è¯•æ¥å£
            '/login'                   # ç™»å½•æ¥å£
        ]

        # å¦‚æœè¯·æ±‚è·¯å¾„å®Œå…¨åŒ¹é…ç™½åå•ï¼Œç›´æ¥æ”¾è¡Œ
        if request.path in whitelist:
            return None

        # å¦‚æœæ˜¯APIè¯·æ±‚ä¸”ä¸åœ¨ç™½åå•å†…ï¼Œæ‰æ£€æŸ¥ç™»å½•çŠ¶æ€
        if request.path.startswith('/api/') and not current_user.is_authenticated:
            return jsonify({'success': False, 'message': 'æœªç™»å½•'}), 401
    except Exception:
        pass

# ==================== æ”¯ä»˜ç³»ç»Ÿé…ç½® ====================
# å®Œå…¨ä»æ•°æ®åº“åŠ è½½ï¼Œä¸ä½¿ç”¨ç¡¬ç¼–ç é»˜è®¤å€¼
PAYMENT_CONFIG = {
    'notify_url': (f"{PUBLIC_BASE_URL}/api/payment/notify" if PUBLIC_BASE_URL else ''),
    'return_url': (f"{PUBLIC_BASE_URL}/payment/success" if PUBLIC_BASE_URL else ''),
    'version': '1.0'
}

# æ·»åŠ ä¸€ä¸ªç®€å•çš„æµ‹è¯•ç«¯ç‚¹æ¥éªŒè¯å›è°ƒURLæ˜¯å¦å¯è®¿é—®
@app.route('/api/payment/test', methods=['GET'])
def test_payment_callback():
    """æµ‹è¯•æ”¯ä»˜å›è°ƒURLæ˜¯å¦å¯è®¿é—®"""
    return jsonify({
        'status': 'ok',
        'message': 'æ”¯ä»˜å›è°ƒURLå¯æ­£å¸¸è®¿é—®',
        'timestamp': get_cn_time(),
        'config': {
            'notify_url': PAYMENT_CONFIG.get('notify_url'),
            'has_key': bool(PAYMENT_CONFIG.get('key'))
        }
    })

import hashlib
import requests as req

def process_vip_upgrade_sync(telegram_id, vip_price, config, deduct_balance=True):
    """åŒæ­¥ç‰ˆæœ¬çš„VIPå¼€é€šå¤„ç†ï¼ˆç”¨äºæ”¯ä»˜å›è°ƒï¼‰"""
    try:
        from bot_logic import DB, distribute_vip_rewards, get_system_config

        member = DB.get_member(telegram_id)
        if not member:
            print(f"[VIPå¼€é€šåŒæ­¥] ç”¨æˆ·ä¸å­˜åœ¨: {telegram_id}")
            return False, "ç”¨æˆ·ä¸å­˜åœ¨"

        if member.get('is_vip'):
            print(f"[VIPå¼€é€šåŒæ­¥] ç”¨æˆ·å·²æ˜¯VIP: {telegram_id}")
            return False, "ç”¨æˆ·å·²æ˜¯VIP"

        print(f"[VIPå¼€é€šåŒæ­¥] ç”¨æˆ·ä¿¡æ¯: telegram_id={telegram_id}, å½“å‰ä½™é¢={member.get('balance', 0)}, VIPä»·æ ¼={vip_price}, éœ€è¦æ‰£è´¹={deduct_balance}")

        # æ£€æŸ¥ä½™é¢ï¼ˆå¦‚æœéœ€è¦æ‰£è´¹ï¼‰
        if deduct_balance:
            if member.get('balance', 0) < vip_price:
                print(f"[VIPå¼€é€šåŒæ­¥] ä½™é¢ä¸è¶³: éœ€è¦{vip_price}, å½“å‰{member.get('balance', 0)}")
                return False, "ä½™é¢ä¸è¶³"
            # æ‰£é™¤VIPè´¹ç”¨
            new_balance = member['balance'] - vip_price
            print(f"[VIPå¼€é€šåŒæ­¥] æ‰£è´¹å‰ä½™é¢: {member['balance']}, æ‰£è´¹åä½™é¢: {new_balance}")
            DB.update_member(telegram_id, balance=new_balance, is_vip=1, vip_time=get_cn_time())
            print(f"[VIPå¼€é€šåŒæ­¥] æ•°æ®åº“æ›´æ–°å®Œæˆ: balance={new_balance}, is_vip=1")
        else:
            # ä¸æ‰£è´¹ï¼Œç›´æ¥å¼€é€š
            DB.update_member(telegram_id, is_vip=1, vip_time=get_cn_time())
            print(f"[VIPå¼€é€šåŒæ­¥] ä¸æ‰£è´¹å¼€é€šVIPå®Œæˆ")

        # åˆ†å‘VIPå¥–åŠ±
        print(f"[VIPå¼€é€šåŒæ­¥] å¼€å§‹åˆ†å‘å¥–åŠ±")
        distribute_vip_rewards(telegram_id, vip_price)
        print(f"[VIPå¼€é€šåŒæ­¥] å¥–åŠ±åˆ†å‘å®Œæˆ")

        return True, {'new_balance': member.get('balance', 0) if not deduct_balance else new_balance}
    except Exception as e:
        print(f"[VIPå¼€é€šåŒæ­¥] é”™è¯¯: {e}")
        import traceback
        traceback.print_exc()
        return False, str(e)

def generate_payment_sign(params, key):
    """ç”Ÿæˆæ”¯ä»˜ç­¾å"""
    sorted_params = sorted([(k, v) for k, v in params.items() if v is not None and v != ''])
    sign_str = '&'.join([f'{k}={v}' for k, v in sorted_params])
    sign_str += f'&key={key}'
    return hashlib.md5(sign_str.encode()).hexdigest().upper()

# ==================== ç™»å½•è®¤è¯ ====================

@app.route('/login', methods=['GET', 'POST'])
def login():
    if request.method == 'POST':
        data = request.json
        username = data.get('username')
        password = data.get('password')
        remember = data.get('remember', False)
        
        user = WebDB.get_user_by_username(username)
        if user and check_password_hash(user.password_hash, password):
            from flask_login import login_user
            login_user(user, remember=remember)
            return jsonify({'success': True, 'message': 'ç™»å½•æˆåŠŸ'})
        
        return jsonify({'success': False, 'message': 'ç”¨æˆ·åæˆ–å¯†ç é”™è¯¯'}), 401
        
    if current_user.is_authenticated:
        return redirect(url_for('index'))
    return render_template('login.html')

@app.route('/logout')
@login_required
def logout():
    logout_user()
    return redirect(url_for('login'))

@app.route('/api/change_password', methods=['POST'])
@login_required
def api_change_password():
    data = request.json
    old_password = data.get('old_password')
    new_password = data.get('new_password')
    
    user = WebDB.get_user_by_id(current_user.id)
    
    if not check_password_hash(user.password_hash, old_password):
        return jsonify({'success': False, 'message': 'æ—§å¯†ç é”™è¯¯'}), 400
        
    WebDB.update_password(user.id, new_password)
    return jsonify({'success': True, 'message': 'å¯†ç ä¿®æ”¹æˆåŠŸ'})

# ==================== åŸºç¡€é¡µé¢è·¯ç”± ====================

@app.route('/')
@login_required
def index():
    """ä¸»é¡µ - æ•°æ®ç»Ÿè®¡"""
    return render_template('dashboard.html', active_page='dashboard')

@app.route('/members')
@login_required
def members_page():
    """ä¼šå‘˜ç®¡ç†é¡µé¢"""
    return render_template('members.html', active_page='members')

@app.route('/settings')
@login_required
def settings_page():
    """è®¾ç½®é¡µé¢"""
    return render_template('settings.html', active_page='settings')

@app.route('/statistics')
@login_required
def statistics_page():
    """ç»Ÿè®¡æŠ¥è¡¨é¡µé¢"""
    return render_template('statistics.html', active_page='statistics')

@app.route('/withdrawals')
@login_required
def withdrawals_page():
    """æç°ç®¡ç†é¡µé¢"""
    return render_template('withdrawals.html', active_page='withdrawals')

@app.route('/recharges')
@login_required
def recharges():
    """å……å€¼è®¢å•ç®¡ç†é¡µé¢"""
    return render_template('recharges.html')

@app.route('/earnings')
@login_required
def earnings_page():
    """æ”¶ç›Šè®°å½•ç®¡ç†é¡µé¢"""
    return render_template('earnings.html', active_page='earnings')

@app.route('/resources')
@login_required
def resources_page():
    """è¡Œä¸šèµ„æºç®¡ç†é¡µé¢"""
    return render_template('resources.html', active_page='resources')

@app.route('/customer-service')
@login_required
def customer_service_page():
    """å®¢æœç®¡ç†é¡µé¢"""
    return render_template('customer_service.html', active_page='customer_service')

@app.route('/broadcast')
@login_required
def broadcast_page():
    """ç¾¤å‘ç®¡ç†é¡µé¢"""
    return render_template('broadcast.html', active_page='broadcast')

@app.route('/bot-settings')
@login_required
def bot_settings_page():
    """æœºå™¨äººè®¾ç½®é¡µé¢"""
    return render_template('bot_settings.html', active_page='bot_settings')

@app.route('/level-settings')
@login_required
def level_settings_page():
    """å±‚çº§è®¾ç½®é¡µé¢"""
    return render_template('level_settings.html', active_page='level_settings')

@app.route('/member-groups')
@login_required
def member_groups_page():
    """ä¼šå‘˜ç¾¤ç®¡ç†é¡µé¢"""
    return render_template('member_groups.html', active_page='member_groups')

@app.route('/fallback-accounts')
@login_required
def fallback_accounts_page():
    """æ¡æ¼è´¦å·ç®¡ç†é¡µé¢"""
    return render_template('fallback_accounts.html', active_page='fallback_accounts')

@app.route('/team-graph')
@login_required
def team_graph_index():
    """å›¢é˜Ÿå›¾è°±å…¥å£é¡µ"""
    return render_template('team_graph_all.html', active_page='team_graph')

@app.route('/team-graph/<int:telegram_id>')
@login_required
def team_graph_page(telegram_id):
    """å›¢é˜Ÿå›¾è°±è¯¦æƒ…é¡µé¢"""
    return render_template('team_graph.html', telegram_id=telegram_id, active_page='team_graph')

# ==================== æ”¯ä»˜å›è°ƒ ====================

@app.route('/api/payment/notify', methods=['POST', 'GET'])
def payment_notify():
    """æ”¯ä»˜å¼‚æ­¥å›è°ƒé€šçŸ¥"""
    try:
        # 1. è·å–å‚æ•°
        if request.method == 'POST':
            raw_data = request.form.to_dict()
            if not raw_data:
                raw_data = request.get_json(silent=True) or {}
        else:
            raw_data = request.args.to_dict()

        print(f'[æ”¯ä»˜å›è°ƒ] æ”¶åˆ°æ•°æ®: {raw_data}')

        if not raw_data:
            return 'fail'

        # 2. éªŒè¯ç­¾å
        # æ–‡æ¡£è¯´æ˜ï¼šremark ä¸å‚ä¸ç­¾å
        # ç®—æ³•ï¼šéç©ºå­—æ®µæ’åºæ‹¼æ¥ + &key=... -> MD5 -> Upper

        sign_received = raw_data.get('sign', '')
        my_key = PAYMENT_CONFIG.get('key', '')

        # è¿‡æ»¤å‚ä¸ç­¾åçš„å‚æ•°
        params_to_sign = {}
        for k, v in raw_data.items():
            if k == 'sign': continue
            if k == 'remark': continue # æ–‡æ¡£2.3æ˜ç¡®æŒ‡å‡ºremarkä¸å‚ä¸ç­¾å
            if v == '' or v is None: continue
            params_to_sign[k] = str(v)

        # æ’åºå¹¶æ‹¼æ¥
        sorted_keys = sorted(params_to_sign.keys())
        sign_str = '&'.join([f'{k}={params_to_sign[k]}' for k in sorted_keys])
        sign_str_with_key = f"{sign_str}&key={my_key}"

        # è®¡ç®—ç­¾å
        calc_sign = hashlib.md5(sign_str_with_key.encode('utf-8')).hexdigest().upper()

        if sign_received.upper() != calc_sign:
            print(f'[æ”¯ä»˜å›è°ƒ] ç­¾åéªŒè¯å¤±è´¥! æ”¶åˆ°: {sign_received}, è®¡ç®—: {calc_sign}')
            print(f'[æ”¯ä»˜å›è°ƒ] ç­¾ååŸä¸²: {sign_str_with_key}')
            return 'fail'
        
        # 3. ä¸šåŠ¡å¤„ç†
        # å‡è®¾ status=4 ä¸ºæˆåŠŸ (å‚è€ƒæ–‡æ¡£)
        # æ–‡æ¡£å‚æ•°ï¼šstatus string è®¢å•æ”¯ä»˜çŠ¶æ€ 4ï¼šæ”¯ä»˜æˆåŠŸ
        status = str(raw_data.get('status', ''))
        out_trade_no = raw_data.get('out_trade_no')
        amount = float(raw_data.get('amount', 0))

        if status == '4':
            conn = get_db_conn()
            c = conn.cursor()

            # æŸ¥è¯¢è®¢å•
            c.execute('SELECT member_id, status, remark FROM recharge_records WHERE order_id = ?', (out_trade_no,))
            order = c.fetchone()

            if order:
                member_id, current_status, remark = order

                # é˜²æ­¢é‡å¤å¤„ç†
                if current_status != 'completed':
                    # æ›´æ–°è®¢å•çŠ¶æ€
                    c.execute("UPDATE recharge_records SET status = 'completed' WHERE order_id = ?", (out_trade_no,))

                    # å¢åŠ ä½™é¢
                    c.execute("UPDATE members SET balance = balance + ? WHERE telegram_id = ?", (amount, member_id))
                    conn.commit()

                    print(f'[æ”¯ä»˜å›è°ƒ] è®¢å• {out_trade_no} å¤„ç†æˆåŠŸï¼Œå……å€¼ {amount} U')

                    # è§¦å‘åç»­é€»è¾‘ (æ¨å…¥Boté˜Ÿåˆ—)
                    try:
                        import bot_logic
                        # åˆ¤æ–­æ˜¯å¦ä¸ºVIPå¼€é€šæ„å‘
                        is_vip_order = (remark == 'å¼€é€š')
                        # å¦‚æœæ²¡æœ‰å¤‡æ³¨ä½†é‡‘é¢è¶³å¤ŸVIPä»·æ ¼ï¼Œä¹Ÿå¯ä»¥è§†ä¸ºVIPè®¢å•
                        if not is_vip_order:
                            config = get_system_config()
                            if amount >= float(config.get('vip_price', 10)):
                                is_vip_order = True

                        if hasattr(bot_logic, 'process_recharge_queue'):
                            bot_logic.process_recharge_queue.append({
                                'member_id': member_id,
                                'amount': amount,
                                'is_vip_order': is_vip_order
                            })
                    except Exception as e:
                        print(f'[æ”¯ä»˜å›è°ƒ] æ¨é€Boté˜Ÿåˆ—å¤±è´¥: {e}')
            else:
                print(f'[æ”¯ä»˜å›è°ƒ] æœªæ‰¾åˆ°è®¢å•: {out_trade_no}')

                conn.close()
                return 'success'
        
        return 'success' # å³ä½¿çŠ¶æ€ä¸æ˜¯4ï¼Œä¹Ÿè¿”å›successå‘ŠçŸ¥ç½‘å…³å·²æ”¶åˆ°

    except Exception as e:
        print(f'[æ”¯ä»˜å›è°ƒ] å¼‚å¸¸: {e}')
        import traceback
        traceback.print_exc()
        return 'fail'

@app.route('/payment/success')
def payment_success():
    return '<html><head><meta charset=utf-8><title>æ”¯ä»˜æˆåŠŸ</title></head><body style=text-align:center;padding:50px><h1>æ”¯ä»˜æˆåŠŸ</h1><p>å……å€¼è®¢å•å·²æäº¤</p></body></html>'

# ==================== å†…éƒ¨API ====================

@app.route('/internal/notify', methods=['POST'])
def internal_notify():
    """å†…éƒ¨APIï¼šå‘é€é€šçŸ¥ç»™ç”¨æˆ·"""
    try:
        data = request.json
        member_id = data['member_id']
        message = data['message']
        notify_queue.append({'member_id': member_id, 'message': message})
        print(f"âœ… é€šçŸ¥å·²åŠ å…¥é˜Ÿåˆ—: ç”¨æˆ·{member_id}")
        return jsonify({'success': True})
    except Exception as e:
        print(f"å†…éƒ¨APIå¤±è´¥: {e}")
        return jsonify({'success': False, 'error': str(e)})

# ==================== å…³é”®APIè·¯ç”± =====================

@app.route('/api/members')
@login_required
def api_members():
    """è·å–ä¼šå‘˜åˆ—è¡¨API"""
    page = request.args.get('page', 1, type=int)
    per_page = request.args.get('per_page', 20, type=int)
    search = request.args.get('search', '', type=str)
    filter_type = request.args.get('filter', 'all', type=str)
    
    # ä½¿ç”¨WebDBçš„å®Œæ•´æ–¹æ³•ï¼ˆéœ€è¦ä»main.pyè¿ç§»å®Œæ•´å®ç°ï¼‰
    # è¿™é‡Œç®€åŒ–å¤„ç†ï¼Œå®é™…åº”è¯¥è°ƒç”¨å®Œæ•´çš„ get_all_members
    data = WebDB.get_all_members(page, per_page, search, filter_type)
    return jsonify(data)

@app.route('/api/member/<int:telegram_id>')
@login_required
def api_member_detail(telegram_id):
    """è·å–ä¼šå‘˜è¯¦æƒ…API"""
    member = WebDB.get_member_detail(telegram_id)
    if member:
        # è¿”å›ä¸å‰ç«¯æœŸæœ›ä¸€è‡´çš„çº¯ member å¯¹è±¡ï¼ˆå…¼å®¹æ—§å‰ç«¯ï¼‰
        return jsonify(member)
    return jsonify({'error': 'ä¼šå‘˜ä¸å­˜åœ¨'}), 404

@app.route('/api/member/<int:telegram_id>', methods=['PUT'])
@login_required
def api_update_member(telegram_id):
    """æ›´æ–°ä¼šå‘˜ä¿¡æ¯API"""
    data = request.json
    WebDB.update_member(telegram_id, data)
    return jsonify({'success': True, 'message': 'æ›´æ–°æˆåŠŸ'})

@app.route('/api/member/<int:telegram_id>', methods=['DELETE'])
@login_required
def api_delete_member(telegram_id):
    """åˆ é™¤ä¼šå‘˜API"""
    WebDB.delete_member(telegram_id)
    return jsonify({'success': True, 'message': 'åˆ é™¤æˆåŠŸ'})

@app.route('/api/member/add', methods=['POST'])
@login_required
def api_add_member():
    """æ·»åŠ ä¼šå‘˜API"""
    try:
        data = request.json
        telegram_id = data.get('telegram_id')
        username = data.get('username', '')
        referrer_id = data.get('referrer_id')
        
        if not telegram_id:
            return jsonify({'success': False, 'message': 'telegram_idä¸èƒ½ä¸ºç©º'}), 400
        
        # æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨
        existing = DB.get_member(telegram_id)
        if existing:
            return jsonify({'success': False, 'message': 'ä¼šå‘˜å·²å­˜åœ¨'}), 400
        
        # åˆ›å»ºä¼šå‘˜
        DB.create_member(telegram_id, username, referrer_id)
        return jsonify({'success': True, 'message': 'æ·»åŠ æˆåŠŸ'})
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500

@app.route('/api/member-groups/<int:group_id>/broadcasts', methods=['GET'])
@login_required
def api_get_group_broadcasts(group_id):
    """è·å–æŸä¸ªç¾¤å¯ç”¨çš„ç¾¤å‘åˆ—è¡¨ä»¥åŠè¯¥ç¾¤å·²åˆ†é…çš„æ¡ç›®çŠ¶æ€"""
    try:
        conn = get_db_conn()
        c = conn.cursor()
        # è·å–æ‰€æœ‰ç¾¤å‘æ¶ˆæ¯
        c.execute("""SELECT id, title, content, image_url, video_url, buttons, buttons_per_row, broadcast_interval, is_active, create_time
                     FROM broadcast_messages WHERE is_active = 1 ORDER BY id ASC""")
        msgs = c.fetchall()

        # è·å–è¯¥ç¾¤çš„åˆ†é…è®°å½•
        c.execute("SELECT message_id, is_active, last_sent_time FROM broadcast_assignments WHERE group_id = ?", (group_id,))
        assigns = {r[0]: {'is_active': r[1], 'last_sent_time': r[2]} for r in c.fetchall()}
        conn.close()

        messages = []
        for row in msgs:
            mid = row[0]
            messages.append({
                'id': mid,
                'title': row[1],
                'content': row[2],
                'image_url': row[3] or '',
                'video_url': row[4] or '',
                'buttons': row[5] or '[]',
                'buttons_per_row': row[6] or 2,
                'broadcast_interval': row[7] or 120,
                'is_active': row[8],
                'create_time': row[9] or '',
                'assigned': mid in assigns,
                'assignment': assigns.get(mid)
            })

        return jsonify({'success': True, 'messages': messages})
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500


@app.route('/api/member-groups/<int:group_id>/broadcasts', methods=['POST'])
@login_required
def api_assign_broadcast_to_group(group_id):
    """ä¸ºæŸä¸ªç¾¤åˆ†é…ä¸€æ¡ç¾¤å‘æ¶ˆæ¯ï¼ˆæˆ–æ›´æ–°æ¿€æ´»çŠ¶æ€ï¼‰"""
    try:
        data = request.get_json() or {}
        message_id = int(data.get('message_id') or 0)
        is_active = 1 if data.get('is_active') else 0
        if not message_id:
            return jsonify({'success': False, 'message': 'message_id å¿…å¡«'}), 400

        conn = get_db_conn()
        c = conn.cursor()
        # æ£€æŸ¥ç¾¤æ˜¯å¦å­˜åœ¨
        c.execute('SELECT id, group_link FROM member_groups WHERE id = ?', (group_id,))
        g = c.fetchone()
        if not g:
            conn.close()
            return jsonify({'success': False, 'message': 'ç¾¤ç»„ä¸å­˜åœ¨'}), 404

        # æ’å…¥æˆ–æ›´æ–° assignment
        c.execute('SELECT id FROM broadcast_assignments WHERE group_id = ? AND message_id = ?', (group_id, message_id))
        row = c.fetchone()
        now = get_cn_time()
        if row:
            c.execute('UPDATE broadcast_assignments SET is_active = ?, create_time = ? WHERE id = ?', (is_active, now, row[0]))
        else:
            c.execute('INSERT INTO broadcast_assignments (group_id, message_id, is_active, create_time) VALUES (?, ?, ?, ?)',
                (group_id, message_id, is_active, now))
        conn.commit()
        conn.close()
        return jsonify({'success': True, 'message': 'åˆ†é…å·²ä¿å­˜'})
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500


@app.route('/api/member-groups/<int:group_id>/broadcasts/<int:message_id>', methods=['DELETE'])
@login_required
def api_unassign_broadcast_from_group(group_id, message_id):
    """å–æ¶ˆæŸæ¡æ¶ˆæ¯å¯¹æŸç¾¤çš„åˆ†é…"""
    try:
        conn = get_db_conn()
        c = conn.cursor()
        c.execute('DELETE FROM broadcast_assignments WHERE group_id = ? AND message_id = ?', (group_id, message_id))
        conn.commit()
        conn.close()
        return jsonify({'success': True, 'message': 'å·²å–æ¶ˆåˆ†é…'})
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500


@app.route('/api/member-groups/<int:group_id>/broadcast/send', methods=['POST'])
@login_required
def api_group_send_broadcasts(group_id):
    """ç«‹å³å‘æŸä¸ªç¾¤å‘é€é€‰ä¸­çš„ç¾¤å‘å†…å®¹ï¼›å¦‚æœæœªæŒ‡å®š message_idsï¼Œåˆ™å‘é€è¯¥ç¾¤å·²åˆ†é…ä¸”å¯ç”¨çš„æ‰€æœ‰æ¶ˆæ¯"""
    try:
        data = request.get_json() or {}
        message_ids = data.get('message_ids') or []

        conn = get_db_conn()
        c = conn.cursor()
        c.execute('SELECT group_link, group_name FROM member_groups WHERE id = ?', (group_id,))
        g = c.fetchone()
        if not g:
            conn.close()
            return jsonify({'success': False, 'message': 'ç¾¤ç»„ä¸å­˜åœ¨'}), 404
        group_link, group_name = g[0], g[1]

        if not message_ids:
            # å–è¯¥ç¾¤å·²åˆ†é…ä¸”å¯ç”¨çš„æ¶ˆæ¯
            c.execute('SELECT message_id FROM broadcast_assignments WHERE group_id = ? AND is_active = 1 ORDER BY id ASC', (group_id,))
            message_ids = [r[0] for r in c.fetchall()]

        if not message_ids:
            conn.close()
            return jsonify({'success': False, 'message': 'æ²¡æœ‰å¯å‘é€çš„ç¾¤å‘å†…å®¹'}), 400

        # è·å–å¾…å‘é€æ¶ˆæ¯å†…å®¹å¹¶å†™å…¥ broadcast_queue
        placeholders = ','.join(['?' for _ in message_ids])
        c.execute(f'SELECT id, title, content, image_url, video_url, buttons FROM broadcast_messages WHERE id IN ({placeholders}) ORDER BY id ASC', message_ids)
        rows = c.fetchall()
        now = get_cn_time()
        for row in rows:
            # build a JSON payload containing content and media
            msg_obj = {
                'content': row[2] or '',
                'image_url': row[3] or '',
                'video_url': row[4] or '',
                'buttons': row[5] or '',
            }
            import json
            msg_json = json.dumps(msg_obj, ensure_ascii=False)
            # å†™å…¥é˜Ÿåˆ—ï¼›Bot çº¿ç¨‹ä¼šè§£æ JSON å¹¶å‘é€åª’ä½“/æŒ‰é’®ç­‰
            c.execute('INSERT INTO broadcast_queue (group_link, group_name, message, status, create_time) VALUES (?, ?, ?, ?, ?)',
                      (group_link, group_name, msg_json, 'pending', now))

        conn.commit()
        conn.close()
        return jsonify({'success': True, 'message': f'å·²å°† {len(rows)} æ¡æ¶ˆæ¯åŠ å…¥ç¾¤ {group_name} çš„å‘é€é˜Ÿåˆ—'})
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500

@app.route('/api/member/<int:telegram_id>/graph')
@login_required
def api_member_graph(telegram_id):
    """è·å–ä¼šå‘˜å…³ç³»å›¾è°± (ä¿®å¤ç‰ˆï¼šç¡®ä¿è¿”å›å®Œæ•´ç»“æ„)"""
    try:
        conn = get_db_conn()
        c = conn.cursor()

        # 1. è·å–å½“å‰ä¼šå‘˜
        c.execute("""SELECT telegram_id, username, balance, is_vip, referrer_id,
                is_group_bound, is_bot_admin, is_joined_upline, direct_count, team_count, total_earned
            FROM members WHERE telegram_id = ?""", (telegram_id,))
        row = c.fetchone()

        # å³ä½¿æ‰¾ä¸åˆ°ä¼šå‘˜ï¼Œä¹Ÿä¸è¦è¿”å› 404 å¯¼è‡´å‰ç«¯å´©æºƒï¼Œè€Œæ˜¯è¿”å›ä¸€ä¸ªç©ºçš„å ä½å¯¹è±¡
        if not row:
            center = {
                'telegram_id': telegram_id, 'username': 'æœªçŸ¥/ä¸å­˜åœ¨', 'balance': 0,
                'is_vip': 0, 'referrer_id': None, 'is_group_bound': 0,
                'is_bot_admin': 0, 'is_joined_upline': 0,
                'direct_count': 0, 'team_count': 0, 'total_earned': 0
            }
        else:
            center = {
                'telegram_id': row[0], 'username': row[1] or 'æœªè®¾ç½®', 'balance': row[2] or 0,
                'is_vip': row[3], 'referrer_id': row[4], 'is_group_bound': row[5],
                'is_bot_admin': row[6], 'is_joined_upline': row[7],
                'direct_count': row[8] or 0, 'team_count': row[9] or 0, 'total_earned': row[10] or 0
            }
    
        # 2. è·å–ä¸Šçº§é“¾ï¼ˆå‘ä¸Š10å±‚ï¼‰
        uplines = []
        current_ref = center['referrer_id']
        level = 1

        # é˜²æ­¢æ­»å¾ªç¯
        seen_ids = {telegram_id}

        while current_ref and level <= 10:
            if current_ref in seen_ids: break
            seen_ids.add(current_ref)

            c.execute("""SELECT telegram_id, username, is_vip, referrer_id,
                    is_group_bound, is_bot_admin, is_joined_upline
                FROM members WHERE telegram_id = ?""", (current_ref,))
            ref_row = c.fetchone()

            if not ref_row:
                # å¯èƒ½æ˜¯æ¡æ¼è´¦å·æˆ–è€…æ•°æ®ä¸ä¸€è‡´ï¼Œæ·»åŠ ä¸€ä¸ªå ä½ç¬¦
                uplines.append({
                    'telegram_id': current_ref, 'username': 'æœªçŸ¥/ç³»ç»Ÿå·', 'is_vip': 1,
                    'level': level, 'is_group_bound': 1, 'is_bot_admin': 1, 'is_joined_upline': 1,
                    'direct_count': 0, 'team_count': 0
                })
                break

            # å®æ—¶è®¡ç®—è¯¥ç”¨æˆ·çš„ç›´æ¨å’Œå›¢é˜Ÿæ•°é‡
            downline_counts = DB.get_downline_count(ref_row[0], 10)
            direct_count = downline_counts[0]['total'] if downline_counts and len(downline_counts) > 0 else 0
            team_count = sum(item.get('total', 0) for item in downline_counts) if downline_counts else 0

            uplines.append({
                'telegram_id': ref_row[0], 'username': ref_row[1] or 'æœªè®¾ç½®', 'is_vip': ref_row[2],
                'level': level, 'is_group_bound': ref_row[4], 'is_bot_admin': ref_row[5],
                'is_joined_upline': ref_row[6], 'direct_count': direct_count, 'team_count': team_count
            })
            current_ref = ref_row[3]
            level += 1
    
        # 3. è·å–ä¸‹çº§ï¼ˆå‘ä¸‹10å±‚ï¼‰
        downlines = []
        def get_downline_recursive(parent_id, current_level=1, max_level=10):
            if current_level > max_level: return

            c.execute("""SELECT telegram_id, username, is_vip, referrer_id,
                    is_group_bound, is_bot_admin, is_joined_upline
                FROM members WHERE referrer_id = ? LIMIT 50""", (parent_id,))  # é™åˆ¶æ•°é‡é˜²æ­¢è¿‡å¤§

            rows = c.fetchall()
            for row in rows:
                # å®æ—¶è®¡ç®—è¯¥ç”¨æˆ·çš„ç›´æ¨å’Œå›¢é˜Ÿæ•°é‡
                downline_counts = DB.get_downline_count(row[0], 10)  # è·å–10å±‚æ•°æ®
                direct_count = downline_counts[0]['total'] if downline_counts and len(downline_counts) > 0 else 0
                team_count = sum(item.get('total', 0) for item in downline_counts) if downline_counts else 0

                downlines.append({
                    'telegram_id': row[0], 'username': row[1] or 'æœªè®¾ç½®', 'is_vip': row[2],
                    'level': current_level, 'is_group_bound': row[4], 'is_bot_admin': row[5],
                    'is_joined_upline': row[6], 'direct_count': direct_count, 'team_count': team_count
                })
                # é€’å½’
                get_downline_recursive(row[0], current_level + 1, max_level)

        get_downline_recursive(telegram_id)

        conn.close()
        return jsonify({
            'success': True,
            'center': center,
            'uplines': uplines,
            'downlines': downlines
        })
    except Exception as e:
        print(f"[Graph Error] {e}")
        import traceback
        traceback.print_exc()
        # è¿”å›ä¸€ä¸ªç©ºç»“æ„é˜²æ­¢å‰ç«¯æŠ¥é”™
        return jsonify({
            'success': False,
            'error': str(e),
            'center': {'telegram_id': telegram_id, 'username': 'Error'},
            'uplines': [],
            'downlines': []
        })

@app.route('/api/statistics')
@login_required
def api_statistics():
    """è·å–ç»Ÿè®¡æ•°æ®API"""
    stats = WebDB.get_statistics()
    return jsonify(stats)

@app.route('/api/statistics/chart')
@login_required
def api_chart_data():
    """è·å–å›¾è¡¨æ•°æ®API"""
    chart_data = WebDB.get_chart_data()
    return jsonify(chart_data)

@app.route('/api/dashboard/stats')
@login_required
def api_dashboard_stats():
    """è·å–ä»ªè¡¨ç›˜ç»Ÿè®¡æ•°æ®"""
    try:
        from datetime import datetime, timedelta
        conn = get_db_conn()
        c = conn.cursor()
        
        today = datetime.now().strftime('%Y-%m-%d')
        yesterday = (datetime.now() - timedelta(days=1)).strftime('%Y-%m-%d')
        month_start = datetime.now().strftime('%Y-%m-01')
        
        c.execute('SELECT COUNT(*) FROM members')
        total_members = c.fetchone()[0]
        
        c.execute('SELECT COUNT(*) FROM members WHERE is_vip = 1')
        vip_members = c.fetchone()[0]
        
        c.execute('SELECT COUNT(*) FROM members WHERE DATE(register_time) = ?', (today,))
        today_register = c.fetchone()[0]
        
        c.execute('SELECT COUNT(*) FROM members WHERE DATE(register_time) = ?', (yesterday,))
        yesterday_register = c.fetchone()[0]
        
        c.execute('SELECT COUNT(*) FROM members WHERE DATE(register_time) >= ?', (month_start,))
        month_register = c.fetchone()[0]
        
        c.execute('SELECT COUNT(*) FROM members WHERE is_vip = 1 AND DATE(vip_time) = ?', (today,))
        today_vip = c.fetchone()[0]
        
        c.execute('SELECT COUNT(*) FROM members WHERE is_vip = 1 AND DATE(vip_time) = ?', (yesterday,))
        yesterday_vip = c.fetchone()[0]
        
        c.execute('SELECT COUNT(*) FROM members WHERE is_vip = 1 AND DATE(vip_time) >= ?', (month_start,))
        month_vip = c.fetchone()[0]
        
        c.execute("SELECT telegram_id, username, total_earned FROM fallback_accounts ORDER BY total_earned DESC LIMIT 10")
        fallback_rows = c.fetchall()
        
        fallback_accounts = []
        total_income = 0
        
        for row in fallback_rows:
            total_income += row[2] or 0
            fallback_accounts.append({
                "telegram_id": row[0],
                "username": row[1],
                "balance": row[2] or 0,
                "total_earned": row[2] or 0,
                "is_vip": 1
            })
        
        today_income = total_income
        yesterday_income = 0
        month_income = total_income
        
        trend_labels = []
        trend_register = []
        trend_vip = []
        for i in range(6, -1, -1):
            date = (datetime.now() - timedelta(days=i)).strftime('%Y-%m-%d')
            trend_labels.append((datetime.now() - timedelta(days=i)).strftime('%m-%d'))
            
            c.execute('SELECT COUNT(*) FROM members WHERE DATE(register_time) = ?', (date,))
            trend_register.append(c.fetchone()[0])
            
            c.execute('SELECT COUNT(*) FROM members WHERE is_vip = 1 AND DATE(vip_time) = ?', (date,))
            trend_vip.append(c.fetchone()[0])
        
        conn.close()
        
        return jsonify({
            'success': True,
            'data': {
                'total_members': total_members,
                'vip_members': vip_members,
                'today_register': today_register,
                'yesterday_register': yesterday_register,
                'month_register': month_register,
                'today_vip': today_vip,
                'yesterday_vip': yesterday_vip,
                'month_vip': month_vip,
                'today_income': round(today_income, 2),
                'yesterday_income': round(yesterday_income, 2),
                'month_income': round(month_income, 2),
                'total_income': round(total_income, 2),
                'fallback_accounts': fallback_accounts,
                'trend_data': {
                    'labels': trend_labels,
                    'register_counts': trend_register,
                    'vip_counts': trend_vip
                }
            }
        })
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500

@app.route('/api/member-groups')
@login_required
def api_get_member_groups():
    """è·å–ä¼šå‘˜ç¾¤åˆ—è¡¨"""
    try:
        search = request.args.get('search', '').strip()
        conn = get_db_conn()
        c = conn.cursor()
        
        if search:
            c.execute('''
                SELECT 
                    mg.id, mg.telegram_id, mg.group_id, mg.group_name,
                    mg.group_link, mg.member_count, mg.bot_id, mg.is_bot_admin,
                    mg.create_time, m.username
                FROM member_groups mg
                LEFT JOIN members m ON mg.telegram_id = m.telegram_id
                WHERE mg.group_name LIKE ? OR mg.group_link LIKE ? OR m.username LIKE ?
                ORDER BY mg.id DESC
            ''', (f'%{search}%', f'%{search}%', f'%{search}%'))
        else:
            c.execute('''
                SELECT 
                    mg.id, mg.telegram_id, mg.group_id, mg.group_name,
                    mg.group_link, mg.member_count, mg.bot_id, mg.is_bot_admin,
                    mg.create_time, m.username
                FROM member_groups mg
                LEFT JOIN members m ON mg.telegram_id = m.telegram_id
                ORDER BY mg.id DESC
            ''')
        
        rows = c.fetchall()
        groups = []
        for row in rows:
            groups.append({
                'id': row[0],
                'telegram_id': row[1],
                'group_id': row[2],
                'group_name': row[3] or '',
                'group_link': row[4] or '',
                'member_count': row[5] or 0,
                'bot_id': row[6],
                'is_bot_admin': row[7],
                'create_time': row[8][:19] if row[8] else '',
                'owner_username': row[9] or ''
            })
        
        conn.close()
        return jsonify({'success': True, 'groups': groups})
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500


@app.route('/api/member-groups/<int:id>', methods=['PUT'])
@login_required
def api_update_member_group(id):
    """æ›´æ–°ä¼šå‘˜ç¾¤ç»„ä¿¡æ¯"""
    try:
        data = request.json or {}
        group_name = data.get('group_name')
        group_link = data.get('group_link')

        conn = get_db_conn()
        c = conn.cursor()

        updates = []
        params = []
        if group_name is not None:
            updates.append("group_name = ?")
            params.append(group_name)
        if group_link is not None:
            updates.append("group_link = ?")
            params.append(group_link)

        if not updates:
            conn.close()
            return jsonify({'success': False, 'message': 'æ²¡æœ‰è¦æ›´æ–°çš„å†…å®¹'})

        params.append(id)
        c.execute(f"UPDATE member_groups SET {', '.join(updates)} WHERE id = ?", params)
        conn.commit()
        conn.close()

        return jsonify({'success': True, 'message': 'æ›´æ–°æˆåŠŸ'})
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500


@app.route('/api/member-groups/<int:id>/verify', methods=['POST'])
@login_required
def api_verify_member_group(id):
    """éªŒè¯ç¾¤ç»„çŠ¶æ€ (è§¦å‘Botæ£€æµ‹)"""
    try:
        conn = get_db_conn()
        c = conn.cursor()
        c.execute("SELECT group_link FROM member_groups WHERE id = ?", (id,))
        row = c.fetchone()
        conn.close()

        if not row or not row[0]:
            return jsonify({'success': False, 'message': 'ç¾¤ç»„ä¸å­˜åœ¨æˆ–æ— é“¾æ¥'}), 404

        group_link = row[0]

        # å°è¯•è°ƒç”¨ Bot éªŒè¯ (è¿™æ˜¯ä¸€ä¸ªå¼‚æ­¥æ“ä½œï¼ŒWebç«¯åªèƒ½è¿”å›å·²æäº¤)
        # è¿™é‡Œç®€å•è¿”å›æˆåŠŸï¼Œå®é™…éªŒè¯ä¾èµ–åå° check_member_status_task ä»»åŠ¡
        # æˆ–è€…å¯ä»¥æ‰‹åŠ¨è§¦å‘ä¸€æ¬¡æ£€æµ‹é€»è¾‘

        return jsonify({
            'success': True,
            'message': 'éªŒè¯è¯·æ±‚å·²æäº¤ï¼Œè¯·ç¨ååˆ·æ–°æŸ¥çœ‹çŠ¶æ€ (ç³»ç»Ÿåå°ä¼šè‡ªåŠ¨å®šæ—¶æ£€æµ‹)'
        })
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500

@app.route('/api/member-groups/broadcast', methods=['POST'])
@login_required
def api_broadcast_to_groups():
    """å‘é€‰ä¸­çš„ä¼šå‘˜ç¾¤ç»„å‘é€å¹¿æ’­æ¶ˆæ¯"""
    try:
        data = request.get_json() or {}
        group_ids = data.get('group_ids', [])
        message = (data.get('message', '')).strip()

        if not message:
            return jsonify({'success': False, 'message': 'æ¶ˆæ¯å†…å®¹ä¸èƒ½ä¸ºç©º'}), 400

        if not group_ids:
            return jsonify({'success': False, 'message': 'è¯·é€‰æ‹©è¦å‘é€çš„ç¾¤ç»„'}), 400

        conn = get_db_conn()
        c = conn.cursor()

        # è·å–é€‰ä¸­çš„ç¾¤ç»„ä¿¡æ¯
        placeholders = ','.join(['?' for _ in group_ids])
        c.execute(f'SELECT id, group_link, group_name FROM member_groups WHERE id IN ({placeholders})', group_ids)
        groups = c.fetchall()
        conn.close()

        if not groups:
            return jsonify({'success': False, 'message': 'æœªæ‰¾åˆ°å¯¹åº”çš„ç¾¤ç»„'}), 404

        # ã€ä¿®å¤ç‚¹ã€‘æ­£ç¡®å¼•ç”¨ bot_logic ä¸­çš„å˜é‡
        import bot_logic
        # ç¡®ä¿åˆ—è¡¨å­˜åœ¨
        if not hasattr(bot_logic, 'pending_broadcasts'):
            bot_logic.pending_broadcasts = []

        sent_count = 0
        for group in groups:
            group_link = group[1]
            if group_link and 't.me/' in group_link:
                try:
                    # ç›´æ¥è¿½åŠ åˆ° bot_logic æ¨¡å—çš„åˆ—è¡¨ä¸­
                    bot_logic.pending_broadcasts.append({
                        'type': 'broadcast',
                        'group_links': [group_link],
                        'message_content': message
                    })
                    sent_count += 1
                except Exception as e:
                    print(f'[ç¾¤å‘API] æ·»åŠ ç¾¤ç»„ {group[0]} å¤±è´¥: {e}')
                    continue

        if sent_count == 0:
            return jsonify({'success': False, 'message': 'æ²¡æœ‰æœ‰æ•ˆçš„ç¾¤ç»„é“¾æ¥å¯ä»¥å‘é€'}), 400

        return jsonify({
            'success': True,
            'sent_count': sent_count,
            'message': f'å·²å°†ç¾¤å‘ä»»åŠ¡æ·»åŠ åˆ°é˜Ÿåˆ—ï¼Œå°†å‘é€åˆ° {sent_count} ä¸ªç¾¤ç»„'
        })

    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500

@app.route('/api/fallback-accounts', methods=['GET', 'POST'])
@login_required
def api_fallback_accounts():
    """è·å–æ¡æ¼è´¦å·åˆ—è¡¨æˆ–æ·»åŠ æ–°è´¦å·"""
    try:
        conn = get_db_conn()
        c = conn.cursor()

        if request.method == 'GET':
            # è·å–æ¡æ¼è´¦å·åˆ—è¡¨
            c.execute('''
                SELECT fa.id, fa.telegram_id, fa.username, fa.group_link, fa.total_earned, fa.is_active,
                       m.is_vip, m.balance
                FROM fallback_accounts fa
                LEFT JOIN members m ON fa.telegram_id = m.telegram_id
                ORDER BY fa.id ASC
            ''')
            accounts = []
            for row in c.fetchall():
                telegram_id = row[1]
                # é‡æ–°è®¡ç®—ï¼šç»Ÿè®¡ earnings_records ä¸­ï¼Œç»™è¯¥æ¡æ¼è´¦å·çš„æ‰€æœ‰å«"æ¡æ¼"è¯´æ˜çš„æ”¶ç›Š
                c2 = conn.cursor()
                c2.execute('''
                    SELECT COALESCE(SUM(amount), 0)
                    FROM earnings_records
                    WHERE earning_user = ? AND description LIKE '%æ¡æ¼%'
                ''', (telegram_id,))
                calculated_total = c2.fetchone()[0] or 0

                stored_total = row[4] or 0
                if abs(calculated_total - stored_total) > 0.01:
                    c.execute('UPDATE fallback_accounts SET total_earned = ? WHERE telegram_id = ?',
                             (calculated_total, telegram_id))
                    conn.commit()
                    stored_total = calculated_total

                accounts.append({
                    'id': row[0],
                    'telegram_id': telegram_id,
                    'username': row[2] or str(telegram_id),
                    'group_link': row[3] or '',
                    'total_earned': stored_total,
                    'is_active': row[5] if row[5] is not None else 1,
                    'is_vip': row[6] if row[6] is not None else 0,
                    'balance': row[7] if row[7] is not None else 0
                })
            conn.close()
            return jsonify({'success': True, 'accounts': accounts})

        elif request.method == 'POST':
            # æ·»åŠ æ–°æ¡æ¼è´¦å·
            data = request.json or {}
            username = data.get('username', '').strip()
            group_link = data.get('group_link', '').strip()

            if not username:
                conn.close()
                return jsonify({'success': False, 'message': 'è¯·è¾“å…¥Telegramç”¨æˆ·å'}), 400

            # å¤„ç†ç”¨æˆ·åæ ¼å¼
            if username.startswith('@'):
                username = username[1:]

            # å°è¯•è§£ætelegram_idï¼ˆå¦‚æœæ˜¯æ•°å­—ï¼‰
            telegram_id = None
            if username.isdigit():
                telegram_id = int(username)
            # å¦‚æœä¸æ˜¯æ•°å­—ï¼Œå°±å½“ä½œç”¨æˆ·åå¤„ç†ï¼Œtelegram_idè®¾ä¸ºNone

            # æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨ï¼ˆé€šè¿‡ç”¨æˆ·åæˆ–telegram_idï¼‰
            if telegram_id:
                c.execute('SELECT id FROM fallback_accounts WHERE telegram_id = ? OR username = ?', (telegram_id, username))
            else:
                c.execute('SELECT id FROM fallback_accounts WHERE username = ?', (username,))

            if c.fetchone():
                conn.close()
                return jsonify({'success': False, 'message': 'è¯¥è´¦å·å·²å­˜åœ¨'}), 400

            # å¦‚æœæœ‰telegram_idï¼Œæ£€æŸ¥æ˜¯å¦å­˜åœ¨å¯¹åº”çš„membersè®°å½•
            if telegram_id:
                c.execute('SELECT telegram_id FROM members WHERE telegram_id = ?', (telegram_id,))
                member_exists = c.fetchone() is not None

                if not member_exists:
                    # å¦‚æœmembersè¡¨ä¸­æ²¡æœ‰ï¼Œå…ˆåˆ›å»ºmembersè®°å½•
                    c.execute('''
                        INSERT INTO members (telegram_id, username, register_time)
                        VALUES (?, ?, ?)
                    ''', (telegram_id, username, get_cn_time()))

            # æ·»åŠ åˆ°fallback_accounts
            c.execute('''
                INSERT INTO fallback_accounts (telegram_id, username, group_link, is_active, main_account_id)
                VALUES (?, ?, ?, 1, ?)
            ''', (telegram_id, username, group_link if group_link else None, telegram_id))

            conn.commit()
            conn.close()

            return jsonify({'success': True, 'message': 'æ¡æ¼è´¦å·æ·»åŠ æˆåŠŸ'})

    except Exception as e:
        try:
            conn.close()
        except:
            pass
        return jsonify({'success': False, 'message': str(e)}), 500

@app.route('/api/earnings')
@login_required
def api_get_earnings():
    """è·å–æ”¶ç›Šè®°å½•åˆ—è¡¨"""
    try:
        page = request.args.get('page', 1, type=int)
        per_page = request.args.get('per_page', 20, type=int)
        search = request.args.get('search', '').strip()
        
        conn = get_db_conn()
        c = conn.cursor()
        offset = (page - 1) * per_page
        
        where_clause = ''
        params = []
        
        if search:
            if search.isdigit():
                where_clause = 'WHERE er.earning_user = ?'
                params = [int(search)]
            else:
                where_clause = 'WHERE (m.username LIKE ? OR fa.username LIKE ?)'
                params = [f'%{search}%', f'%{search}%']
        
        count_query = f'''
            SELECT COUNT(*) FROM earnings_records er
            LEFT JOIN members m ON er.earning_user = m.telegram_id
            LEFT JOIN fallback_accounts fa ON er.earning_user = fa.telegram_id
            {where_clause}
        '''
        c.execute(count_query, params)
        total = c.fetchone()[0]
        
        query = f'''
            SELECT er.id, er.earning_user as member_id,
                   COALESCE(m.username, fa.username, '') as username,
                   er.amount, er.upgraded_user, er.description, er.create_time
            FROM earnings_records er
            LEFT JOIN members m ON er.earning_user = m.telegram_id
            LEFT JOIN fallback_accounts fa ON er.earning_user = fa.telegram_id
            {where_clause}
            ORDER BY er.create_time DESC
            LIMIT ? OFFSET ?
        '''
        c.execute(query, params + [per_page, offset])
        
        records = []
        for row in c.fetchall():
            member_id = row[1]
            username = row[2] or ''
            upgraded_user_id = row[4] if len(row) > 4 else None
            
            if member_id and not username:
                c2 = conn.cursor()
                c2.execute('SELECT username, telegram_id FROM fallback_accounts WHERE telegram_id = ?', (member_id,))
                fb_row = c2.fetchone()
                if fb_row:
                    username = fb_row[0] or ''
                    if not username:
                        username = str(fb_row[1]) if fb_row[1] else str(member_id)
                else:
                    c2.execute('SELECT username FROM members WHERE telegram_id = ?', (member_id,))
                    m_row = c2.fetchone()
                    if m_row and m_row[0]:
                        username = m_row[0]
                    else:
                        username = str(member_id)
            # ç›´æ¥è¯»å–æ•°æ®åº“ä¸­çš„ description
            detailed_description = row[5] or ''

            # å¦‚æœæ˜¯æ—§æ•°æ®ï¼ˆæ²¡æœ‰è¯¦ç»†è¯´æ˜ï¼‰ï¼Œå¯ä»¥ä¿ç•™ä¸€ç‚¹ç®€å•çš„å…¼å®¹é€»è¾‘ï¼Œæˆ–è€…ç›´æ¥æ˜¾ç¤º
            if not detailed_description:
                detailed_description = "æ”¶ç›Šè®°å½•"

            try:
                if upgraded_user_id:
                    upm = DB.get_member(upgraded_user_id)
                    upgraded_name = f"@{upm['username']}" if upm and upm.get('username') else str(upgraded_user_id)
                else:
                    upgraded_name = '-'
            except:
                upgraded_name = str(upgraded_user_id) if upgraded_user_id else '-'
            
            records.append({
                'id': row[0],
                'member_id': member_id if member_id is not None else 0,
                'username': username or (str(member_id) if member_id else 'N/A'),
                'amount': row[3],
                'upgraded_user_id': upgraded_user_id or 0,
                'upgraded_user_name': upgraded_name,
                'description': detailed_description,  # ä½¿ç”¨è¯¦ç»†è¯´æ˜
                'create_time': row[6][:19] if row[6] else ''
            })
        
        conn.close()
        
        return jsonify({
            'success': True,
            'records': records,
            'total': total,
            'page': page,
            'pages': (total + per_page - 1) // per_page if total > 0 else 1,
            'per_page': per_page
        })
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500

@app.route('/api/resource_categories')
@login_required
def api_get_resource_categories():
    """è·å–èµ„æºåˆ†ç±»åˆ—è¡¨"""
    try:
        categories = DB.get_resource_categories(0)
        return jsonify({'success': True, 'categories': categories})
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500


@app.route('/api/resource_categories/<int:id>')
@login_required
def api_get_resource_category(id):
    """è·å–å•ä¸ªèµ„æºåˆ†ç±»"""
    try:
        conn = get_db_conn()
        c = conn.cursor()
        c.execute('SELECT id, name, parent_id FROM resource_categories WHERE id = ?', (id,))
        row = c.fetchone()
        conn.close()
        if row:
            return jsonify({'id': row[0], 'name': row[1], 'parent_id': row[2]})
        return jsonify({'success': False, 'message': 'åˆ†ç±»ä¸å­˜åœ¨'}), 404
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500


@app.route('/api/resource_categories', methods=['POST'])
@login_required
def api_create_resource_category():
    """åˆ›å»ºèµ„æºåˆ†ç±»"""
    try:
        data = request.json or {}
        name = (data.get('name') or '').strip()
        parent_id = int(data.get('parent_id', 0) or 0)
        if not name:
            return jsonify({'success': False, 'message': 'åˆ†ç±»åç§°ä¸èƒ½ä¸ºç©º'}), 400
        conn = get_db_conn()
        c = conn.cursor()
        c.execute('INSERT INTO resource_categories (name, parent_id) VALUES (?, ?)', (name, parent_id))
        conn.commit()
        conn.close()
        return jsonify({'success': True, 'message': 'åˆ›å»ºæˆåŠŸ'})
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500


@app.route('/api/resource_categories/<int:id>', methods=['PUT'])
@login_required
def api_update_resource_category(id):
    """æ›´æ–°èµ„æºåˆ†ç±»"""
    try:
        data = request.json or {}
        name = (data.get('name') or '').strip()
        parent_id = int(data.get('parent_id', 0) or 0)
        if not name:
            return jsonify({'success': False, 'message': 'åˆ†ç±»åç§°ä¸èƒ½ä¸ºç©º'}), 400
        conn = get_db_conn()
        c = conn.cursor()
        c.execute('UPDATE resource_categories SET name = ?, parent_id = ? WHERE id = ?', (name, parent_id, id))
        conn.commit()
        conn.close()
        return jsonify({'success': True, 'message': 'æ›´æ–°æˆåŠŸ'})
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500


@app.route('/api/resource_categories/<int:id>', methods=['DELETE'])
@login_required
def api_delete_resource_category(id):
    """åˆ é™¤èµ„æºåˆ†ç±»"""
    try:
        conn = get_db_conn()
        c = conn.cursor()
        c.execute('SELECT COUNT(*) FROM resource_categories WHERE parent_id = ?', (id,))
        if c.fetchone()[0] > 0:
            conn.close()
            return jsonify({'success': False, 'message': 'è¯¥åˆ†ç±»ä¸‹æœ‰å­åˆ†ç±»ï¼Œæ— æ³•åˆ é™¤'}), 400
        c.execute('SELECT COUNT(*) FROM resources WHERE category_id = ?', (id,))
        if c.fetchone()[0] > 0:
            conn.close()
            return jsonify({'success': False, 'message': 'è¯¥åˆ†ç±»ä¸‹æœ‰èµ„æºï¼Œæ— æ³•åˆ é™¤'}), 400
        c.execute('DELETE FROM resource_categories WHERE id = ?', (id,))
        conn.commit()
        conn.close()
        return jsonify({'success': True, 'message': 'åˆ é™¤æˆåŠŸ'})
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500


@app.route('/api/resources')
@login_required
def api_get_resources():
    """è·å–èµ„æºåˆ—è¡¨"""
    try:
        category_id = request.args.get('category_id', type=int)
        conn = get_db_conn()
        c = conn.cursor()
        if category_id:
            c.execute('''
                SELECT r.id, r.name, r.link, r.type, r.member_count, r.category_id, rc.name
                FROM resources r
                LEFT JOIN resource_categories rc ON r.category_id = rc.id
                WHERE r.category_id = ?
                ORDER BY r.id DESC
            ''', (category_id,))
        else:
            c.execute('''
                SELECT r.id, r.name, r.link, r.type, r.member_count, r.category_id, rc.name
                FROM resources r
                LEFT JOIN resource_categories rc ON r.category_id = rc.id
                ORDER BY r.id DESC
            ''')
        rows = c.fetchall()
        resources = []
        for row in rows:
            resources.append({
                'id': row[0],
                'name': row[1],
                'link': row[2],
                'type': row[3],
                'member_count': row[4],
                'category_id': row[5],
                'category_name': row[6] or ''
            })
        conn.close()
        return jsonify({'success': True, 'resources': resources})
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500


@app.route('/api/resources/<int:id>')
@login_required
def api_get_resource(id):
    """è·å–å•ä¸ªèµ„æº"""
    try:
        conn = get_db_conn()
        c = conn.cursor()
        c.execute('SELECT id, name, link, type, member_count, category_id FROM resources WHERE id = ?', (id,))
        row = c.fetchone()
        conn.close()
        if row:
            return jsonify({
                'id': row[0],
                'name': row[1],
                'link': row[2],
                'type': row[3],
                'member_count': row[4],
                'category_id': row[5]
            })
        return jsonify({'success': False, 'message': 'èµ„æºä¸å­˜åœ¨'}), 404
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500


@app.route('/api/resources', methods=['POST'])
@login_required
def api_create_resource():
    """åˆ›å»ºèµ„æº"""
    try:
        data = request.json or {}
        name = (data.get('name') or '').strip()
        link = (data.get('link') or '').strip()
        rtype = (data.get('type') or '').strip()
        category_id = int(data.get('category_id', 0) or 0)
        member_count = int(data.get('member_count', 0) or 0)
        if not name or not link or not rtype:
            return jsonify({'success': False, 'message': 'å¿…å¡«å­—æ®µä¸èƒ½ä¸ºç©º'}), 400
        if rtype not in ['group', 'channel']:
            return jsonify({'success': False, 'message': 'èµ„æºç±»å‹ä¸æ­£ç¡®'}), 400
        if not (link.startswith('https://t.me/') or link.startswith('t.me/') or link.startswith('@')):
            return jsonify({'success': False, 'message': 'Telegramé“¾æ¥æ ¼å¼ä¸æ­£ç¡®'}), 400
        conn = get_db_conn()
        c = conn.cursor()
        c.execute('INSERT INTO resources (category_id, name, link, type, member_count) VALUES (?, ?, ?, ?, ?)',
                  (category_id, name, link, rtype, member_count))
        conn.commit()
        conn.close()
        return jsonify({'success': True, 'message': 'åˆ›å»ºæˆåŠŸ'})
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500


@app.route('/api/resources/<int:id>', methods=['PUT'])
@login_required
def api_update_resource(id):
    """æ›´æ–°èµ„æº"""
    try:
        data = request.json or {}
        category_id = int(data.get('category_id', 0) or 0)
        name = (data.get('name') or '').strip()
        link = (data.get('link') or '').strip()
        rtype = (data.get('type') or '').strip()
        member_count = int(data.get('member_count', 0) or 0)
        conn = get_db_conn()
        c = conn.cursor()
        c.execute('''
            UPDATE resources 
            SET category_id = ?, name = ?, link = ?, type = ?, member_count = ?
            WHERE id = ?
        ''', (category_id, name, link, rtype, member_count, id))
        conn.commit()
        conn.close()
        return jsonify({'success': True, 'message': 'æ›´æ–°æˆåŠŸ'})
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500


@app.route('/api/resources/<int:id>', methods=['DELETE'])
@login_required
def api_delete_resource(id):
    """åˆ é™¤èµ„æº"""
    try:
        conn = get_db_conn()
        c = conn.cursor()
        c.execute('DELETE FROM resources WHERE id = ?', (id,))
        conn.commit()
        conn.close()
        return jsonify({'success': True, 'message': 'åˆ é™¤æˆåŠŸ'})
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500

@app.route('/api/broadcast/messages')
@login_required
def api_get_broadcast_messages():
    """è·å–ç¾¤å‘å†…å®¹åˆ—è¡¨"""
    try:
        conn = get_db_conn()
        c = conn.cursor()
        c.execute("""SELECT id, title, content, media_type, media_url, is_active, create_time,
                    image_url, video_url, buttons, buttons_per_row, broadcast_interval
                    FROM broadcast_messages ORDER BY id DESC""")
        rows = c.fetchall()
        messages = []
        for row in rows:
            messages.append({
                'id': row[0],
                'title': row[1],
                'content': row[2],
                'media_type': row[3],
                'media_url': row[4],
                'is_active': row[5],
                'create_time': row[6],
                'image_url': row[7] or '',
                'video_url': row[8] or '',
                'buttons': row[9] or '[]',
                'buttons_per_row': row[10] or 2,
                'broadcast_interval': row[11] or 120
            })
        conn.close()
        return jsonify({'success': True, 'messages': messages})
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/api/broadcast/send', methods=['POST'])
@login_required
def api_broadcast_send():
    """æ‰‹åŠ¨ç¾¤å‘æ¶ˆæ¯åˆ°æŒ‡å®šç¾¤ç»„"""
    try:
        data = request.get_json() or {}
        message = data.get('message', '')
        group_ids = data.get('group_ids', [])
        send_all = data.get('all', False)

        if not message:
            return jsonify({'success': False, 'message': 'æ¶ˆæ¯å†…å®¹ä¸èƒ½ä¸ºç©º'}), 400

        conn = get_db_conn()
        c = conn.cursor()

        if send_all:
            c.execute('SELECT id, group_link, group_name FROM member_groups')
        else:
            if not group_ids:
                conn.close()
                return jsonify({'success': False, 'message': 'è¯·é€‰æ‹©ç¾¤ç»„'}), 400
            placeholders = ','.join(['?' for _ in group_ids])
            c.execute(f'SELECT id, group_link, group_name FROM member_groups WHERE id IN ({placeholders})', group_ids)

        groups = c.fetchall()
        conn.close()

        if not groups:
            return jsonify({'success': False, 'message': 'æ²¡æœ‰æ‰¾åˆ°ç¾¤ç»„'}), 400

        # åŠ å…¥å‘é€é˜Ÿåˆ—
        sent = 0
        for g in groups:
            group_link = g[1]
            if group_link and 't.me/' in group_link:
                try:
                    pending_broadcasts.append({
                        'type': 'broadcast',
                        'group_links': [group_link],
                        'message_content': message
                    })
                    sent += 1
                except Exception:
                    pass

        return jsonify({'success': True, 'sent': sent, 'message': f'å·²åŠ å…¥å‘é€é˜Ÿåˆ—: {sent}ä¸ªç¾¤ç»„'})
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500

@app.route('/api/bot-configs')
@login_required
def api_bot_configs():
    """è·å–Boté…ç½®åˆ—è¡¨ (ä¿®å¤ç‰ˆ: è¿”å›å®Œæ•´å¯¹è±¡ç»“æ„)"""
    try:
        conn = get_db_conn()
        c = conn.cursor()
        # ä» bot_configs è¡¨è¯»å–è¯¦ç»†ä¿¡æ¯ï¼Œè€Œä¸æ˜¯ä» system_config è¯»å–ç®€å•å­—ç¬¦ä¸²
        c.execute("SELECT id, bot_token, bot_username, is_active, create_time FROM bot_configs ORDER BY id DESC")
        rows = c.fetchall()
        conn.close()

        configs = []
        for row in rows:
            configs.append({
                'id': row[0],
                'bot_token': row[1],
                'bot_username': row[2] or 'æœªçŸ¥',
                'is_active': row[3],
                'create_time': row[4] or ''
            })

        # è¿”å› configs å­—æ®µï¼Œå‰ç«¯è¡¨æ ¼æ‰èƒ½æ­£ç¡®æ¸²æŸ“
        return jsonify({'success': True, 'configs': configs, 'tokens': configs})
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500


@app.route('/api/bot-config', methods=['POST'])
@login_required
def api_create_bot_config():
    """æ·»åŠ æœºå™¨äººé…ç½®"""
    try:
        data = request.json or {}
        token = (data.get('bot_token') or '').strip()
        username = (data.get('bot_username') or '').strip()
        if not token:
            return jsonify({'success': False, 'message': 'Bot Token ä¸èƒ½ä¸ºç©º'}), 400
        conn = get_db_conn()
        c = conn.cursor()
        now = get_cn_time()
        c.execute('INSERT INTO bot_configs (bot_token, bot_username, is_active, create_time) VALUES (?, ?, ?, ?)',
                  (token, username, 1, now))
        new_id = c.lastrowid
        conn.commit()
        conn.close()

        try:
            from .bot_logic import bot, add_bot_dynamically
            if bot and getattr(bot, 'loop', None):
                bot.loop.create_task(add_bot_dynamically(new_id, token))
                print(f"[Web] å·²è§¦å‘æ–°æœºå™¨äººåŠ¨æ€å¯åŠ¨: ID {new_id}")
            else:
                print("[Web] ä¸»Botæœªè¿è¡Œï¼Œæ— æ³•åŠ¨æ€å¯åŠ¨ï¼Œéœ€é‡å¯ç”Ÿæ•ˆ")
        except Exception as e:
            print(f"[Web] åŠ¨æ€å¯åŠ¨è§¦å‘å¤±è´¥ (éœ€æ‰‹åŠ¨é‡å¯): {e}")

        return jsonify({'success': True, 'message': 'æœºå™¨äººå·²æ·»åŠ  (å°è¯•è‡ªåŠ¨å¯åŠ¨ä¸­...)'})
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500


@app.route('/api/bot-config/<int:id>', methods=['DELETE'])
@login_required
def api_delete_bot_config(id):
    """åˆ é™¤æœºå™¨äººé…ç½®"""
    try:
        conn = get_db_conn()
        c = conn.cursor()
        c.execute('DELETE FROM bot_configs WHERE id = ?', (id,))
        conn.commit()
        conn.close()
        return jsonify({'success': True, 'message': 'å·²åˆ é™¤'})
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500


# ============ ç¾¤å‘æ¶ˆæ¯å¢åˆ æ”¹æŸ¥ APIï¼ˆä¸å‰ç«¯æ¨¡æ¿åŒ¹é…ï¼‰ ============
@app.route('/api/broadcast/message', methods=['POST'])
@login_required
def api_create_broadcast_message():
    """åˆ›å»ºç¾¤å‘æ¶ˆæ¯ï¼ˆä¾›å‰ç«¯ templates/broadcast.html ä½¿ç”¨ï¼‰"""
    try:
        data = request.get_json() or {}
        title = (data.get('title') or '')[:200]
        content = data.get('content') or ''
        image_url = data.get('image_url') or ''
        video_url = data.get('video_url') or ''
        buttons = data.get('buttons') or '[]'
        buttons_per_row = int(data.get('buttons_per_row', 2) or 2)
        broadcast_interval = int(data.get('broadcast_interval', 120) or 120)
        now = get_cn_time()

        conn = get_db_conn()
        c = conn.cursor()
        c.execute('''
            INSERT INTO broadcast_messages
            (title, content, media_type, media_url, is_active, create_time, image_url, video_url, buttons, buttons_per_row, broadcast_interval)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        ''', (title, content, None, None, 1, now, image_url, video_url, buttons, buttons_per_row, broadcast_interval))
        conn.commit()
        conn.close()
        return jsonify({'success': True, 'message': 'åˆ›å»ºæˆåŠŸ'})
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500


@app.route('/api/broadcast/message/<int:id>', methods=['GET'])
@login_required
def api_get_broadcast_message(id):
    try:
        conn = get_db_conn()
        c = conn.cursor()
        c.execute('SELECT id, title, content, image_url, video_url, buttons, buttons_per_row, is_active, broadcast_interval, create_time FROM broadcast_messages WHERE id = ?', (id,))
        row = c.fetchone()
        conn.close()
        if not row:
            return jsonify({'success': False, 'message': 'æœªæ‰¾åˆ°è¯¥æ¶ˆæ¯'}), 404
        msg = {
            'id': row[0],
            'title': row[1],
            'content': row[2],
            'image_url': row[3] or '',
            'video_url': row[4] or '',
            'buttons': row[5] or '[]',
            'buttons_per_row': row[6] or 2,
            'is_active': row[7],
            'broadcast_interval': row[8] or 120,
            'create_time': row[9] or ''
        }
        return jsonify({'success': True, 'message': msg})
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500


@app.route('/api/broadcast/message/<int:id>', methods=['PUT'])
@login_required
def api_update_broadcast_message(id):
    try:
        data = request.get_json() or {}
        title = (data.get('title') or '')[:200]
        content = data.get('content') or ''
        image_url = data.get('image_url') or ''
        video_url = data.get('video_url') or ''
        buttons = data.get('buttons') or '[]'
        buttons_per_row = int(data.get('buttons_per_row', 2) or 2)
        broadcast_interval = int(data.get('broadcast_interval', 120) or 120)
        is_active = 1 if data.get('is_active', True) else 0

        conn = get_db_conn()
        c = conn.cursor()
        c.execute('''
            UPDATE broadcast_messages
            SET title = ?, content = ?, image_url = ?, video_url = ?, buttons = ?, buttons_per_row = ?, broadcast_interval = ?, is_active = ?
            WHERE id = ?
        ''', (title, content, image_url, video_url, buttons, buttons_per_row, broadcast_interval, is_active, id))
        conn.commit()
        conn.close()
        return jsonify({'success': True, 'message': 'æ›´æ–°æˆåŠŸ'})
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500


@app.route('/api/broadcast/message/<int:id>', methods=['DELETE'])
@login_required
def api_delete_broadcast_message(id):
    try:
        conn = get_db_conn()
        c = conn.cursor()
        c.execute('DELETE FROM broadcast_messages WHERE id = ?', (id,))
        conn.commit()
        conn.close()
        return jsonify({'success': True, 'message': 'åˆ é™¤æˆåŠŸ'})
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500

@app.route('/api/upload', methods=['POST'])
@login_required
def api_upload_file():
    """ä¸Šä¼ æ–‡ä»¶API"""
    try:
        file = request.files.get('file')
        if not file:
            return jsonify({'success': False, 'message': 'æ²¡æœ‰æ–‡ä»¶'}), 400

        # æ£€æŸ¥æ–‡ä»¶å¤§å°ï¼ˆ50MBï¼‰
        if file.content_length and file.content_length > 50 * 1024 * 1024:
            return jsonify({'success': False, 'message': 'æ–‡ä»¶å¤§å°è¶…è¿‡50MB'}), 400

        # æ£€æŸ¥æ–‡ä»¶ç±»å‹
        allowed_types = ['image/jpeg', 'image/png', 'image/gif', 'image/webp', 'video/mp4', 'video/avi', 'video/mov']
        if file.content_type not in allowed_types:
            return jsonify({'success': False, 'message': 'ä¸æ”¯æŒçš„æ–‡ä»¶ç±»å‹'}), 400

        # ç”Ÿæˆæ–‡ä»¶å
        import uuid
        filename = f"{uuid.uuid4().hex}_{file.filename}"
        # ä½¿ç”¨é…ç½®ä¸­çš„ UPLOAD_DIRï¼ˆé€šå¸¸ä¸º <BASE_DIR>/static/uploadsï¼‰
        file_path = os.path.join(UPLOAD_DIR, filename)

        # ç¡®ä¿ä¸Šä¼ ç›®å½•å­˜åœ¨
        os.makedirs(os.path.dirname(file_path), exist_ok=True)

        # ä¿å­˜æ–‡ä»¶
        file.save(file_path)

        # è¿”å›æ–‡ä»¶URL
        file_url = f"/static/uploads/{filename}"
        return jsonify({'success': True, 'url': file_url, 'message': 'ä¸Šä¼ æˆåŠŸ'})

    except Exception as e:
        print(f"ä¸Šä¼ æ–‡ä»¶é”™è¯¯: {e}")
        return jsonify({'success': False, 'message': 'ä¸Šä¼ å¤±è´¥'}), 500

@app.route('/api/welcome-messages')
@login_required
def api_welcome_messages():
    """è·å–æ¬¢è¿æ¶ˆæ¯åˆ—è¡¨"""
    try:
        config = get_system_config()
        return jsonify({
            'success': True,
            'welcome_enabled': config.get('welcome_enabled', '0'),
            'welcome_message': config.get('welcome_message', '')
        })
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500

@app.route('/api/advertisements')
@login_required
def api_advertisements():
    """è·å–å¹¿å‘Šåˆ—è¡¨"""
    try:
        conn = get_db_conn()
        c = conn.cursor()
        c.execute("SELECT id, content, is_active, create_time FROM broadcast_messages WHERE media_type = 'ad' ORDER BY id DESC")
        rows = c.fetchall()
        ads = []
        for row in rows:
            ads.append({
                'id': row[0],
                'content': row[1],
                'is_active': row[2],
                'create_time': row[3]
            })
        conn.close()
        return jsonify({'success': True, 'advertisements': ads})
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500

@app.route('/api/level-settings')
@login_required
def api_level_settings():
    """è·å–å±‚çº§è®¾ç½®ï¼ˆè¯»å–æ—¶å†æ¬¡æ¸…ç†0å€¼ï¼‰"""
    try:
        config = get_system_config()

        # 1. è·å–å±‚æ•°
        try:
            level_count = int(config.get('level_count', 10))
        except:
            level_count = 10

        # 2. è·å–é»˜è®¤é‡‘é¢
        try:
            level_reward = float(config.get('level_reward', 1.0))
            if level_reward <= 0: level_reward = 1.0
        except:
            level_reward = 1.0

        # 3. å¤„ç†å±‚çº§é‡‘é¢ï¼ˆget_system_configå·²ç»è§£æè¿‡äº†ï¼‰
        level_amounts_raw = config.get('level_amounts')
        level_amounts = []

        if level_amounts_raw and isinstance(level_amounts_raw, list):
            # get_system_configå·²ç»è§£æè¿‡äº†ï¼Œç›´æ¥ä½¿ç”¨
            for x in level_amounts_raw:
                try:
                    v = float(x)
                    if v <= 0.001: v = level_reward # ã€å…³é”®ä¿®å¤ã€‘è¯»å–æ—¶å¦‚æœæ˜¯0ï¼Œæ˜¾ç¤ºä¸ºé»˜è®¤å€¼
                    level_amounts.append(v)
                except:
                    level_amounts.append(level_reward)
        else:
            # å¦‚æœæ•°æ®æœ‰é—®é¢˜ï¼Œåˆ›å»ºé»˜è®¤å€¼
            level_amounts = [level_reward] * level_count

        # 4. è¡¥é½æˆ–æˆªæ–­
        # è¡¥é½
        if len(level_amounts) < level_count:
            missing = level_count - len(level_amounts)
            # ç”¨ level_reward è¡¥é½
            level_amounts += [level_reward] * missing

        # æˆªæ–­ (åªå–å‰ level_count ä¸ª)
        level_amounts = level_amounts[:level_count]

        result = {
            'success': True,
            'level_count': level_count,
            'level_reward': level_reward,
            'level_amounts': level_amounts
        }
        response = jsonify(result)
        # æ·»åŠ ç¼“å­˜æ§åˆ¶å¤´ï¼Œé˜²æ­¢æµè§ˆå™¨ç¼“å­˜
        response.headers['Cache-Control'] = 'no-cache, no-store, must-revalidate'
        response.headers['Pragma'] = 'no-cache'
        response.headers['Expires'] = '0'
        return response
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500


@app.route('/api/level-settings', methods=['POST'])
@login_required
def api_update_level_settings():
    """ä¿å­˜å±‚çº§è®¾ç½®ï¼ˆç»ˆæä¿®å¤ï¼šå¼ºåˆ¶éé›¶ï¼‰"""
    try:
        data = request.json or {}

        # 1. è·å–ç›®æ ‡å±‚æ•°
        try:
            target_count = int(data.get('level_count', 10))
            if target_count <= 0: target_count = 10
        except:
            target_count = 10

        # 2. ç¡®å®šé»˜è®¤å…œåº•é‡‘é¢ (level_reward)
        try:
            # ä¼˜å…ˆçœ‹ç”¨æˆ·æ˜¯å¦åŒæ—¶ä¹Ÿæäº¤äº† level_reward (å¿«æ·è®¾ç½®)
            # å¦‚æœæ²¡æœ‰ï¼Œåˆ™å»æ•°æ®åº“æŸ¥ï¼Œå¦‚æœæ•°æ®åº“ä¹Ÿæ²¡æœ‰ï¼Œå°±ç”¨ 1.0
            input_reward = data.get('level_reward')
            if input_reward:
                default_reward = float(input_reward)
            else:
                current_config = get_system_config()
                default_reward = float(current_config.get('level_reward', 1.0))

            if default_reward <= 0: default_reward = 1.0
        except:
            default_reward = 1.0

        # è·å–å‰ç«¯ä¼ æ¥çš„é‡‘é¢åˆ—è¡¨
        raw_amounts = data.get('level_amounts')
        final_amounts = []

        # 3. ä¸¥æ ¼å¾ªç¯ target_count æ¬¡ï¼Œæ„å»ºåˆ—è¡¨
        for i in range(target_count):
            val_float = 0.0

            # ã€ä¿®æ”¹2ã€‘å¢å¼ºæ•°æ®è¯»å–é€»è¾‘ï¼Œä¿®å¤ç¬¬10å±‚æ— æ³•è®¾ç½®çš„é—®é¢˜
            if raw_amounts:
                val = None
                if isinstance(raw_amounts, list):
                    if i < len(raw_amounts):
                        val = raw_amounts[i]
                elif isinstance(raw_amounts, dict):
                    # å°è¯•å¤šç§ Key æ ¼å¼: "1", 1, "0", 0
                    # æ³¨æ„ï¼šé€šå¸¸ç¬¬1å±‚å¯¹åº”çš„ key æ˜¯ "1"
                    # ä¼˜å…ˆå°è¯• "1", "2" ... "10" æ ¼å¼
                    val = raw_amounts.get(str(i + 1))
                    # å…¶æ¬¡å°è¯• 1, 2 ... 10 (int key)
                    if val is None: val = raw_amounts.get(i + 1)
                    # å†æ¬¡å°è¯• "0", "1" (0-based string key)
                    if val is None: val = raw_amounts.get(str(i))
                    # æœ€åå°è¯• 0, 1 (0-based int key)
                    if val is None: val = raw_amounts.get(i)

                print(f"[DEBUG] ç¬¬{i+1}å±‚: åŸå§‹å€¼={val}, ç±»å‹={type(val)}")

                try:
                    if val is not None and str(val).strip() != "":
                        val_float = float(val)
                except:
                    val_float = 0.0

            # ã€é‡è¦ä¿®å¤ã€‘åªæœ‰å½“val_floatç¡®å®æ˜¯0æˆ–ç©ºå€¼æ—¶æ‰ä½¿ç”¨é»˜è®¤å€¼
            # ä¸è¦å¼ºåˆ¶è¦†ç›–ç”¨æˆ·æ˜ç¡®è®¾ç½®çš„æ­£æ•°å€¼
            if val_float <= 0.0001:  # åªå¤„ç†çœŸæ­£çš„0å€¼
                val_float = default_reward
                print(f"[DEBUG] ç¬¬{i+1}å±‚å€¼è¿‡å°ï¼Œä½¿ç”¨é»˜è®¤å€¼: {default_reward}")

            final_amounts.append(val_float)
            print(f"[DEBUG] ç¬¬{i+1}å±‚æœ€ç»ˆå€¼: {val_float}")

        # 4. ä¿å­˜
        update_system_config('level_count', target_count)
        update_system_config('level_amounts', final_amounts)  # è¿™é‡Œä¼šè‡ªåŠ¨JSONåºåˆ—åŒ–
        # åŒæ—¶æ›´æ–° level_reward ä¸ºå…œåº•å€¼ï¼Œä¿æŒä¸€è‡´æ€§
        update_system_config('level_reward', default_reward)

        response = jsonify({
            'success': True,
            'message': 'å±‚çº§è®¾ç½®å·²ä¿å­˜',
            'saved_count': target_count,
            'saved_amounts': final_amounts
        })
        # æ·»åŠ ç¼“å­˜æ§åˆ¶å¤´
        response.headers['Cache-Control'] = 'no-cache, no-store, must-revalidate'
        response.headers['Pragma'] = 'no-cache'
        response.headers['Expires'] = '0'
        return response
    except Exception as e:
        print(f"ä¿å­˜è®¾ç½®å‡ºé”™: {e}")
        import traceback
        traceback.print_exc()
        return jsonify({'success': False, 'message': str(e)}), 500


@app.route('/api/withdrawals')
@login_required
def api_withdrawals():
    """è·å–æç°åˆ—è¡¨API"""
    page = request.args.get('page', 1, type=int)
    per_page = request.args.get('per_page', 20, type=int)
    status = request.args.get('status', 'all')
    search = request.args.get('search', '').strip()
    
    data = WebDB.get_withdrawals(page, per_page, status, search)
    return jsonify(data)

@app.route('/api/withdrawals/<int:id>/process', methods=['POST'])
@login_required
def api_process_withdrawal(id):
    """å¤„ç†æç°API"""
    data = request.json
    action = data.get('action')
    
    success, message = WebDB.process_withdrawal(id, action)
    if success:
        return jsonify({'success': True, 'message': message})
    return jsonify({'success': False, 'message': message}), 400

@app.route('/api/recharges/stats')
@login_required
def api_recharges_stats():
    """è·å–å……å€¼ç»Ÿè®¡æ•°æ®ï¼ˆå¸¦æ—¥æœŸç­›é€‰ï¼‰"""
    try:
        # ã€ä¿®æ”¹4ã€‘è·å–æ—¥æœŸç­›é€‰å‚æ•°
        start_date = request.args.get('start_date', '').strip()
        end_date = request.args.get('end_date', '').strip()

        conn = get_db_conn()
        c = conn.cursor()

        # æ„å»ºåŸºç¡€æŸ¥è¯¢å’Œå‚æ•°
        base_where = "WHERE 1=1"
        params = []

        if start_date:
            base_where += " AND date(create_time) >= ?"
            params.append(start_date)

        if end_date:
            base_where += " AND date(create_time) <= ?"
            params.append(end_date)

        # è¾…åŠ©å‡½æ•°ï¼šæ ¹æ®çŠ¶æ€æ„å»ºæŸ¥è¯¢
        def get_stat_sql(status_filter=None):
            sql = f"SELECT COALESCE(SUM(amount), 0), COUNT(*) FROM recharge_records {base_where}"
            current_params = params.copy()
            if status_filter:
                sql += " AND status = ?"
                current_params.append(status_filter)
            return sql, current_params

        # æ€»å……å€¼é‡‘é¢/ç¬”æ•°
        sql, p = get_stat_sql(None)
        c.execute(sql, p)
        row = c.fetchone()
        total_amount = row[0]
        total_count = row[1]

        # æˆåŠŸå……å€¼é‡‘é¢/ç¬”æ•°
        sql, p = get_stat_sql("completed")
        c.execute(sql, p)
        row = c.fetchone()
        success_amount = row[0]
        success_count = row[1]

        # å¤±è´¥å……å€¼é‡‘é¢/ç¬”æ•°
        sql, p = get_stat_sql("failed")
        c.execute(sql, p)
        row = c.fetchone()
        failed_amount = row[0]
        failed_count = row[1]

        # å¾…å¤„ç†ç¬”æ•° (åªç»Ÿè®¡ç¬”æ•°ï¼Œé€šå¸¸å¾…å¤„ç†é‡‘é¢ä¸è®¡å…¥ç»Ÿè®¡æˆ–å•ç‹¬åˆ—å‡ºï¼Œè¿™é‡Œä¿æŒåŸæœ‰ç»“æ„)
        sql, p = get_stat_sql("pending")
        c.execute(sql, p)
        row = c.fetchone()
        pending_count = row[1]

        conn.close()

        return jsonify({
            'success': True,
            'stats': {
                'total_amount': float(total_amount),
                'success_amount': float(success_amount),
                'failed_amount': float(failed_amount),
                'total_count': total_count,
                'success_count': success_count,
                'failed_count': failed_count,
                'pending_count': pending_count
            }
        })

    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500

@app.route('/api/recharges')
@login_required
def api_recharges():
    """è·å–å……å€¼è®¢å•åˆ—è¡¨ï¼ˆæ”¯æŒæ—¥æœŸç­›é€‰ï¼‰"""
    try:
        page = int(request.args.get('page', 1))
        per_page = int(request.args.get('per_page', 20))
        search = request.args.get('search', '').lstrip('@').strip()
        # æ·»åŠ æ—¥æœŸç­›é€‰å‚æ•°
        start_date = request.args.get('start_date', '').strip()
        end_date = request.args.get('end_date', '').strip()
        
        conn = get_db_conn()
        c = conn.cursor()
        
        where_clause = 'WHERE 1=1'
        params = []

        # æ·»åŠ æœç´¢æ¡ä»¶
        if search:
            where_clause += ' AND (r.member_id LIKE ? OR r.order_id LIKE ? OR m.username LIKE ?)'
            search_param = f'%{search}%'
            params.extend([search_param, search_param, search_param])

        # æ·»åŠ æ—¥æœŸç­›é€‰æ¡ä»¶
        if start_date:
            where_clause += ' AND date(r.create_time) >= ?'
            params.append(start_date)

        if end_date:
            where_clause += ' AND date(r.create_time) <= ?'
            params.append(end_date)
        
        count_query = f'SELECT COUNT(*) FROM recharge_records r LEFT JOIN members m ON r.member_id = m.telegram_id {where_clause}'
        c.execute(count_query, params)
        total = c.fetchone()[0]
        
        offset = (page - 1) * per_page

        # æ£€æŸ¥ recharge_records è¡¨ä¸­æ˜¯å¦å­˜åœ¨ remark å­—æ®µ
        c.execute("PRAGMA table_info(recharge_records)")
        cols = [r[1] for r in c.fetchall()]
        remark_present = 'remark' in cols

        if remark_present:
            query = f'''
                SELECT r.id, r.member_id, m.username, r.amount, r.order_id,
                       r.status, r.create_time, r.payment_method, r.remark
                FROM recharge_records r
                LEFT JOIN members m ON r.member_id = m.telegram_id
                {where_clause}
                ORDER BY r.create_time DESC
                LIMIT ? OFFSET ?
            '''
        else:
            query = f'''
                SELECT r.id, r.member_id, m.username, r.amount, r.order_id,
                       r.status, r.create_time, r.payment_method
                FROM recharge_records r
                LEFT JOIN members m ON r.member_id = m.telegram_id
                {where_clause}
                ORDER BY r.create_time DESC
                LIMIT ? OFFSET ?
            '''
        c.execute(query, params + [per_page, offset])

        recharges = []
        for row in c.fetchall():
            # æ ¹æ®remarkåˆ¤æ–­å……å€¼ç±»å‹
            remark = row[8] if remark_present and len(row) > 8 else ''
            recharge_type = 'å¼€é€šVIP' if remark == 'å¼€é€š' else 'å……å€¼'

            item = {
                'id': row[0],
                'telegram_id': row[1],
                'username': row[2] or '',
                'amount': row[3],
                'order_number': row[4] or '',
                'status': row[5],
                'create_time': row[6][:19] if row[6] else '',
                'payment_method': row[7] or '',
                'type': recharge_type  # æ–°å¢ç±»å‹å­—æ®µ
            }
            if remark_present:
                item['remark'] = remark
            else:
                item['remark'] = ''
            recharges.append(item)
        
        conn.close()
        
        return jsonify({
            'success': True,
            'records': recharges,
            'total': total,
            'page': page,
            'per_page': per_page
        })
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500

@app.route('/api/recharges/<int:recharge_id>/status', methods=['POST'])
@login_required
def api_update_recharge_status(recharge_id):
    """ã€æ ¸å¿ƒä¿®å¤ã€‘åå°æ‰‹åŠ¨ä¿®æ”¹å……å€¼è®¢å•çŠ¶æ€ - ç»Ÿä¸€è°ƒç”¨ process_recharge"""
    try:
        data = request.get_json() or {}
        new_status = (data.get('status') or '').strip()
        if not new_status:
            return jsonify({'success': False, 'message': 'ç¼ºå°‘çŠ¶æ€å‚æ•°'})

        conn = get_db_conn()
        c = conn.cursor()
        c.execute('SELECT member_id, amount, status, order_id FROM recharge_records WHERE id = ?', (recharge_id,))
        row = c.fetchone()
        if not row:
            conn.close()
            return jsonify({'success': False, 'message': 'è®¢å•ä¸å­˜åœ¨'})

        member_id, amount, old_status, order_id = row
        
        if new_status != 'completed':
            c.execute('UPDATE recharge_records SET status = ? WHERE id = ?', (new_status, recharge_id))
            conn.commit()
            conn.close()
            return jsonify({'success': True, 'message': 'è®¢å•çŠ¶æ€å·²æ›´æ–°'})

        if old_status == 'completed':
            conn.close()
            return jsonify({'success': True, 'message': 'è¯¥è®¢å•å·²æ˜¯å·²æ”¯ä»˜çŠ¶æ€ï¼Œæ— éœ€é‡å¤å¤„ç†'})

        # 1. æ ‡è®°æ•°æ®åº“çŠ¶æ€
        # ã€ä¿®å¤ç‚¹ã€‘æ ¹æ®é‡‘é¢åˆ¤æ–­æ˜¯å¦æ ‡è®°ä¸º"å¼€é€š"
        config = get_system_config()
        vip_price = float(config.get('vip_price', 10))
        remark_text = 'ç®¡ç†å‘˜æ‰‹åŠ¨é€šè¿‡'

        # æ£€æŸ¥æ˜¯å¦æ˜¯VIPè®¢å•ï¼ˆåŸºäºé‡‘é¢åˆ¤æ–­ï¼‰
        is_vip_order = False
        if amount >= vip_price:
            is_vip_order = True
            remark_text = 'å¼€é€š'  # å…³é”®ï¼šè¿™å°±æŠŠç±»å‹æ”¹æˆäº†"å¼€é€šVIP"

        c.execute('UPDATE recharge_records SET status = ?, remark = ? WHERE id = ?',
                 ('completed', remark_text, recharge_id))

        # 2. ç»™ç”¨æˆ·åŠ ä½™é¢ (é‡è¦ï¼)
        c.execute('UPDATE members SET balance = balance + ? WHERE telegram_id = ?', (amount, member_id))
        conn.commit()
        conn.close()

        # 3. ã€æ ¸å¿ƒã€‘å‘Šè¯‰æœºå™¨äººå»å¤„ç†ä¸šåŠ¡ï¼ˆå¼€VIPã€åˆ†çº¢ã€å‘é€šçŸ¥ï¼‰
        # è¿™ä¼šè§¦å‘ bot_logic.process_rechargeï¼Œå®ƒä¼šè‡ªåŠ¨è¯†åˆ«ä½™é¢æ˜¯å¦è¶³å¤Ÿå¼€VIP
        try:
            import bot_logic
            if hasattr(bot_logic, 'process_recharge_queue'):
                # æ¨å…¥é˜Ÿåˆ—ï¼Œè®©æœºå™¨äººçº¿ç¨‹å»æ‰£æ¬¾ã€å¼€é€šVIPã€å‘åˆ†çº¢
                bot_logic.process_recharge_queue.append({
                    'member_id': member_id,
                    'amount': amount,
                    'is_vip_order': is_vip_order  # ä¼ é€’æ­£ç¡®çš„æ ‡å¿—
                })
                print(f"[Webåå°æ‰‹åŠ¨é€šè¿‡] å·²å°†è®¢å• {order_id} æ¨é€ç»™æœºå™¨äººå¤„ç†VIPé€»è¾‘ï¼ŒVIPè®¢å•: {is_vip_order}")
        except Exception as e:
            print(f"[Webåå°æ‰‹åŠ¨é€šè¿‡] æ¨é€æœºå™¨äººé˜Ÿåˆ—å¤±è´¥: {e}")

        return jsonify({'success': True, 'message': 'å·²æ‰‹åŠ¨é€šè¿‡ï¼ŒVIPå¼€é€šå’Œåˆ†çº¢å°†åœ¨å‡ ç§’å†…è‡ªåŠ¨å¤„ç†'})
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500

@app.route('/api/members/broadcast', methods=['POST'])
@login_required
def api_members_broadcast():
    global notify_queue
    """å‘ä¼šå‘˜å‘é€ç¾¤å‘æ¶ˆæ¯"""
    try:
        data = request.get_json() or {}
        message = (data.get('message') or '').strip()
        member_ids = data.get('member_ids') or []
        send_all = bool(data.get('all'))

        if not message:
            return jsonify({'success': False, 'message': 'æ¶ˆæ¯å†…å®¹ä¸èƒ½ä¸ºç©º'})

        conn = get_db_conn()
        c = conn.cursor()

        targets = []
        if send_all:
            c.execute('SELECT telegram_id FROM members')
            targets = [row[0] for row in c.fetchall()]
        else:
            ids = []
            for mid in member_ids:
                try:
                    ids.append(int(mid))
                except (TypeError, ValueError):
                    continue
            if not ids:
                conn.close()
                return jsonify({'success': False, 'message': 'è¯·é€‰æ‹©è¦å‘é€çš„ä¼šå‘˜'})
            placeholders = ','.join(['?' for _ in ids])
            c.execute(f'SELECT telegram_id FROM members WHERE telegram_id IN ({placeholders})', ids)
            targets = [row[0] for row in c.fetchall()]

        conn.close()

        if not targets:
            return jsonify({'success': False, 'message': 'æœªæ‰¾åˆ°å¯¹åº”çš„ä¼šå‘˜'})

        # ç¡®ä¿notify_queueå·²åˆå§‹åŒ–
        if not notify_queue:
            from bot_logic import notify_queue
        
        for mid in targets:
            notify_queue.append({'member_id': mid, 'message': message})

        count = len(targets)
        return jsonify({'success': True, 'count': count, 'message': f'å·²åŠ å…¥å‘é€é˜Ÿåˆ—ï¼Œå°†å‘ {count} ä½ä¼šå‘˜å‘é€'})
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500

@app.route('/api/settings', methods=['GET'])
@login_required
def api_get_settings():
    """è·å–ç³»ç»Ÿè®¾ç½®API"""
    try:
        config = get_system_config()
        return jsonify({
            'success': True,
            'settings': {
                'levels': config.get('level_count', 10),
                'reward_per_level': config.get('level_reward', 1),
                'vip_price': config.get('vip_price', 10),
                'withdraw_threshold': config.get('withdraw_threshold', 50),
                'usdt_address': config.get('usdt_address', ''),
                'service_text': config.get('support_text', ''),
                'pinned_ad': config.get('pinned_ad', ''),
                'welcome_message': config.get('welcome_message', ''),
                'welcome_enabled': config.get('welcome_enabled', '1'),
                'auto_register_enabled': config.get('auto_register_enabled', '0')
            }
        })
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500

@app.route('/api/settings', methods=['POST'])
@login_required
def api_update_settings():
    """æ›´æ–°ç³»ç»Ÿè®¾ç½®API"""
    try:
        data = request.json
        key = data.get('key')
        value = data.get('value')
        
        if not key:
            return jsonify({'success': False, 'message': 'ç¼ºå°‘keyå‚æ•°'}), 400
        
        from .database import update_system_config
        update_system_config(key, value)
        
        return jsonify({'success': True, 'message': 'è®¾ç½®å·²æ›´æ–°'})
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500

# ==================== è¡¥å…¨é—æ¼çš„ API è·¯ç”± ====================

@app.route('/api/settings/fallback-accounts')
@login_required
def api_settings_fallback_accounts():
    """æ¡æ¼è´¦å·è®¾ç½® API (å…¼å®¹æ—§å‰ç«¯)"""
    return api_fallback_accounts()

@app.route('/api/customer_services')
@login_required
def api_get_customer_services():
    """è·å–å®¢æœåˆ—è¡¨API"""
    try:
        services = DB.get_customer_services()
        # Return as an array for frontend templates that expect a plain list
        return jsonify(services)
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500


@app.route('/api/customer_services', methods=['POST'])
@login_required
def api_create_customer_service():
    """åˆ›å»ºå®¢æœ"""
    try:
        data = request.json or {}
        name = (data.get('name') or '').strip()
        link = (data.get('link') or '').strip()
        if not name or not link:
            return jsonify({'success': False, 'message': 'åç§°å’Œé“¾æ¥ä¸èƒ½ä¸ºç©º'}), 400
        conn = get_db_conn()
        c = conn.cursor()
        c.execute('INSERT INTO customer_service (name, link) VALUES (?, ?)', (name, link))
        conn.commit()
        new_id = c.lastrowid
        conn.close()
        return jsonify({'success': True, 'id': new_id})
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500


@app.route('/api/customer_services/<int:id>', methods=['GET'])
@login_required
def api_get_customer_service(id):
    """è·å–å•ä¸ªå®¢æœ"""
    try:
        conn = get_db_conn()
        c = conn.cursor()
        c.execute('SELECT id, name, link FROM customer_service WHERE id = ?', (id,))
        row = c.fetchone()
        conn.close()
        if not row:
            return jsonify({'success': False, 'message': 'å®¢æœä¸å­˜åœ¨'}), 404
        return jsonify({'id': row[0], 'name': row[1], 'link': row[2]})
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500


@app.route('/api/customer_services/<int:id>', methods=['PUT'])
@login_required
def api_update_customer_service(id):
    """æ›´æ–°å®¢æœ"""
    try:
        data = request.json or {}
        name = data.get('name')
        link = data.get('link')
        if not name and not link:
            return jsonify({'success': False, 'message': 'æ— æ›´æ–°å­—æ®µ'}), 400
        conn = get_db_conn()
        c = conn.cursor()
        if name:
            c.execute('UPDATE customer_service SET name = ? WHERE id = ?', (name, id))
        if link:
            c.execute('UPDATE customer_service SET link = ? WHERE id = ?', (link, id))
        conn.commit()
        conn.close()
        return jsonify({'success': True, 'message': 'æ›´æ–°æˆåŠŸ'})
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500


@app.route('/api/customer_services/<int:id>', methods=['DELETE'])
@login_required
def api_delete_customer_service(id):
    """åˆ é™¤å®¢æœ"""
    try:
        conn = get_db_conn()
        c = conn.cursor()
        c.execute('DELETE FROM customer_service WHERE id = ?', (id,))
        conn.commit()
        conn.close()
        return jsonify({'success': True, 'message': 'åˆ é™¤æˆåŠŸ'})
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500

@app.route('/api/payment-config', methods=['GET'])
@login_required
def api_get_payment_config():
    """è·å–æ”¯ä»˜é…ç½®API"""
    try:
        # Return payload compatible with frontend field names
        return jsonify({
            'success': True,
            'config': {
                'payment_url': PAYMENT_CONFIG.get('api_url', ''),
                'payment_token': PAYMENT_CONFIG.get('key', ''),
                'payment_rate': PAYMENT_CONFIG.get('payment_rate', 1.00),
                'payment_channel': PAYMENT_CONFIG.get('pay_type', 'trc20'),
                'payment_user_id': PAYMENT_CONFIG.get('partner_id', '')
            }
        })
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500


@app.route('/api/payment-config', methods=['POST'])
@login_required
def api_update_payment_config():
    """æ›´æ–°æ”¯ä»˜é…ç½®ï¼ˆå‰ç«¯ä¿å­˜ï¼‰"""
    try:
        data = request.json or {}
        # write to system_config and update in-memory PAYMENT_CONFIG
        from .database import update_system_config
        # Support both frontend keys and alternative keys
        url = data.get('payment_url') or data.get('api_url') or data.get('paymentUrl')
        token = data.get('payment_token') or data.get('paymentToken') or data.get('key')
        rate = data.get('payment_rate') or data.get('paymentRate')
        channel = data.get('payment_channel') or data.get('paymentChannel') or data.get('pay_type')
        user_id = data.get('payment_user_id') or data.get('paymentUserId') or data.get('partner_id')

        if url is not None:
            update_system_config('payment_url', url)
            PAYMENT_CONFIG['api_url'] = url
        if token is not None:
            update_system_config('payment_token', token)
            PAYMENT_CONFIG['key'] = token
        if rate is not None:
            update_system_config('payment_rate', str(rate))
            PAYMENT_CONFIG['payment_rate'] = float(rate)
        if channel is not None:
            update_system_config('payment_channel', channel)
            PAYMENT_CONFIG['pay_type'] = channel
        if user_id is not None:
            update_system_config('payment_user_id', str(user_id))
            PAYMENT_CONFIG['partner_id'] = str(user_id)

        return jsonify({'success': True, 'message': 'æ”¯ä»˜é…ç½®å·²ä¿å­˜'})
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500

@app.route('/api/settings/bot-tokens')
@login_required
def api_bot_tokens_alias():
    """Bot Tokenåˆ—è¡¨ (å…¼å®¹æ—§å‰ç«¯)"""
    return api_bot_configs()


@app.route('/api/settings/bot-tokens', methods=['POST'])
@login_required
def api_add_bot_token_alias():
    """æ·»åŠ Bot Token (å…¼å®¹æ—§å‰ç«¯)"""
    try:
        data = request.json or {}
        token = (data.get('token') or '').strip()
        if not token:
            return jsonify({'success': False, 'message': 'Tokenä¸èƒ½ä¸ºç©º'}), 400
        conn = get_db_conn()
        c = conn.cursor()
        c.execute("SELECT COUNT(*) FROM system_config WHERE key LIKE 'bot_token_%'")
        count = c.fetchone()[0]
        key = f'bot_token_{count + 1}'
        c.execute('INSERT INTO system_config (key, value) VALUES (?, ?)', (key, token))
        conn.commit()
        conn.close()
        return jsonify({'success': True, 'message': 'Tokenå·²æ·»åŠ '})
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500


@app.route('/api/settings/bot-tokens/<int:index>', methods=['DELETE'])
@login_required
def api_delete_bot_token_alias(index):
    """åˆ é™¤Bot Token (å…¼å®¹æ—§å‰ç«¯)"""
    try:
        conn = get_db_conn()
        c = conn.cursor()
        # keys are 1-based in UI mapping to bot_token_{n}
        key = f'bot_token_{index + 1}'
        c.execute("DELETE FROM system_config WHERE key = ?", (key,))
        conn.commit()
        conn.close()
        return jsonify({'success': True, 'message': 'Tokenå·²åˆ é™¤'})
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500

@app.route('/api/fallback-accounts/<int:id>', methods=['DELETE'])
@login_required
def api_delete_fallback_account(id):
    """åˆ é™¤æ¡æ¼è´¦å·"""
    try:
        conn = get_db_conn()
        c = conn.cursor()
        c.execute('DELETE FROM fallback_accounts WHERE id = ?', (id,))
        conn.commit()
        conn.close()
        return jsonify({'success': True, 'message': 'åˆ é™¤æˆåŠŸ'})
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500

@app.route('/api/fallback-accounts/<int:id>', methods=['PUT'])
@login_required
def api_update_fallback_account(id):
    """æ›´æ–°æ¡æ¼è´¦å·"""
    try:
        data = request.json
        conn = get_db_conn()
        c = conn.cursor()
        
        updates = []
        params = []
        
        if 'username' in data:
            updates.append('username = ?')
            params.append(data['username'])
        if 'group_link' in data:
            updates.append('group_link = ?')
            params.append(data['group_link'])
        if 'is_active' in data:
            updates.append('is_active = ?')
            params.append(1 if data['is_active'] else 0)
        
        if updates:
            params.append(id)
            c.execute(f'UPDATE fallback_accounts SET {", ".join(updates)} WHERE id = ?', params)
            conn.commit()
        
        conn.close()
        return jsonify({'success': True, 'message': 'æ›´æ–°æˆåŠŸ'})
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500

# ==================== ç®¡ç†å‘˜æ‰‹åŠ¨å¼€é€šVIP API ====================

@app.route('/api/member/<int:telegram_id>/manual-vip', methods=['POST'])
@login_required
def api_manual_vip(telegram_id):
    """
    ã€æ ¸å¿ƒä¿®å¤ã€‘ç®¡ç†å‘˜æ‰‹åŠ¨å¼€é€šVIP - ç»Ÿä¸€è°ƒç”¨ distribute_vip_rewards
    åˆ é™¤æ‰€æœ‰æ‰‹å†™åˆ†çº¢é€»è¾‘
    """
    try:
        config = get_system_config()
        
        # ã€æ ¸å¿ƒä¿®å¤ã€‘ä½¿ç”¨botçš„äº‹ä»¶å¾ªç¯åˆ›å»ºå¼‚æ­¥ä»»åŠ¡
        # Flaskæ˜¯åŒæ­¥çš„ï¼Œæ‰€ä»¥é€šè¿‡äº‹ä»¶å¾ªç¯åˆ›å»ºä»»åŠ¡ï¼Œä¸ç­‰å¾…ç»“æœ
        if bot:
            bot.loop.create_task(admin_manual_vip_handler(telegram_id, config))
        else:
            # å¦‚æœbotæœªåˆå§‹åŒ–ï¼Œå»¶è¿Ÿå¯¼å…¥
            from bot_logic import bot, admin_manual_vip_handler
            bot.loop.create_task(admin_manual_vip_handler(telegram_id, config))
        
        return jsonify({
            'success': True,
            'message': 'VIPå¼€é€šä»»åŠ¡å·²æäº¤ï¼Œæ­£åœ¨åå°å¤„ç†ä¸­...'
        })
    except Exception as e:
        return jsonify({'success': False, 'message': str(e)}), 500

def run_web():
    """Web å¯åŠ¨å…¥å£"""
    global PAYMENT_CONFIG

    # Load payment config from database - å®Œå…¨ä¾èµ–æ•°æ®åº“é…ç½®
    try:
        config = get_system_config()

        # ä»æ•°æ®åº“åŠ è½½æ‰€æœ‰é…ç½®ï¼Œå¦‚æœæ•°æ®åº“ä¸­æ²¡æœ‰åˆ™ä¸ºç©º
        PAYMENT_CONFIG.update({
            'api_url': config.get('payment_url', ''),
            'partner_id': str(config.get('payment_user_id', '')),
            'key': config.get('payment_token', ''),
            'pay_type': config.get('payment_channel', ''),
            'payment_rate': float(config.get('payment_rate', 1.0)),
        })

        print(f"[Webå¯åŠ¨] å·²åŠ è½½æ”¯ä»˜é…ç½®: URL={PAYMENT_CONFIG.get('api_url', 'æœªè®¾ç½®')}, PartnerID={PAYMENT_CONFIG.get('partner_id', 'æœªè®¾ç½®')}, PayType={PAYMENT_CONFIG.get('pay_type', 'æœªè®¾ç½®')}")
    except Exception as e:
        print(f"[Webå¯åŠ¨] åŠ è½½æ”¯ä»˜é…ç½®å¤±è´¥: {e}")
        # å¦‚æœåŠ è½½å¤±è´¥ï¼Œæ¸…ç©ºé…ç½®
        PAYMENT_CONFIG.update({
            'api_url': '',
            'partner_id': '',
            'key': '',
            'pay_type': '',
            'payment_rate': 1.0,
        })

    # Ensure recharge_records has a remark column for admin notes
    try:
        conn = get_db_conn()
        c = conn.cursor()
        c.execute("PRAGMA table_info(recharge_records)")
        cols = [r[1] for r in c.fetchall()]
        if 'remark' not in cols:
            try:
                c.execute("ALTER TABLE recharge_records ADD COLUMN remark TEXT")
                conn.commit()
            except Exception:
                pass
        conn.close()
    except Exception:
        pass

    print("ğŸŒ Webç®¡ç†åå°å¯åŠ¨ä¸­...")
    try:
        app.run(debug=False, host='0.0.0.0', port=5051, use_reloader=False)
    except Exception as e:
        print(f"âŒ WebæœåŠ¡å™¨å¯åŠ¨å¤±è´¥: {e}")
        import traceback
        traceback.print_exc()
        # ä¸è¦é€€å‡ºï¼Œè®©ç¨‹åºç»§ç»­è¿è¡Œå…¶ä»–æœåŠ¡
        import time
        print("â³ 5ç§’åé‡è¯•å¯åŠ¨WebæœåŠ¡å™¨...")
        time.sleep(5)
        try:
            app.run(debug=False, host='0.0.0.0', port=5051, use_reloader=False)
        except Exception as retry_e:
            print(f"âŒ WebæœåŠ¡å™¨é‡è¯•å¯åŠ¨ä»ç„¶å¤±è´¥: {retry_e}")
            print("ğŸ’¡ è¯·æ£€æŸ¥ç«¯å£5051æ˜¯å¦è¢«å ç”¨ï¼Œæˆ–æ‰‹åŠ¨é‡å¯æœåŠ¡")

__all__ = ['app', 'run_web']


--- File: ./app/config.py ---
"""
é…ç½®æ–‡ä»¶
ç»Ÿä¸€ç®¡ç†é¡¹ç›®è·¯å¾„å’Œé…ç½®
"""
import os
from pathlib import Path

# é¡¹ç›®æ ¹ç›®å½•
BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))

# æ•°æ®ç›®å½•
DATA_DIR = os.path.join(BASE_DIR, 'data')

# æ•°æ®åº“è·¯å¾„
DB_PATH = os.path.join(DATA_DIR, 'bot.db')

# æ—¥å¿—è·¯å¾„
LOG_PATH = os.path.join(DATA_DIR, 'bot.log')

# PIDæ–‡ä»¶è·¯å¾„
PID_PATH = os.path.join(DATA_DIR, 'bot.pid')

# Sessionæ–‡ä»¶è·¯å¾„
SESSION_PATH = os.path.join(DATA_DIR, 'bot.session')

# é™æ€æ–‡ä»¶ä¸Šä¼ ç›®å½•
UPLOAD_DIR = os.path.join(BASE_DIR, 'static', 'uploads')

# Sessionæ–‡ä»¶ç›®å½•ï¼ˆå¤šæœºå™¨äººSessionéš”ç¦»ï¼‰
SESSION_DIR = os.path.join(DATA_DIR, 'sessions')

# ç¡®ä¿æ•°æ®ç›®å½•å­˜åœ¨
os.makedirs(DATA_DIR, exist_ok=True)
os.makedirs(UPLOAD_DIR, exist_ok=True)
os.makedirs(SESSION_DIR, exist_ok=True)

# ... (Rest of file remains same) ...

# ==================== Telegram Bot é…ç½® ====================
# ä» .env æ–‡ä»¶æˆ–ç¯å¢ƒå˜é‡è¯»å–é…ç½®

def load_env_config():
    """ä» .env æ–‡ä»¶åŠ è½½é…ç½®"""
    env_file = os.path.join(BASE_DIR, '.env')
    config = {}
    
    # å¦‚æœå­˜åœ¨ .env æ–‡ä»¶ï¼Œè¯»å–é…ç½®
    if os.path.exists(env_file):
        with open(env_file, 'r', encoding='utf-8') as f:
            for line in f:
                line = line.strip()
                # è·³è¿‡ç©ºè¡Œå’Œæ³¨é‡Š
                if not line or line.startswith('#'):
                    continue
                # è§£æ key=value
                if '=' in line:
                    key, value = line.split('=', 1)
                    key = key.strip()
                    value = value.strip().strip('"').strip("'")
                    config[key] = value
    
    return config

# åŠ è½½ç¯å¢ƒé…ç½®
_env_config = load_env_config()

# Telegram API é…ç½®
# ä¼˜å…ˆä»ç¯å¢ƒå˜é‡è¯»å–ï¼Œå…¶æ¬¡ä» .env æ–‡ä»¶è¯»å–ï¼Œæœ€åä½¿ç”¨é»˜è®¤å€¼
API_ID = int(os.getenv('API_ID') or _env_config.get('API_ID', '21332425'))
API_HASH = os.getenv('API_HASH') or _env_config.get('API_HASH', 'f5d0cddc784e3a7a09ea9714ed01f238')
BOT_TOKEN = os.getenv('BOT_TOKEN') or _env_config.get('BOT_TOKEN', '8520376411:AAHGZMmI-oROPyrxBmDTo7_OCtpy8kHWORc')

# ç®¡ç†å‘˜ ID åˆ—è¡¨
_admin_ids_str = os.getenv('ADMIN_IDS') or _env_config.get('ADMIN_IDS', '7935612165')
ADMIN_IDS = [int(uid.strip()) for uid in _admin_ids_str.split(',') if uid.strip()]

# ä»£ç†é…ç½®
USE_PROXY = (os.getenv('USE_PROXY') or _env_config.get('USE_PROXY', 'False')).lower() == 'true'
PROXY_TYPE = os.getenv('PROXY_TYPE') or _env_config.get('PROXY_TYPE', 'socks5')
PROXY_HOST = os.getenv('PROXY_HOST') or _env_config.get('PROXY_HOST', '127.0.0.1')
PROXY_PORT = int(os.getenv('PROXY_PORT') or _env_config.get('PROXY_PORT', '7897'))

# ==================== Web / Payment å›è°ƒå…¬å…±é…ç½® ====================
# å¯¹å¤–å¯è®¿é—®çš„ç«™ç‚¹æ ¹åœ°å€ï¼ˆå¸¦ç«¯å£ï¼‰ï¼Œç”¨äºæ‹¼æ¥æ”¯ä»˜å›è°ƒ/è·³è½¬ç­‰URLã€‚
# ç¤ºä¾‹:
# - http://1.2.3.4:5051
# - https://your-domain.com
PUBLIC_BASE_URL = (os.getenv('PUBLIC_BASE_URL') or _env_config.get('PUBLIC_BASE_URL', '')).rstrip('/')


--- File: ./app/core_functions.py ---
"""
æ ¸å¿ƒåŠŸèƒ½æ¨¡å—
åŒ…å«ç¾¤ç»„æ£€æµ‹ã€å±‚çº§è®¡ç®—ã€åˆ†çº¢åˆ†é…ç­‰æ ¸å¿ƒé€»è¾‘
"""
import sqlite3
import os
import sys
from datetime import datetime, timedelta, timezone
from telethon import TelegramClient
from telethon.tl.functions.channels import GetParticipantRequest
from telethon.tl.types import ChannelParticipantAdmin, ChannelParticipantCreator

# å¯¼å…¥é…ç½®
BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
sys.path.insert(0, BASE_DIR)
from app.config import DB_PATH

# å®šä¹‰ä¸­å›½æ—¶åŒº
CN_TIMEZONE = timezone(timedelta(hours=8))

def get_cn_time():
    """è·å–ä¸­å›½æ—¶é—´å­—ç¬¦ä¸²"""
    return datetime.now(CN_TIMEZONE).isoformat()

async def verify_group_link(bot, link, clients=None):
    """éªŒè¯ç¾¤é“¾æ¥ï¼Œæ£€æŸ¥æœºå™¨äººæ˜¯å¦åœ¨ç¾¤å†…ä¸”ä¸ºç®¡ç†å‘˜"""
    try:
        # å¿…é¡»æ˜¯ http(s)://t.me/ å¼€å¤´
        if link.startswith('http://t.me/'):
            tail = link.replace('http://t.me/', '').split('?')[0]
        elif link.startswith('https://t.me/'):
            tail = link.replace('https://t.me/', '').split('?')[0]
        else:
            return {'success': False, 'message': 'é“¾æ¥æ ¼å¼ä¸æ­£ç¡®ï¼Œè¯·ä½¿ç”¨ http://t.me/ å¼€å¤´çš„é“¾æ¥'}

        # 1) ç§æœ‰é‚€è¯·é“¾æ¥: +hash æˆ– joinchat/hash
        if tail.startswith('+') or tail.startswith('joinchat/'):
            try:
                from telethon.tl.functions.messages import CheckChatInviteRequest
                from telethon.tl.types import ChatInviteAlready, ChatInvite

                hash_val = tail.replace('+', '').replace('joinchat/', '')

                # ä½¿ç”¨è§¦å‘çš„ bot è¿›è¡Œæ£€æŸ¥
                invite = await bot(CheckChatInviteRequest(hash_val))

                if isinstance(invite, ChatInviteAlready):
                    # æœºå™¨äººå·²ç»åœ¨ç¾¤é‡Œï¼šè·å– Chat å¯¹è±¡å’Œ ID
                    chat = invite.chat
                    return {
                        'success': True,
                        'message': 'éªŒè¯æˆåŠŸï¼Œæœºå™¨äººå·²åœ¨ç¾¤å†…',
                        'admin_checked': True,
                        'group_id': chat.id,
                        'group_name': getattr(chat, 'title', 'æœªå‘½åç¾¤ç»„')
                    }
                elif isinstance(invite, ChatInvite):
                    # æœºå™¨äººä¸åœ¨ç¾¤é‡Œ - å¼ºåˆ¶è¦æ±‚ç”¨æˆ·å…ˆæ‹‰ç¾¤
                    return {
                        'success': False,
                        'message': 'âŒ æœºå™¨äººå°šæœªåŠ å…¥è¯¥ç¾¤ç»„ã€‚\n\nè¯·å…ˆå°†æœºå™¨äººæ‹‰å…¥æ‚¨çš„ç¾¤ç»„ï¼Œå¹¶è®¾ä¸ºç®¡ç†å‘˜ï¼Œç„¶åå†å‘é€é“¾æ¥ã€‚',
                        'admin_checked': False
                    }
            except Exception as e:
                print(f'[ç§æœ‰é“¾æ¥éªŒè¯å¤±è´¥] {e}')
                # è§£æå¤±è´¥ï¼Œæ— æ³•è·å–ID
                return {
                    'success': False,
                    'message': f'âŒ æ— æ³•è§£æè¯¥é“¾æ¥ï¼Œè¯·ç¡®ä¿æœºå™¨äººå·²åœ¨ç¾¤å†…ã€‚\né”™è¯¯: {str(e)}',
                    'admin_checked': False
                }

        # 2) å…¬å¼€ç¾¤ç”¨æˆ·å
        username = tail
        try:
            # å°è¯•è·å–å®ä½“
            entity = await bot.get_entity(username)
            group_id = entity.id
            group_name = getattr(entity, 'title', username)
        except Exception as e:
            print(f'è·å–å®ä½“å¤±è´¥: {e}')
            return {'success': False, 'message': 'âŒ æ— æ³•è®¿é—®è¯¥ç¾¤ï¼Œè¯·ç¡®ä¿æœºå™¨äººå·²åŠ å…¥è¯¥ç¾¤ç»„ã€‚'}

        # æ£€æŸ¥æ˜¯å¦æ˜¯ç¾¤ç»„
        if not hasattr(entity, 'broadcast') or entity.broadcast:
             # æœ‰äº›é¢‘é“ä¹Ÿæ˜¯ broadcast=Trueï¼Œè¿™é‡Œç®€å•è¿‡æ»¤éç¾¤ç»„
             # ä¸¥è°¨ä¸€ç‚¹å¯ä»¥æ£€æŸ¥ class typeï¼Œä½†æš‚ä¸”è¿™æ ·
             pass

        # 3) æ£€æŸ¥æœºå™¨äººæ˜¯å¦åœ¨ç¾¤å†… (å¤šæœºå™¨äººé€»è¾‘)
        if clients and len(clients) > 0:
            is_any_bot_in_group, admin_bot_id = await check_any_bot_in_group(clients, username)

            if not is_any_bot_in_group:
                return {'success': False, 'message': 'âŒ æ²¡æœ‰æœºå™¨äººåŠ å…¥è¯¥ç¾¤ç»„ï¼Œè¯·å…ˆå°†æœºå™¨äººæ‹‰å…¥ç¾¤ç»„ã€‚'}

            return {
                'success': True,
                'message': 'éªŒè¯æˆåŠŸ',
                'admin_checked': (admin_bot_id is not None),
                'group_id': group_id,
                'group_name': group_name
            }
        else:
            # å•æœºå™¨äººé€»è¾‘
            return {
                'success': True,
                'message': 'éªŒè¯æˆåŠŸ',
                'admin_checked': True, # å‡å®šä¸ºçœŸï¼Œåå°å¼‚æ­¥æ£€æµ‹
                'group_id': group_id,
                'group_name': group_name
            }

    except Exception as e:
        print(f'éªŒè¯ç¾¤é“¾æ¥å¤±è´¥: {e}')
        return {'success': False, 'message': f'éªŒè¯å¤±è´¥: {str(e)}'}


async def check_user_in_group(bot, user_id, group_link):
    """
    æ£€æµ‹ç”¨æˆ·æ˜¯å¦åœ¨æŒ‡å®šç¾¤ç»„ä¸­
    
    Args:
        bot: Telegramæœºå™¨äººå®¢æˆ·ç«¯
        user_id: ç”¨æˆ·Telegram ID
        group_link: ç¾¤ç»„é“¾æ¥
    
    Returns:
        bool: Trueè¡¨ç¤ºç”¨æˆ·åœ¨ç¾¤ç»„ä¸­
    """
    try:
        # ä»ç¾¤é“¾æ¥æå–ç¾¤ç»„
        if 'joinchat/' in group_link or 't.me/' in group_link:
            group_entity = await bot.get_entity(group_link)
        else:
            return False
        
        # æ£€æŸ¥ç”¨æˆ·æ˜¯å¦åœ¨ç¾¤ç»„ä¸­
        try:
            participant = await bot(GetParticipantRequest(group_entity, user_id))
            return True
        except:
            return False
    except Exception as e:
        print(f"æ£€æµ‹ç”¨æˆ·æ˜¯å¦åœ¨ç¾¤å¤±è´¥: {e}")
        return False


async def check_bot_is_admin(bot, bot_id, group_link):
    """
    æ£€æµ‹æœºå™¨äººæ˜¯å¦ä¸ºç¾¤ç»„ç®¡ç†å‘˜

    Args:
        bot: Telegramæœºå™¨äººå®¢æˆ·ç«¯
        bot_id: æœºå™¨äººçš„Telegram ID
        group_link: ç¾¤ç»„é“¾æ¥

    Returns:
        bool: Trueè¡¨ç¤ºæœºå™¨äººæ˜¯ç®¡ç†å‘˜
    """
    try:
        group_entity = await bot.get_entity(group_link)

        # è·å–æœºå™¨äººåœ¨ç¾¤ç»„ä¸­çš„èº«ä»½
        participant = await bot(GetParticipantRequest(group_entity, bot_id))

        # æ£€æŸ¥æ˜¯å¦ä¸ºç®¡ç†å‘˜æˆ–åˆ›å»ºè€…
        if isinstance(participant.participant, (ChannelParticipantAdmin, ChannelParticipantCreator)):
            return True
        return False
    except Exception as e:
        print(f"æ£€æµ‹æœºå™¨äººç®¡ç†å‘˜æƒé™å¤±è´¥: {e}")
        return False


async def check_any_bot_in_group(clients, group_link):
    """
    æ£€æŸ¥æ˜¯å¦æœ‰ä»»ä½•æ´»è·ƒçš„æœºå™¨äººåŠ å…¥äº†æŒ‡å®šçš„ç¾¤ç»„

    Args:
        clients: æ´»è·ƒçš„æœºå™¨äººå®¢æˆ·ç«¯åˆ—è¡¨
        group_link: ç¾¤ç»„é“¾æ¥

    Returns:
        tuple: (is_any_bot_in_group, is_admin_bot_id)
               is_any_bot_in_group: æ˜¯å¦æœ‰æœºå™¨äººåŠ å…¥ç¾¤ç»„
               is_admin_bot_id: å¦‚æœæœ‰æœºå™¨äººæ˜¯ç®¡ç†å‘˜ï¼Œè¿”å›å…¶bot_idï¼Œå¦åˆ™ä¸ºNone
    """
    from telethon.tl.types import (
        ChannelParticipantAdmin, ChannelParticipantCreator,
        ChannelParticipant, ChatParticipant, ChatParticipantAdmin, ChatParticipantCreator
    )

    for client in clients:
        try:
            bot_id = (await client.get_me()).id

            # é¦–å…ˆå°è¯•è·å–ç¾¤ç»„å®ä½“
            try:
                group_entity = await client.get_entity(group_link)
            except Exception as entity_err:
                # å¦‚æœè¿å®ä½“éƒ½è·å–ä¸åˆ°ï¼Œè¯´æ˜ï¼š
                # 1. ç¾¤ç»„ä¸å­˜åœ¨
                # 2. ç¾¤ç»„æ˜¯ç§æœ‰çš„ä¸”æœºå™¨äººä¸åœ¨é‡Œé¢
                # 3. æœºå™¨äººè¢«banäº†
                continue

            # å®ä½“è·å–æˆåŠŸï¼Œè¯´æ˜æœºå™¨äººè‡³å°‘çŸ¥é“è¿™ä¸ªç¾¤ç»„
            # ç°åœ¨å°è¯•è·å–æœºå™¨äººåœ¨ç¾¤ç»„ä¸­çš„èº«ä»½
            try:
                participant = await client(GetParticipantRequest(group_entity, bot_id))

                # æ£€æŸ¥æ˜¯å¦åœ¨ç¾¤ç»„ä¸­ï¼ˆåŒ…æ‹¬æ‰€æœ‰ç±»å‹çš„å‚ä¸è€…ï¼‰
                if isinstance(participant.participant, (ChannelParticipantAdmin, ChannelParticipantCreator,
                                                      ChannelParticipant, ChatParticipant,
                                                      ChatParticipantAdmin, ChatParticipantCreator)):
                    # æ£€æŸ¥æ˜¯å¦ä¸ºç®¡ç†å‘˜æˆ–åˆ›å»ºè€…
                    if isinstance(participant.participant, (ChannelParticipantAdmin, ChannelParticipantCreator,
                                                          ChatParticipantAdmin, ChatParticipantCreator)):
                        return True, bot_id  # è¿”å›Trueå’Œç®¡ç†å‘˜bot_id
                    else:
                        return True, None  # åœ¨ç¾¤ç»„ä¸­ä½†ä¸æ˜¯ç®¡ç†å‘˜

            except Exception as participant_err:
                # GetParticipantRequest å¤±è´¥
                # è¿™é€šå¸¸æ„å‘³ç€æœºå™¨äººä¸åœ¨ç¾¤ç»„ä¸­ï¼Œæˆ–è€…æ²¡æœ‰æƒé™æŸ¥çœ‹æˆå‘˜åˆ—è¡¨
                # ç”±äºæˆ‘ä»¬å·²ç»èƒ½è·å–å®ä½“ä½†æ— æ³•è·å–å‚ä¸è€…ä¿¡æ¯ï¼Œæ›´å¯èƒ½çš„æƒ…å†µæ˜¯æœºå™¨äººä¸åœ¨ç¾¤ç»„ä¸­
                # è¿”å› False, None è¡¨ç¤ºä¸åœ¨ç¾¤ç»„ä¸­
                print(f"[æƒé™æ£€æŸ¥] æœºå™¨äºº {bot_id} åœ¨ç¾¤ç»„ä¸­è·å–å‚ä¸è€…ä¿¡æ¯å¤±è´¥ï¼Œå¯èƒ½ä¸åœ¨ç¾¤ç»„ä¸­: {participant_err}")
                return False, None

        except Exception as e:
            # å…¶ä»–å¼‚å¸¸ï¼Œç»§ç»­æ£€æŸ¥ä¸‹ä¸€ä¸ªæœºå™¨äºº
            continue

    return False, None  # æ²¡æœ‰æœºå™¨äººåŠ å…¥ç¾¤ç»„


def get_upline_chain(telegram_id, max_level=10):
    """
    è·å–ç”¨æˆ·çš„ä¸Šçº§é“¾ï¼ˆå‘ä¸ŠNå±‚ï¼‰ï¼Œå¦‚æœä¸Šçº§ä¸è¶³ï¼Œè‡ªåŠ¨ç”¨æ¡æ¼è´¦å·è¡¥é½
    
    Args:
        telegram_id: ç”¨æˆ·Telegram ID
        max_level: æœ€å¤§å±‚çº§æ•°
    
    Returns:
        list: ä¸Šçº§é“¾åˆ—è¡¨ï¼Œæ ¼å¼: [{'level': å±‚çº§, 'id': telegram_id, 'is_fallback': bool}, ...]
    """
    import sys
    import os
    sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
    from app.config import DB_PATH
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    
    upline_chain = []  # æ ¼å¼: [{'level': å±‚çº§, 'id': telegram_id, 'is_fallback': bool}]
    current_id = telegram_id
    
    # 1. å…ˆæ‰¾çœŸå®çš„æ¨èäººé“¾æ¡
    for level in range(1, max_level + 1):
        c.execute('SELECT referrer_id FROM members WHERE telegram_id = ?', (current_id,))
        row = c.fetchone()
        
        if row and row[0]:
            # æ‰¾åˆ°çœŸå®ä¸Šçº§
            upline_chain.append({'level': level, 'id': row[0], 'is_fallback': False})
            current_id = row[0]
        else:
            # æ²¡æœ‰ä¸Šçº§äº†ï¼Œåœæ­¢æŸ¥æ‰¾çœŸå®ä¸Šçº§
            break
    
    # 2. å¦‚æœå±‚æ•°ä¸è¶³ï¼Œç”¨æ¡æ¼è´¦å·è¡¥é½
    current_chain_len = len(upline_chain)
    needed_count = max_level - current_chain_len
    
    if needed_count > 0:
        # è·å–æ‰€æœ‰æ¿€æ´»çš„æ¡æ¼è´¦å·ï¼ŒæŒ‰IDæ’åº
        c.execute('SELECT telegram_id FROM fallback_accounts WHERE is_active = 1 ORDER BY id ASC')
        fallback_rows = c.fetchall()
        # è¿‡æ»¤æ‰ None å€¼ï¼Œç¡®ä¿å…¨æ˜¯æœ‰æ•ˆçš„ ID
        fallback_ids = [r[0] for r in fallback_rows if r[0] is not None]
        
        if fallback_ids:
            # ä»ä¸‹ä¸€å±‚å¼€å§‹è¡¥
            start_level = current_chain_len + 1
            for i in range(needed_count):
                current_level = start_level + i
                # å¾ªç¯ä½¿ç”¨æ¡æ¼è´¦å·: ç¬¬1ä¸ªè¡¥ä½ç”¨ç¬¬1ä¸ªè´¦å·ï¼Œç¬¬2ä¸ªç”¨ç¬¬2ä¸ª...
                # ä½¿ç”¨å–ä½™ç®—æ³•å®ç°å¾ªç¯åˆ†é…
                fb_id = fallback_ids[i % len(fallback_ids)]
                
                upline_chain.append({
                    'level': current_level, 
                    'id': fb_id, 
                    'is_fallback': True
                })
        else:
            print(f'[get_upline_chain] è­¦å‘Š: æ•°æ®åº“ä¸­æ²¡æœ‰æ¿€æ´»çš„æ¡æ¼è´¦å·ï¼Œæ— æ³•è¡¥è¶³ {needed_count} å±‚')
    
    conn.close()
    return upline_chain


def get_downline_tree(telegram_id, max_level=10):
    """
    è·å–ç”¨æˆ·çš„ä¸‹çº§æ ‘ï¼ˆå‘ä¸‹Nå±‚ï¼‰
    
    Args:
        telegram_id: ç”¨æˆ·Telegram ID
        max_level: æœ€å¤§å±‚çº§æ•°
    
    Returns:
        dict: ä¸‹çº§æ ‘ç»“æ„ {å±‚çº§: [ç”¨æˆ·åˆ—è¡¨]}
    """
    import sys
    import os
    sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
    from app.config import DB_PATH
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    
    downline_tree = {}
    current_level_ids = [telegram_id]
    
    for level in range(1, max_level + 1):
        if not current_level_ids:
            break
        
        # æŸ¥è¯¢å½“å‰å±‚çº§æ‰€æœ‰ç”¨æˆ·çš„ç›´æ¨ä¸‹çº§
        placeholders = ','.join(['?'] * len(current_level_ids))
        c.execute(f'''
            SELECT telegram_id, username, is_vip, register_time
            FROM members
            WHERE referrer_id IN ({placeholders})
        ''', current_level_ids)
        
        downlines = c.fetchall()
        if downlines:
            downline_tree[level] = [
                {
                    'telegram_id': row[0],
                    'username': row[1],
                    'is_vip': row[2],
                    'register_time': row[3]
                }
                for row in downlines
            ]
            # å‡†å¤‡ä¸‹ä¸€å±‚çš„æŸ¥è¯¢
            current_level_ids = [row[0] for row in downlines]
        else:
            break
    
    conn.close()
    return downline_tree


def calculate_team_stats(telegram_id, max_level=10):
    """
    è®¡ç®—å›¢é˜Ÿç»Ÿè®¡æ•°æ®
    
    Args:
        telegram_id: ç”¨æˆ·Telegram ID
        max_level: æœ€å¤§å±‚çº§æ•°
    
    Returns:
        dict: {'direct_count': ç›´æ¨äººæ•°, 'team_count': å›¢é˜Ÿæ€»äººæ•°, 'vip_count': VIPäººæ•°}
    """
    import sys
    import os
    sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
    from app.config import DB_PATH
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    
    # ç›´æ¨äººæ•°
    c.execute('SELECT COUNT(*) FROM members WHERE referrer_id = ?', (telegram_id,))
    direct_count = c.fetchone()[0]
    
    # å›¢é˜Ÿæ€»äººæ•°ï¼ˆé€’å½’æŸ¥è¯¢æ‰€æœ‰ä¸‹çº§ï¼‰
    team_count = 0
    vip_count = 0
    
    downline_tree = get_downline_tree(telegram_id, max_level)
    for level_users in downline_tree.values():
        team_count += len(level_users)
        vip_count += sum(1 for u in level_users if u['is_vip'])
    
    conn.close()
    return {
        'direct_count': direct_count,
        'team_count': team_count,
        'vip_count': vip_count
    }


async def check_user_conditions(bot, telegram_id):
    """
    æ£€æŸ¥ç”¨æˆ·æ˜¯å¦æ»¡è¶³æ‰€æœ‰æ¡ä»¶
    
    Returns:
        dict: {
            'is_vip': bool,
            'is_group_bound': bool,
            'is_bot_admin': bool,
            'is_joined_upline': bool,
            'missing_conditions': []  # æœªæ»¡è¶³çš„æ¡ä»¶åˆ—è¡¨
        }
    """
    import sys
    import os
    sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
    from app.config import DB_PATH
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    
    c.execute('''
        SELECT is_vip, is_group_bound, is_bot_admin, is_joined_upline, group_link
        FROM members WHERE telegram_id = ?
    ''', (telegram_id,))
    row = c.fetchone()
    conn.close()
    
    if not row:
        return None
    
    is_vip, is_group_bound, is_bot_admin, is_joined_upline, group_link = row
    
    missing_conditions = []
    if not is_vip:
        missing_conditions.append('æœªå¼€é€šVIP')
    if not is_group_bound:
        missing_conditions.append('æœªç»‘å®šç¾¤ç»„')
    if not is_bot_admin:
        missing_conditions.append('æœªè®¾ç½®æœºå™¨äººä¸ºç®¡ç†å‘˜')
    if not is_joined_upline:
        missing_conditions.append('æœªåŠ å…¥ä¸Šå±‚æ‰€æœ‰ç¾¤ç»„')
    
    return {
        'is_vip': bool(is_vip),
        'is_group_bound': bool(is_group_bound),
        'is_bot_admin': bool(is_bot_admin),
        'is_joined_upline': bool(is_joined_upline),
        'group_link': group_link or '',
        'missing_conditions': missing_conditions,
        'all_conditions_met': len(missing_conditions) == 0
    }


def update_level_path(telegram_id):
    """
    æ›´æ–°ç”¨æˆ·çš„å±‚çº§è·¯å¾„
    
    Args:
        telegram_id: ç”¨æˆ·Telegram ID
    """
    import sys
    import os
    sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
    from app.config import DB_PATH
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    
    # è·å–ä¸Šçº§é“¾
    path = []
    current_id = telegram_id
    
    for _ in range(20):  # æœ€å¤š20å±‚
        c.execute('SELECT referrer_id FROM members WHERE telegram_id = ?', (current_id,))
        row = c.fetchone()
        if not row or not row[0]:
            break
        path.insert(0, str(row[0]))
        current_id = row[0]
    
    level_path = ','.join(path) if path else ''
    
    # æ›´æ–°level_pathå­—æ®µ
    c.execute('UPDATE members SET level_path = ? WHERE telegram_id = ?', (level_path, telegram_id))
    conn.commit()
    conn.close()


def get_fallback_account(level):
    """
    è·å–æŒ‡å®šå±‚çº§çš„æ¡æ¼è´¦å·

    Args:
        level: å±‚çº§æ•° (1-10)

    Returns:
        int: æ¡æ¼è´¦å·çš„telegram_id
    """
    import sys
    import os
    sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
    from app.config import DB_PATH
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()

    # æŒ‰é¡ºåºè·å–æ¡æ¼è´¦å·
    c.execute('SELECT telegram_id FROM fallback_accounts WHERE is_active = 1 ORDER BY id LIMIT 1 OFFSET ?',
             (level - 1,))
    row = c.fetchone()
    conn.close()

    return row[0] if row else None


# ã€æ–°å¢ã€‘ç”ŸæˆVIPå¼€é€šæˆåŠŸåçš„è¯¦ç»†æ–‡æ¡ˆ
def generate_vip_success_message(telegram_id, amount, vip_price, current_balance):
    """ç”Ÿæˆç¬¦åˆè¦æ±‚çš„VIPå¼€é€šæ–‡æ¡ˆ"""
    try:
        from app.config import DB_PATH
        conn = sqlite3.connect(DB_PATH)
        c = conn.cursor()

        # è·å–ç³»ç»Ÿé…ç½®çš„å±‚æ•°
        c.execute("SELECT value FROM system_config WHERE key = 'level_count'")
        row = c.fetchone()
        level_count = int(row[0]) if row else 10
        conn.close()

        # è·å–ä¸Šçº§ç¾¤åˆ—è¡¨
        upline_chain = get_upline_chain(telegram_id, level_count)
        upline_groups_text = ""
        group_count = 0

        # å†æ¬¡è¿æ¥è·å–ä¸Šçº§è¯¦ç»†ä¿¡æ¯
        conn = sqlite3.connect(DB_PATH)
        c = conn.cursor()

        for item in upline_chain:
            if item.get('is_fallback'): continue # è·³è¿‡æ¡æ¼è´¦å·çš„ç¾¤

            uid = item['id']
            lvl = item['level']
            c.execute("SELECT username, group_link FROM members WHERE telegram_id = ?", (uid,))
            u_row = c.fetchone()

            if u_row and u_row[1]: # æœ‰ç¾¤é“¾æ¥
                # ç®€å•å¤„ç†ç¾¤å
                g_link = u_row[1]
                u_name = u_row[0] or f"ç”¨æˆ·{uid}"
                upline_groups_text += f"{lvl}. @{u_name}çš„ç¾¤\n"
                group_count += 1

        conn.close()

        msg = (
            f"ğŸ‰ å……å€¼æˆåŠŸï¼VIPå·²å¼€é€šï¼\n\n"
            f"ğŸ’° å……å€¼é‡‘é¢: {amount} U\n"
            f"ğŸ’ VIPè´¹ç”¨: {vip_price} U\n"
            f"ğŸ’µ å½“å‰ä½™é¢: {current_balance} U\n\n"
            f"âš ï¸ é‡è¦ï¼šè¯·ç«‹å³å®Œæˆä»¥ä¸‹æ“ä½œ\n\n"
            f"1ï¸âƒ£ ç»‘å®šæ‚¨çš„ç¾¤ç»„\n"
            f"2ï¸âƒ£ åŠ å…¥ä¸Šå±‚ç¾¤ç»„ï¼ˆå…±{group_count}ä¸ªï¼‰\n"
            f"{upline_groups_text}\n"
            f"å®Œæˆä»¥ä¸Šæ“ä½œåï¼Œæ‚¨çš„ä¸‹çº§å¼€é€šVIPæ—¶\n"
            f"æ‚¨æ‰èƒ½è·å¾—åˆ†çº¢ï¼"
        )
        return msg
    except Exception as e:
        print(f"[ç”Ÿæˆæ–‡æ¡ˆé”™è¯¯] {e}")
        return f"ğŸ‰ VIPå¼€é€šæˆåŠŸï¼\nèŠ±è´¹: {vip_price}U\nä½™é¢: {current_balance}U"


async def distribute_vip_rewards(bot, telegram_id, pay_amount, config):
    """
    ç»Ÿä¸€å¤„ç†VIPå¼€é€šåçš„åˆ†çº¢é€»è¾‘ï¼ˆç»ˆæä¿®å¤ç‰ˆï¼šå…¨é“¾è·¯å»é‡ + è¯¦ç»†è¯´æ˜è®°å½•ï¼‰
    """
    import sys
    import os
    sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
    from app.config import DB_PATH

    level_count = int(config.get('level_count', 10))
    reward_amount = float(config.get('level_reward', 1))

    chain = get_upline_chain(telegram_id, level_count)

    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    c.execute('SELECT username FROM members WHERE telegram_id = ?', (telegram_id,))
    user_row = c.fetchone()
    source_username = user_row[0] if user_row else str(telegram_id)
    conn.close()

    reward_stats = {'real': 0, 'fallback': 0}

    # è®°å½•æœ¬è½®å·²è·å¾—å¥–åŠ±çš„è´¦å·IDï¼ˆåŒ…æ‹¬çœŸå®ç”¨æˆ·å’Œæ¡æ¼è´¦å·ï¼‰
    used_ids_in_this_round = set()

    # é¢„å…ˆåŠ è½½æ‰€æœ‰æ´»è·ƒæ¡æ¼è´¦å·ï¼ˆæŒ‰IDæ’åºï¼‰
    conn = sqlite3.connect(DB_PATH)
    c = conn.cursor()
    c.execute('SELECT telegram_id FROM fallback_accounts WHERE is_active = 1 ORDER BY id ASC')
    all_fb_rows = c.fetchall()
    all_valid_fbs = [r[0] for r in all_fb_rows if r[0] is not None]
    conn.close()

    for item in chain:
        level = item['level']
        upline_id = item['id']
        is_fallback_in_chain = item['is_fallback']

        if not upline_id or str(upline_id) == 'None': continue

        conn = sqlite3.connect(DB_PATH, timeout=10)
        c = conn.cursor()

        try:
            target_id_to_reward = None
            is_rewarding_fallback = False

            # ã€å…³é”®ä¿®æ”¹ã€‘ç”¨äºå­˜å‚¨å…·ä½“çš„å¤±è´¥åŸå› æè¿°
            record_description = ""
            # --- æ­¥éª¤Aï¼šç¡®å®šè¿™ä¸€å±‚çš„åŸå§‹æ¥æ”¶è€… ---
            if is_fallback_in_chain:
                # é“¾æ¡æœ¬èº«å°±æ˜¯æ¡æ¼è´¦å·ï¼ˆè¯´æ˜è¿™ä¸€å±‚æ²¡æœ‰çœŸå®ä¸Šçº§ï¼‰
                candidate_id = upline_id
                is_rewarding_fallback = True
                record_description = f"ç¬¬{level}å±‚æ— ä¸Šçº§ï¼ˆè‡ªåŠ¨æ¡æ¼ï¼‰"
            else:
                # çœŸå®ç”¨æˆ·ï¼Œæ£€æŸ¥æ¡ä»¶
                c.execute('SELECT username, is_vip, is_group_bound, is_bot_admin, is_joined_upline FROM members WHERE telegram_id = ?', (upline_id,))
                row = c.fetchone()

                # è·å–ä¸Šçº§æ˜¾ç¤ºåç§°
                upline_name = str(upline_id)
                if row and row[0]:
                    upline_name = f"@{row[0]}"

                if row and row[1] and row[2] and row[3] and row[4]:
                    # çœŸå®ç”¨æˆ·è¾¾æ ‡
                    candidate_id = upline_id
                    is_rewarding_fallback = False
                    record_description = f"ç¬¬{level}å±‚ä¸‹çº§å¼€é€šVIP"
                else:
                    # çœŸå®ç”¨æˆ·ä¸è¾¾æ ‡
                    candidate_id = None
                    is_rewarding_fallback = True

                    # ã€å…³é”®ä¿®æ”¹ã€‘æ„å»ºè¯¦ç»†çš„å¤±è´¥åŸå› 
                    fail_reasons = []
                    if not row:
                        fail_reasons.append("ç”¨æˆ·ä¸å­˜åœ¨")
                    else:
                        if not row[1]: fail_reasons.append("æœªVIP")
                        if not row[2]: fail_reasons.append("æœªç»‘ç¾¤")
                        if not row[3]: fail_reasons.append("æœªè®¾ç½®ç¾¤ç®¡")
                        if not row[4]: fail_reasons.append("æœªåŠ ç¾¤")

                    reason_str = ",".join(fail_reasons)
                    # è¿™é‡Œçš„æ ¼å¼å°±æ˜¯æ‚¨æƒ³è¦çš„ï¼šæ˜¾ç¤ºå…·ä½“å“ªä¸ªä¸Šçº§æ²¡å®Œæˆ
                    record_description = f"ä¸Šçº§ {upline_name} {reason_str}ï¼ˆè½¬å…¥æ¡æ¼ï¼‰"
                    # è®°å½•é”™è¿‡æ”¶ç›Šé€šçŸ¥
                    if row:
                        c.execute('UPDATE members SET missed_balance = missed_balance + ? WHERE telegram_id = ?',
                                 (reward_amount, upline_id))
                        # å‘é€é€šçŸ¥ç»™é‚£ä¸ªä¸äº‰æ°”çš„ä¸Šçº§
                        try:
                            await bot.send_message(
                                upline_id,
                                f"ğŸ’¸ **é”™å¤±æ”¶ç›Šé€šçŸ¥**\n\n"
                                f"æ‚¨é”™è¿‡äº† {reward_amount} U çš„æ”¶ç›Šï¼\n"
                                f"åŸå› : {reason_str}\n"
                                f"æ¥æº: ä¸‹çº§ @{source_username} (ç¬¬{level}å±‚) å¼€é€šVIP\n\n"
                                f"è¯·å°½å¿«å®Œæˆä»»åŠ¡ï¼Œä»¥å…å†æ¬¡é”™è¿‡ï¼"
                            )
                        except: pass

            # --- æ­¥éª¤Bï¼šå¦‚æœéœ€è¦æ¡æ¼ï¼Œå¯»æ‰¾æ›¿è¡¥ ---
            if is_rewarding_fallback:
                start_index = (level - 1) % len(all_valid_fbs) if all_valid_fbs else 0
                found_fb = None

                # ä¼˜å…ˆæ£€æŸ¥ chain è‡ªå¸¦çš„é‚£ä¸ªæ¡æ¼å·
                if candidate_id and candidate_id in all_valid_fbs and candidate_id not in used_ids_in_this_round:
                    found_fb = candidate_id
                else:
                    # è½®è¯¢æŸ¥æ‰¾
                    if all_valid_fbs:
                        for i in range(len(all_valid_fbs)):
                            idx = (start_index + i) % len(all_valid_fbs)
                            fb_candidate = all_valid_fbs[idx]
                            if fb_candidate not in used_ids_in_this_round:
                                found_fb = fb_candidate
                                break
                        if found_fb is None: found_fb = all_valid_fbs[start_index]

                target_id_to_reward = found_fb
            else:
                target_id_to_reward = candidate_id

            # --- æ­¥éª¤Cï¼šæ‰§è¡Œå‘æ”¾ ---
            if target_id_to_reward:
                # ç¡®ä¿è´¦å·å­˜åœ¨
                if is_rewarding_fallback:
                    c.execute('SELECT id FROM members WHERE telegram_id = ?', (target_id_to_reward,))
                    if not c.fetchone():
                        c.execute('SELECT username FROM fallback_accounts WHERE telegram_id = ?', (target_id_to_reward,))
                        fb_name = c.fetchone()
                        name = fb_name[0] if fb_name else f'fallback_{target_id_to_reward}'
                        c.execute('INSERT OR IGNORE INTO members (telegram_id, username, is_vip, register_time) VALUES (?, ?, 1, ?)',
                                 (target_id_to_reward, name, get_cn_time()))

                    c.execute('UPDATE fallback_accounts SET total_earned = total_earned + ? WHERE telegram_id = ?',
                             (reward_amount, target_id_to_reward))
                    reward_stats['fallback'] += 1
                else:
                    reward_stats['real'] += 1

                used_ids_in_this_round.add(int(target_id_to_reward))

                # æ›´æ–°ä½™é¢
                c.execute('UPDATE members SET balance = balance + ?, total_earned = total_earned + ? WHERE telegram_id = ?',
                         (reward_amount, reward_amount, target_id_to_reward))

                # ã€å…³é”®ä¿®æ”¹ã€‘å†™å…¥æ•°æ®åº“æ—¶ä½¿ç”¨ä¸Šé¢æ„å»ºå¥½çš„è¯¦ç»†è¯´æ˜
                c.execute('''INSERT INTO earnings_records (upgraded_user, earning_user, amount, description, create_time)
                           VALUES (?, ?, ?, ?, ?)''',
                           (telegram_id, target_id_to_reward, reward_amount, record_description, get_cn_time()))

                # é€šçŸ¥
                if not is_rewarding_fallback:
                    try:
                        await bot.send_message(target_id_to_reward,
                            f'ğŸ‰ è·å¾— {reward_amount} U å¥–åŠ±\n\næ¥æºï¼šç¬¬ {level} å±‚ä¸‹çº§ @{source_username} å¼€é€šVIP\n\nå¿«å»è”ç³»ä»–å¸¦é¢†ä»–ä¸€èµ·å‘å±•å›¢é˜Ÿ')
                    except: pass

            conn.commit()
        except Exception as e:
            print(f"[åˆ†çº¢åˆ†é…é”™è¯¯] Level {level}: {e}")
        finally:
            conn.close()

    return reward_stats

--- File: ./app/database.py ---
"""
æ•°æ®åº“å±‚ - ç»Ÿä¸€ç®¡ç†æ‰€æœ‰æ•°æ®åº“æ“ä½œ
"""
import sqlite3
import time
import os
import sys
from datetime import datetime, timedelta, timezone
from werkzeug.security import generate_password_hash
from flask_login import UserMixin

# å…¼å®¹ä¸åŒå¯¼å…¥æ–¹å¼
try:
    # ä¼˜å…ˆå°è¯•ä» app.config å¯¼å…¥ï¼ˆå½“ä½œä¸ºæ¨¡å—å¯¼å…¥æ—¶ï¼‰
    from app.config import DB_PATH
except ImportError:
    try:
        # å°è¯•ä» config å¯¼å…¥ï¼ˆå½“åœ¨ app ç›®å½•ä¸‹ç›´æ¥è¿è¡Œæ—¶ï¼‰
        from config import DB_PATH
    except ImportError:
        # å¦‚æœéƒ½å¤±è´¥ï¼Œä½¿ç”¨ç›¸å¯¹è·¯å¾„è®¡ç®—
        BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
        DATA_DIR = os.path.join(BASE_DIR, 'data')
        DB_PATH = os.path.join(DATA_DIR, 'bot.db')

# å®šä¹‰ä¸­å›½æ—¶åŒº
CN_TIMEZONE = timezone(timedelta(hours=8))

def get_cn_time():
    """è·å–ä¸­å›½æ—¶é—´å­—ç¬¦ä¸²"""
    return datetime.now(CN_TIMEZONE).isoformat()

def get_db_conn():
    """è·å–æ•°æ®åº“è¿æ¥ï¼Œè®¾ç½®è¶…æ—¶å’Œ WAL æ¨¡å¼ä»¥é¿å…é”å®š"""
    conn = sqlite3.connect(DB_PATH, timeout=10.0)
    conn.execute('PRAGMA journal_mode=WAL')
    conn.execute('PRAGMA busy_timeout=10000')
    return conn

def init_db():
    """åˆå§‹åŒ–æ•°æ®åº“è¡¨ç»“æ„"""
    conn = get_db_conn()
    c = conn.cursor()
    
    # ä¼šå‘˜è¡¨
    c.execute('''CREATE TABLE IF NOT EXISTS members (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        telegram_id INTEGER UNIQUE,
        username TEXT,
        backup_account TEXT,
        referrer_id INTEGER,
        balance REAL DEFAULT 0,
        missed_balance REAL DEFAULT 0,
        group_link TEXT,
        is_vip INTEGER DEFAULT 0,
        register_time TEXT,
        vip_time TEXT,
        is_group_bound INTEGER DEFAULT 0,
        is_bot_admin INTEGER DEFAULT 0,
        is_joined_upline INTEGER DEFAULT 0,
        level_path TEXT,
        direct_count INTEGER DEFAULT 0,
        team_count INTEGER DEFAULT 0,
        total_earned REAL DEFAULT 0,
        withdraw_address TEXT,
        FOREIGN KEY (referrer_id) REFERENCES members(telegram_id)
    )''')
    
    # å®¢æœè¡¨
    c.execute('''CREATE TABLE IF NOT EXISTS customer_service (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        name TEXT,
        link TEXT
    )''')
    
    # è¡Œä¸šèµ„æºåˆ†ç±»è¡¨
    c.execute('''CREATE TABLE IF NOT EXISTS resource_categories (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        name TEXT,
        parent_id INTEGER DEFAULT 0
    )''')
    
    # è¡Œä¸šèµ„æºè¡¨
    c.execute('''CREATE TABLE IF NOT EXISTS resources (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        category_id INTEGER,
        name TEXT,
        link TEXT,
        type TEXT,
        member_count INTEGER DEFAULT 0,
        FOREIGN KEY (category_id) REFERENCES resource_categories(id)
    )''')
    
    # æç°è®°å½•è¡¨
    c.execute('''CREATE TABLE IF NOT EXISTS withdrawals (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        member_id INTEGER,
        amount REAL,
        usdt_address TEXT,
        status TEXT DEFAULT 'pending',
        create_time TEXT,
        process_time TEXT,
        FOREIGN KEY (member_id) REFERENCES members(telegram_id)
    )''')
    
    # ç³»ç»Ÿé…ç½®è¡¨
    c.execute('''CREATE TABLE IF NOT EXISTS system_config (
        key TEXT PRIMARY KEY,
        value TEXT
    )''')

    # ç®¡ç†å‘˜è¡¨
    c.execute('''CREATE TABLE IF NOT EXISTS admin_users (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        username TEXT UNIQUE,
        password_hash TEXT
    )''')
    
    # æ”¶ç›Šè®°å½•è¡¨ï¼ˆè®°å½•è°è§¦å‘å‡çº§ã€å“ªä¸ªç”¨æˆ·è·å¾—æ”¶ç›Šã€é‡‘é¢ã€è¯´æ˜ã€æ—¶é—´ï¼‰
    c.execute('''CREATE TABLE IF NOT EXISTS earnings_records (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        upgraded_user INTEGER,     -- å‡çº§çš„å‘èµ·è€…ï¼ˆè°å¼€é€š/å‡çº§é€ æˆåˆ†çº¢ï¼‰
        earning_user INTEGER,      -- è·å¾—æ”¶ç›Šçš„ç”¨æˆ·ï¼ˆæ”¶åˆ°åˆ†çº¢çš„è´¦æˆ·ï¼‰
        amount REAL,
        description TEXT,
        create_time TEXT,
        FOREIGN KEY (earning_user) REFERENCES members(telegram_id)
    )''')
    
    # å……å€¼è®°å½•è¡¨
    c.execute('''CREATE TABLE IF NOT EXISTS recharge_records (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        member_id INTEGER,
        amount REAL,
        order_id TEXT,
        status TEXT,
        payment_method TEXT,
        create_time TEXT,
        FOREIGN KEY (member_id) REFERENCES members(telegram_id)
    )''')
    
    # æ¡æ¼è´¦å·è¡¨
    c.execute('''CREATE TABLE IF NOT EXISTS fallback_accounts (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        telegram_id INTEGER UNIQUE,
        username TEXT,
        group_link TEXT,
        total_earned REAL DEFAULT 0,
        is_active INTEGER DEFAULT 1,
        main_account_id INTEGER
    )''')

    # ç¾¤å‘é˜Ÿåˆ—è¡¨
    c.execute('''CREATE TABLE IF NOT EXISTS broadcast_queue (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        group_link TEXT,
        group_name TEXT,
        message TEXT,
        status TEXT DEFAULT 'pending',
        result TEXT,
        create_time TEXT
    )''')

    # ç¾¤å‘æ¶ˆæ¯è¡¨
    c.execute('''CREATE TABLE IF NOT EXISTS broadcast_messages (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        title TEXT,
        content TEXT,
        media_type TEXT,
        media_url TEXT,
        image_url TEXT,
        video_url TEXT,
        buttons TEXT,
        buttons_per_row INTEGER DEFAULT 2,
        schedule_enabled INTEGER DEFAULT 0,
        schedule_time TEXT,
        is_active INTEGER DEFAULT 1,
        create_time TEXT
    )''')

    # ç¾¤å‘åˆ†é…è¡¨ï¼šè®°å½•å“ªäº›ç¾¤è¢«åˆ†é…äº†å“ªäº›ç¾¤å‘å†…å®¹ï¼Œä»¥åŠå¯ç”¨çŠ¶æ€å’Œæœ€åå‘é€æ—¶é—´
    c.execute('''CREATE TABLE IF NOT EXISTS broadcast_assignments (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        group_id INTEGER,
        message_id INTEGER,
        is_active INTEGER DEFAULT 1,
        create_time TEXT,
        last_sent_time TEXT,
        FOREIGN KEY (group_id) REFERENCES member_groups(id),
        FOREIGN KEY (message_id) REFERENCES broadcast_messages(id)
    )''')

    # ä¼šå‘˜ç¾¤ç»„è¡¨
    c.execute('''CREATE TABLE IF NOT EXISTS member_groups (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        telegram_id INTEGER,
        group_id INTEGER,
        group_name TEXT,
        group_link TEXT,
        member_count INTEGER DEFAULT 0,
        bot_id INTEGER,
        is_bot_admin INTEGER DEFAULT 0,
        owner_username TEXT,
        group_type TEXT DEFAULT 'group',
        schedule_broadcast INTEGER DEFAULT 1,
        create_time TEXT,
        FOREIGN KEY (telegram_id) REFERENCES members(telegram_id)
    )''')
    
    # ç¾¤å‘æ—¥å¿—è¡¨
    c.execute('''CREATE TABLE IF NOT EXISTS broadcast_logs (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        message_id INTEGER,
        group_ids TEXT,
        status TEXT DEFAULT 'pending',
        sent_count INTEGER DEFAULT 0,
        failed_count INTEGER DEFAULT 0,
        create_time TEXT
    )''')
    
    # å¹¿å‘Šè¡¨
    c.execute('''CREATE TABLE IF NOT EXISTS advertisements (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        title TEXT,
        content TEXT,
        position TEXT DEFAULT 'top',
        is_active INTEGER DEFAULT 1,
        create_time TEXT
    )''')
    
    # æ¬¢è¿è¯­è¡¨
    c.execute('''CREATE TABLE IF NOT EXISTS welcome_messages (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        group_id TEXT,
        message TEXT,
        is_active INTEGER DEFAULT 1,
        create_time TEXT
    )''')
    
    # æœºå™¨äººé…ç½®è¡¨
    c.execute('''CREATE TABLE IF NOT EXISTS bot_configs (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        bot_token TEXT,
        bot_username TEXT,
        is_active INTEGER DEFAULT 1,
        api_id INTEGER,
        api_hash TEXT,
        create_time TEXT
    )''')

    # æ£€æŸ¥æ˜¯å¦æœ‰ç®¡ç†å‘˜ï¼Œå¦‚æœæ²¡æœ‰åˆ™åˆ›å»ºé»˜è®¤ç®¡ç†å‘˜
    c.execute('SELECT COUNT(*) FROM admin_users')
    if c.fetchone()[0] == 0:
        default_password_hash = generate_password_hash('admin')
        c.execute('INSERT INTO admin_users (username, password_hash) VALUES (?, ?)', ('admin', default_password_hash))
        print('âš ï¸ åˆ›å»ºé»˜è®¤ç®¡ç†å‘˜è´¦å·: admin / admin')
    
    conn.commit()
    conn.close()

# æ•°æ®åº“æ“ä½œç±»
class DB:
    @staticmethod
    def get_conn():
        """è·å–æ•°æ®åº“è¿æ¥"""
        return get_db_conn()
    
    @staticmethod
    def get_member(telegram_id):
        """è·å–ä¼šå‘˜ä¿¡æ¯"""
        conn = DB.get_conn()
        c = conn.cursor()
        c.execute('''
            SELECT 
                id, telegram_id, username, backup_account, referrer_id,
                balance, missed_balance, group_link, is_vip, register_time, vip_time,
                is_group_bound, is_bot_admin, is_joined_upline, level_path,
                direct_count, team_count, total_earned, withdraw_address
            FROM members WHERE telegram_id = ?
        ''', (telegram_id,))
        row = c.fetchone()
        conn.close()
        if row:
            return {
                'id': row[0], 'telegram_id': row[1], 'username': row[2],
                'backup_account': row[3], 'referrer_id': row[4], 'balance': row[5],
                'missed_balance': row[6], 'group_link': row[7], 'is_vip': row[8],
                'register_time': row[9], 'vip_time': row[10],
                'is_group_bound': row[11], 'is_bot_admin': row[12],
                'is_joined_upline': row[13], 'level_path': row[14],
                'direct_count': row[15], 'team_count': row[16],
                'total_earned': row[17], 'withdraw_address': row[18]
            }
        return None
    
    @staticmethod
    def create_member(telegram_id, username, referrer_id=None):
        """åˆ›å»ºä¼šå‘˜è®°å½•ï¼Œå¸¦é‡è¯•"""
        max_retries = 5
        for retry in range(max_retries):
            conn = DB.get_conn()
            c = conn.cursor()
            try:
                c.execute(
                    '''INSERT INTO members (telegram_id, username, referrer_id, register_time)
                        VALUES (?, ?, ?, ?)''',
                    (telegram_id, username, referrer_id, get_cn_time())
                )
                conn.commit()
                conn.close()
                return True
            except sqlite3.IntegrityError:
                conn.close()
                return True
            except sqlite3.OperationalError as e:
                conn.close()
                if 'locked' in str(e).lower() and retry < max_retries - 1:
                    time.sleep(0.2)
                    continue
                return False
            except Exception:
                conn.close()
                return False
        return False
    
    @staticmethod
    def update_member(telegram_id, **kwargs):
        """æ›´æ–°ä¼šå‘˜ä¿¡æ¯"""
        conn = DB.get_conn()
        c = conn.cursor()
        sets = ', '.join([f'{k} = ?' for k in kwargs.keys()])
        values = list(kwargs.values()) + [telegram_id]
        c.execute(f'UPDATE members SET {sets} WHERE telegram_id = ?', values)
        conn.commit()
        conn.close()
    
    @staticmethod
    def get_upline_members(telegram_id, levels=10):
        """è·å–ä¸ŠNå±‚æ¨èäººï¼ˆå·²åºŸå¼ƒï¼Œè¯·ä½¿ç”¨ core_functions.get_upline_chainï¼‰"""
        members = []
        conn = DB.get_conn()
        c = conn.cursor()
        current_id = telegram_id
        
        for _ in range(levels):
            c.execute('SELECT referrer_id FROM members WHERE telegram_id = ?', (current_id,))
            row = c.fetchone()
            if row and row[0]:
                c.execute('SELECT telegram_id, username, is_vip, balance FROM members WHERE telegram_id = ?', (row[0],))
                member_row = c.fetchone()
                if member_row:
                    members.append({
                        'telegram_id': member_row[0],
                        'username': member_row[1],
                        'is_vip': member_row[2],
                        'balance': member_row[3]
                    })
                    current_id = row[0]
                else:
                    break
            else:
                break
        conn.close()
        return members
    
    @staticmethod
    def get_downline_count(telegram_id, level=1):
        """è·å–ä¸‹Nå±‚ä¼šå‘˜æ•°é‡"""
        conn = DB.get_conn()
        c = conn.cursor()
        
        current_level_ids = [telegram_id]
        counts = []
        
        for _ in range(level):
            if not current_level_ids:
                counts.append({'total': 0, 'vip': 0})
                continue
            placeholders = ','.join(['?' for _ in current_level_ids])
            c.execute(f'SELECT telegram_id, is_vip FROM members WHERE referrer_id IN ({placeholders})', 
                     current_level_ids)
            rows = c.fetchall()
            counts.append({'total': len(rows), 'vip': sum(1 for r in rows if r[1])})
            current_level_ids = [r[0] for r in rows]
        
        conn.close()
        return counts

    @staticmethod
    def get_customer_services():
        """è·å–å®¢æœåˆ—è¡¨"""
        conn = DB.get_conn()
        c = conn.cursor()
        c.execute('SELECT * FROM customer_service')
        rows = c.fetchall()
        conn.close()
        return [{'id': r[0], 'name': r[1], 'link': r[2]} for r in rows]
    
    @staticmethod
    def get_resource_categories(parent_id=0):
        """è·å–èµ„æºåˆ†ç±»"""
        conn = DB.get_conn()
        c = conn.cursor()
        c.execute('SELECT * FROM resource_categories WHERE parent_id = ?', (parent_id,))
        rows = c.fetchall()
        conn.close()
        return [{'id': r[0], 'name': r[1]} for r in rows]
    
    @staticmethod
    def get_resources(category_id, page=1, per_page=20):
        """è·å–èµ„æºåˆ—è¡¨"""
        conn = DB.get_conn()
        c = conn.cursor()
        offset = (page - 1) * per_page
        c.execute('SELECT * FROM resources WHERE category_id = ? LIMIT ? OFFSET ?', 
                 (category_id, per_page, offset))
        rows = c.fetchall()
        c.execute('SELECT COUNT(*) FROM resources WHERE category_id = ?', (category_id,))
        total = c.fetchone()[0]
        conn.close()
        return {
            'items': [{'id': r[0], 'name': r[2], 'link': r[3], 'type': r[4], 'count': r[5]} for r in rows],
            'total': total,
            'pages': (total + per_page - 1) // per_page
        }

def get_system_config():
    """ä»æ•°æ®åº“åŠ¨æ€è¯»å–ç³»ç»Ÿé…ç½®"""
    conn = get_db_conn()
    c = conn.cursor()
    c.execute('SELECT key, value FROM system_config')
    config_rows = c.fetchall()
    
    # é»˜è®¤é…ç½®
    config = {
        'level_count': 10,
        'level_reward': 1,
        'vip_price': 10,
        'withdraw_threshold': 50,
        'support_text': 'ğŸ‘©â€ğŸ’¼ åœ¨çº¿å®¢æœ\n\næš‚æ— å®¢æœä¿¡æ¯ï¼Œè¯·è”ç³»ç®¡ç†å‘˜',
        'usdt_address': 'TUnpYkxUeawyGeMD3PGzhDkdkNYhRJcLfD',
        'pinned_ad': '',
        'welcome_message': '',
        'welcome_enabled': '1',
        'auto_register_enabled': '0'
    }
    
    key_mapping = {
        'levels': 'level_count',
        'reward_per_level': 'level_reward',
        'vip_price': 'vip_price',
        'withdraw_threshold': 'withdraw_threshold',
        'service_text': 'support_text',
        'usdt_address': 'usdt_address',
        'pinned_ad': 'pinned_ad',
        'welcome_message': 'welcome_message',
        'welcome_enabled': 'welcome_enabled',
        'level_amounts': 'level_amounts',
        'auto_register_enabled': 'auto_register_enabled'
    }
    
    for key, value in config_rows:
        if key in key_mapping:
            config_key = key_mapping[key]
            if key in ['levels', 'reward_per_level', 'vip_price', 'withdraw_threshold']:
                config[config_key] = float(value) if '.' in str(value) else int(value)
            elif key == 'level_amounts':
                # stored as JSON string -> parse to list/dict
                try:
                    import json
                    # ç¡®ä¿valueæ˜¯å­—ç¬¦ä¸²ï¼Œå¦‚æœå·²ç»æ˜¯å¯¹è±¡åˆ™ç›´æ¥ä½¿ç”¨
                    if isinstance(value, str):
                        config['level_amounts'] = json.loads(value)
                    else:
                        # å¦‚æœå·²ç»æ˜¯è§£æåçš„å¯¹è±¡ï¼Œç›´æ¥ä½¿ç”¨
                        config['level_amounts'] = value
                except Exception as e:
                    print(f"[DEBUG] level_amountsè§£æå¤±è´¥: {e}, value={value}, type={type(value)}")
                    config['level_amounts'] = value
            else:
                config[config_key] = value
        elif key.startswith('payment_'):
            # å¤„ç†æ”¯ä»˜ç›¸å…³é…ç½®
            config[key] = value
    
    conn.close()
    return config

def update_system_config(key, value):
    """æ›´æ–°ç³»ç»Ÿé…ç½®åˆ°æ•°æ®åº“"""
    reverse_key_mapping = {
        'level_count': 'levels',
        'level_reward': 'reward_per_level',
        'vip_price': 'vip_price',
        'withdraw_threshold': 'withdraw_threshold',
        'support_text': 'service_text',
        'usdt_address': 'usdt_address'
    }
    
    db_key = reverse_key_mapping.get(key, key)
    
    # ç‰¹æ®Šå¤„ç† level_amountsï¼Œç¡®ä¿å§‹ç»ˆå­˜å‚¨ä¸ºJSONå­—ç¬¦ä¸²
    if key == 'level_amounts' and not isinstance(value, str):
        import json
        value = json.dumps(value)
    
    conn = get_db_conn()
    c = conn.cursor()
    c.execute('''
        INSERT INTO system_config (key, value) 
        VALUES (?, ?)
        ON CONFLICT(key) DO UPDATE SET value=excluded.value
    ''', (db_key, str(value)))
    conn.commit()
    conn.close()

class AdminUser(UserMixin):
    """ç®¡ç†å‘˜ç”¨æˆ·ç±»"""
    def __init__(self, id, username, password_hash):
        self.id = id
        self.username = username
        self.password_hash = password_hash

# Webåå°æ•°æ®åº“æ“ä½œç±»ï¼ˆåˆå¹¶åçš„å®Œæ•´ç‰ˆæœ¬ï¼‰
class WebDB:
    """Webç®¡ç†åå°æ•°æ®åº“æ“ä½œ"""
    
    @staticmethod
    def get_user_by_username(username):
        """æ ¹æ®ç”¨æˆ·åè·å–ç”¨æˆ·"""
        conn = get_db_conn()
        c = conn.cursor()
        c.execute('SELECT id, username, password_hash FROM admin_users WHERE username = ?', (username,))
        row = c.fetchone()
        conn.close()
        if row:
            return AdminUser(row[0], row[1], row[2])
        return None
    
    @staticmethod
    def get_user_by_id(user_id):
        """æ ¹æ®IDè·å–ç”¨æˆ·"""
        conn = get_db_conn()
        c = conn.cursor()
        c.execute('SELECT id, username, password_hash FROM admin_users WHERE id = ?', (user_id,))
        row = c.fetchone()
        conn.close()
        if row:
            return AdminUser(row[0], row[1], row[2])
        return None
    
    @staticmethod
    def update_password(user_id, new_password):
        """æ›´æ–°å¯†ç """
        from werkzeug.security import generate_password_hash
        conn = get_db_conn()
        c = conn.cursor()
        password_hash = generate_password_hash(new_password)
        c.execute('UPDATE admin_users SET password_hash = ? WHERE id = ?', (password_hash, user_id))
        conn.commit()
        conn.close()
    
    @staticmethod
    def get_statistics():
        """è·å–ç»Ÿè®¡æ•°æ®"""
        conn = get_db_conn()
        c = conn.cursor()
        
        c.execute('SELECT COUNT(*) FROM members')
        total_members = c.fetchone()[0] or 0
        
        c.execute('SELECT COUNT(*) FROM members WHERE is_vip = 1')
        vip_members = c.fetchone()[0] or 0
        
        c.execute('SELECT COALESCE(SUM(balance), 0) FROM members')
        total_balance = c.fetchone()[0] or 0
        
        c.execute('SELECT COALESCE(SUM(missed_balance), 0) FROM members')
        total_missed = c.fetchone()[0] or 0
        
        conn.close()
        
        return {
            'total_members': total_members,
            'vip_members': vip_members,
            'total_balance': total_balance,
            'total_missed': total_missed
        }
    
    @staticmethod
    def get_chart_data():
        """è·å–å›¾è¡¨ç»Ÿè®¡æ•°æ®"""
        conn = get_db_conn()
        c = conn.cursor()
        
        # è·å–è¿‘7å¤©çš„æ³¨å†Œè¶‹åŠ¿
        from datetime import datetime, timedelta
        today = datetime.now().date()
        dates = []
        counts = []
        
        for i in range(6, -1, -1):
            date = today - timedelta(days=i)
            date_str = date.strftime('%Y-%m-%d')
            dates.append(date.strftime('%m-%d'))
            
            c.execute("SELECT COUNT(*) FROM members WHERE register_time LIKE ?", (f"{date_str}%",))
            count = c.fetchone()[0]
            counts.append(count)
            
        # è·å–VIPæ¯”ä¾‹
        c.execute('SELECT COUNT(*) FROM members WHERE is_vip = 1')
        vip_count = c.fetchone()[0]
        c.execute('SELECT COUNT(*) FROM members WHERE is_vip = 0')
        normal_count = c.fetchone()[0]
        
        conn.close()
        
        return {
            'growth': {'labels': dates, 'data': counts},
            'composition': {'vip': vip_count, 'normal': normal_count}
        }
    
    @staticmethod
    def get_withdrawals(page=1, per_page=20, status='all', search=''):
        """è·å–æç°åˆ—è¡¨"""
        conn = get_db_conn()
        c = conn.cursor()
        offset = (page - 1) * per_page
        
        try:
            search_term = search.lstrip('@').strip() if search else ''
            
            if status != 'all':
                c.execute('SELECT id, member_id, amount, usdt_address, status, create_time, process_time FROM withdrawals WHERE status = ? ORDER BY id DESC', (status,))
            else:
                c.execute('SELECT id, member_id, amount, usdt_address, status, create_time, process_time FROM withdrawals ORDER BY id DESC')
            
            all_rows = c.fetchall()
            
            results = []
            for row in all_rows:
                member_id = row[1]
                c.execute('SELECT username FROM members WHERE telegram_id = ?', (member_id,))
                user_row = c.fetchone()
                username = user_row[0] if user_row else str(member_id)
                
                if search_term:
                    if search_term.lower() not in username.lower() and search_term not in str(member_id):
                        continue
                
                results.append({
                    'id': row[0],
                    'member_id': row[1],
                    'amount': row[2],
                    'usdt_address': row[3],
                    'status': row[4],
                    'create_time': row[5],
                    'process_time': row[6],
                    'username': username
                })
            
            total = len(results)
            withdrawals = results[offset:offset + per_page]
            
            return {
                'withdrawals': withdrawals,
                'total': total,
                'page': page,
                'pages': (total + per_page - 1) // per_page if total > 0 else 1,
                'per_page': per_page
            }
        except Exception as e:
            print(f"get_withdrawals error: {e}")
            import traceback
            traceback.print_exc()
            return {'withdrawals': [], 'total': 0, 'page': 1, 'pages': 1, 'per_page': per_page}
        finally:
            conn.close()
    
    @staticmethod
    def process_withdrawal(withdrawal_id, action):
        """å¤„ç†æç°è¯·æ±‚"""
        conn = get_db_conn()
        c = conn.cursor()
        
        try:
            c.execute('SELECT member_id, amount, status FROM withdrawals WHERE id = ?', (withdrawal_id,))
            row = c.fetchone()
            
            if not row:
                return False, "è®°å½•ä¸å­˜åœ¨"
                
            member_id, amount, status = row
            
            from datetime import datetime
            now = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
            
            if action == 'approve':
                if status == 'rejected':
                    c.execute('UPDATE members SET balance = balance - ? WHERE telegram_id = ?', 
                             (amount, member_id))
                
                c.execute('UPDATE withdrawals SET status = ?, process_time = ? WHERE id = ?', 
                         ('approved', now, withdrawal_id))
                
            elif action == 'reject':
                if status != 'pending':
                    return False, "åªèƒ½æ‹’ç»å¾…å¤„ç†çš„æç°"
                
                c.execute('UPDATE withdrawals SET status = ?, process_time = ? WHERE id = ?', 
                         ('rejected', now, withdrawal_id))
                c.execute('UPDATE members SET balance = balance + ? WHERE telegram_id = ?', 
                         (amount, member_id))
            else:
                return False, "æ— æ•ˆæ“ä½œ"
                
            conn.commit()
            
            # å‘é€BOTé€šçŸ¥
            try:
                import requests
                if action == 'approve':
                    msg = f"âœ… æç°å®¡æ ¸é€šè¿‡\n\nğŸ’° é‡‘é¢: {amount} USDT\nğŸ“ è®¢å•å·: #{withdrawal_id}\nâ° æ—¶é—´: {now}\n\nè¯·æ³¨æ„æŸ¥æ”¶ï¼Œæ„Ÿè°¢æ‚¨çš„è€å¿ƒç­‰å¾…ï¼"
                else:
                    msg = f"âŒ æç°ç”³è¯·è¢«æ‹’ç»\n\nğŸ’° é‡‘é¢: {amount} USDT\nğŸ“ è®¢å•å·: #{withdrawal_id}\nâ° æ—¶é—´: {now}\n\nä½™é¢å·²é€€å›è´¦æˆ·ï¼Œå¦‚æœ‰ç–‘é—®è¯·è”ç³»å®¢æœã€‚"
                
                requests.post("http://127.0.0.1:5051/internal/notify", json={
                    'member_id': member_id, 'message': msg
                }, timeout=1)
            except:
                pass
            
            return True, "æ“ä½œæˆåŠŸ"
        except Exception as e:
            return False, str(e)
        finally:
            conn.close()
    
    @staticmethod
    def get_all_members(page=1, per_page=20, search='', filter_type='all'):
        """è·å–ä¼šå‘˜åˆ—è¡¨ï¼ˆå®Œæ•´ç‰ˆï¼Œè¿‡æ»¤æ‰æ¡æ¼è´¦å·ï¼‰"""
        conn = get_db_conn()
        c = conn.cursor()
        offset = (page - 1) * per_page
        
        search_term = search.lstrip('@').strip() if search else ''
        
        # æ„å»ºæŸ¥è¯¢æ¡ä»¶ï¼ˆä½¿ç”¨è¡¨åˆ«å mï¼‰
        where_clauses = []
        params = []

        # ã€æ ¸å¿ƒä¿®æ”¹ã€‘è¿‡æ»¤æ‰æ¡æ¼è´¦å·ï¼šæ’é™¤åœ¨ fallback_accounts è¡¨ä¸­çš„ç”¨æˆ·
        where_clauses.append('m.telegram_id NOT IN (SELECT telegram_id FROM fallback_accounts)')
        
        if filter_type == 'vip':
            where_clauses.append('m.is_vip = 1')
        elif filter_type == 'normal':
            where_clauses.append('m.is_vip = 0')
        
        if search_term:
            where_clauses.append('(m.username LIKE ? OR m.telegram_id LIKE ?)')
            params.extend([f'%{search_term}%', f'%{search_term}%'])
        
        where_sql = ' AND '.join(where_clauses) if where_clauses else '1=1'
        
        # è·å–æ€»æ•°ï¼ˆä½¿ç”¨JOINä»¥ä¿æŒä¸€è‡´æ€§ï¼‰
        c.execute(f'''
            SELECT COUNT(*) 
            FROM members m
            LEFT JOIN members r ON m.referrer_id = r.telegram_id
            WHERE {where_sql}
        ''', params)
        total = c.fetchone()[0]
        
        # è·å–åˆ†é¡µæ•°æ®ï¼ˆåŒ…å«æ‰€æœ‰å¿…è¦å­—æ®µï¼‰
        c.execute(f'''
            SELECT m.id, m.telegram_id, m.username, m.balance, m.is_vip, m.register_time, m.vip_time, 
                   m.referrer_id, m.group_link, m.missed_balance, m.total_earned,
                   m.is_group_bound, m.is_bot_admin, m.is_joined_upline, m.backup_account,
                   r.username as referrer_username
            FROM members m
            LEFT JOIN members r ON m.referrer_id = r.telegram_id
            WHERE {where_sql}
            ORDER BY m.id DESC
            LIMIT ? OFFSET ?
        ''', params + [per_page, offset])
        
        rows = c.fetchall()
        members = []
        
        # è·å–ç³»ç»Ÿé…ç½®çš„å±‚çº§æ•°
        try:
            c.execute("SELECT value FROM system_config WHERE key = 'level_count'")
            level_row = c.fetchone()
            level_count_cfg = int(level_row[0]) if level_row else 10
        except Exception:
            level_count_cfg = 10
        
        for row in rows:
            tg_id = row[1]
            # ã€æ ¸å¿ƒä¿®å¤ã€‘å®æ—¶è®¡ç®—ç›´æ¨ä¸å›¢é˜Ÿï¼ˆé¿å… team_count å…¨ä¸º 0ï¼‰
            downline_counts = DB.get_downline_count(tg_id, level_count_cfg)
            direct_count = downline_counts[0]['total'] if downline_counts else 0
            team_count = sum(item.get('total', 0) for item in downline_counts) if downline_counts else 0
            
            members.append({
                'id': row[0],  # æ·»åŠ IDå­—æ®µ
                'telegram_id': row[1],
                'username': row[2] or '',
                'balance': row[3] or 0,
                'is_vip': bool(row[4]),
                'register_time': row[5][:19] if row[5] else '',
                'vip_time': row[6][:19] if row[6] else '',
                'referrer_id': row[7],
                'referrer_username': row[15] or '',  # æ·»åŠ æ¨èäººç”¨æˆ·å
                'group_link': row[8] or '',
                'missed_balance': row[9] or 0,
                'total_earned': row[10] or 0,
                'is_group_bound': bool(row[11]),  # æ·»åŠ ç¾¤çŠ¶æ€å­—æ®µ
                'is_bot_admin': bool(row[12]),
                'is_joined_upline': bool(row[13]),
                'backup_account': row[14] or '',  # æ·»åŠ å¤‡ç”¨è´¦å·å­—æ®µ
                'direct_count': direct_count,  # å®æ—¶è®¡ç®—çš„ç›´æ¨äººæ•°
                'team_count': team_count  # å®æ—¶è®¡ç®—çš„å›¢é˜Ÿäººæ•°
            })
        
        conn.close()
        
        return {
            'members': members,
            'total': total,
            'page': page,
            'per_page': per_page,
            'pages': (total + per_page - 1) // per_page
        }
    
    @staticmethod
    def get_member_detail(telegram_id):
        """è·å–ä¼šå‘˜è¯¦æƒ…"""
        conn = get_db_conn()
        c = conn.cursor()
        
        c.execute('''
            SELECT telegram_id, username, balance, is_vip, register_time, vip_time,
                   referrer_id, group_link, missed_balance, total_earned, backup_account
            FROM members WHERE telegram_id = ?
        ''', (telegram_id,))
        
        row = c.fetchone()
        conn.close()
        
        if not row:
            return None
        
        return {
            'telegram_id': row[0],
            'username': row[1] or '',
            'balance': row[2] or 0,
            'is_vip': bool(row[3]),
            'register_time': row[4][:19] if row[4] else '',
            'vip_time': row[5][:19] if row[5] else '',
            'referrer_id': row[6],
            'group_link': row[7] or '',
            'missed_balance': row[8] or 0,
            'total_earned': row[9] or 0,
            'backup_account': row[10] or ''
        }
    
    @staticmethod
    def update_member(telegram_id, data):
        """æ›´æ–°ä¼šå‘˜ä¿¡æ¯"""
        conn = get_db_conn()
        c = conn.cursor()
        
        allowed_fields = ['username', 'balance', 'is_vip', 'group_link', 'missed_balance', 'total_earned']
        updates = []
        params = []
        
        for field in allowed_fields:
            if field in data:
                updates.append(f'{field} = ?')
                params.append(data[field])
        
        if updates:
            params.append(telegram_id)
            c.execute(f'UPDATE members SET {", ".join(updates)} WHERE telegram_id = ?', params)
            conn.commit()
        
        conn.close()
    
    @staticmethod
    def delete_member(telegram_id):
        """åˆ é™¤ä¼šå‘˜"""
        conn = get_db_conn()
        c = conn.cursor()
        c.execute('DELETE FROM members WHERE telegram_id = ?', (telegram_id,))
        conn.commit()
        conn.close()

# ==================== æ•°æ®åº“å‡çº§å‡½æ•° ====================

def upgrade_members_table():
    """å‡çº§membersè¡¨ç»“æ„"""
    conn = get_db_conn()
    c = conn.cursor()
    try:
        c.execute('ALTER TABLE members ADD COLUMN is_group_bound INTEGER DEFAULT 0')
    except: pass
    try:
        c.execute('ALTER TABLE members ADD COLUMN is_bot_admin INTEGER DEFAULT 0')
    except: pass
    try:
        c.execute('ALTER TABLE members ADD COLUMN is_joined_upline INTEGER DEFAULT 0')
    except: pass
    try:
        c.execute('ALTER TABLE members ADD COLUMN level_path TEXT')
    except: pass
    try:
        c.execute('ALTER TABLE members ADD COLUMN direct_count INTEGER DEFAULT 0')
    except: pass
    try:
        c.execute('ALTER TABLE members ADD COLUMN team_count INTEGER DEFAULT 0')
    except: pass
    try:
        c.execute('ALTER TABLE members ADD COLUMN total_earned REAL DEFAULT 0')
    except: pass
    try:
        c.execute('ALTER TABLE members ADD COLUMN withdraw_address TEXT')
    except: pass
    conn.commit()
    conn.close()

def upgrade_member_groups_table():
    """å‡çº§member_groupsè¡¨ç»“æ„"""
    conn = get_db_conn()
    c = conn.cursor()
    try:
        c.execute('ALTER TABLE member_groups ADD COLUMN owner_username TEXT')
    except: pass
    try:
        c.execute('ALTER TABLE member_groups ADD COLUMN group_type TEXT DEFAULT "group"')
    except: pass
    try:
        c.execute('ALTER TABLE member_groups ADD COLUMN schedule_broadcast INTEGER DEFAULT 1')
    except: pass
    conn.commit()
    conn.close()

def upgrade_broadcast_table():
    """å‡çº§broadcast_messagesè¡¨ç»“æ„"""
    conn = get_db_conn()
    c = conn.cursor()
    try:
        c.execute('ALTER TABLE broadcast_messages ADD COLUMN image_url TEXT')
    except: pass
    try:
        c.execute('ALTER TABLE broadcast_messages ADD COLUMN video_url TEXT')
    except: pass
    try:
        c.execute('ALTER TABLE broadcast_messages ADD COLUMN buttons TEXT')
    except: pass
    try:
        c.execute('ALTER TABLE broadcast_messages ADD COLUMN buttons_per_row INTEGER DEFAULT 2')
    except: pass
    try:
        c.execute('ALTER TABLE broadcast_messages ADD COLUMN schedule_enabled INTEGER DEFAULT 0')
    except: pass
    try:
        c.execute('ALTER TABLE broadcast_messages ADD COLUMN schedule_time TEXT')
    except: pass
    try:
        c.execute('ALTER TABLE broadcast_messages ADD COLUMN broadcast_interval INTEGER DEFAULT 120')
    except: pass
    try:
        c.execute('ALTER TABLE broadcast_messages ADD COLUMN broadcast_interval INTEGER DEFAULT 120')
    except: pass
    conn.commit()
    conn.close()

def upsert_member_group(telegram_id, group_link, owner_username=None, is_bot_admin=1, group_id=None):
    """
    å†™å…¥æˆ–æ›´æ–° member_groups è¡¨ï¼Œä¾¿äºåå°åˆ—è¡¨å±•ç¤ºã€‚
    é»˜è®¤ is_bot_admin=1ï¼Œå› ä¸ºéªŒè¯é€šè¿‡åæ‰ä¼šè°ƒç”¨ã€‚
    """
    if not group_link:
        return
    try:
        conn = get_db_conn()
        c = conn.cursor()
        c.execute('SELECT id FROM member_groups WHERE telegram_id = ?', (telegram_id,))
        row = c.fetchone()
        now = get_cn_time()
        if row:
            # æ›´æ–°ç°æœ‰è®°å½•
            update_fields = ['group_link = ?']
            update_values = [group_link]

            if owner_username is not None:
                update_fields.append('owner_username = ?')
                update_values.append(owner_username)

            if group_id is not None:
                update_fields.append('group_id = ?')
                update_values.append(group_id)

            update_values.append(row[0])  # WHERE id = ?

            c.execute(
                f'''UPDATE member_groups
                   SET {', '.join(update_fields)}
                 WHERE id = ?''',
                update_values
            )
        else:
            # æ’å…¥æ–°è®°å½•
            c.execute(
                '''INSERT INTO member_groups 
                   (telegram_id, group_id, group_name, group_link, is_bot_admin, create_time, owner_username, group_type, schedule_broadcast)
                   VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)''',
                (telegram_id, group_id, '', group_link, is_bot_admin, now, owner_username or '', 'group', 1)
            )
        conn.commit()
        conn.close()
        print(f'[member_groups upsert] æˆåŠŸå†™å…¥ç”¨æˆ· {telegram_id} çš„ç¾¤ç»„ç»‘å®šï¼Œgroup_id={group_id}')
    except Exception as e:
        print(f'[member_groups upsert] error: {e}')

async def sync_member_groups_from_members(connected_clients=None):
    """å¯åŠ¨æ—¶åŒæ­¥å·²å­˜åœ¨çš„ä¼šå‘˜ç¾¤é“¾æ¥åˆ° member_groupsï¼Œé¿å…åå°åˆ—è¡¨ä¸ºç©º"""
    try:
        # é¦–å…ˆè·å–éœ€è¦åŒæ­¥çš„æ•°æ®
        conn = get_db_conn()
        c = conn.cursor()
        c.execute("SELECT telegram_id, username, group_link FROM members WHERE group_link IS NOT NULL AND group_link != ''")
        rows = c.fetchall()
        conn.close()

        print(f'[sync_member_groups] å‘ç° {len(rows)} æ¡éœ€è¦åŒæ­¥çš„è®°å½•')

        # ä½¿ç”¨ä¼ å…¥çš„å·²è¿æ¥å®¢æˆ·ç«¯
        synced_count = 0
        if not connected_clients:
            print('[sync_member_groups] è­¦å‘Šï¼šæ²¡æœ‰ä¼ å…¥å·²è¿æ¥çš„æœºå™¨äººå®¢æˆ·ç«¯ï¼Œè·³è¿‡group_idè·å–')
            # å¦‚æœæ²¡æœ‰æœºå™¨äººå®¢æˆ·ç«¯ï¼Œä»ç„¶åˆ›å»ºè®°å½•ä½†group_idä¸ºNone
            for r in rows:
                tg_id, uname, glink = r
                try:
                    upsert_member_group(tg_id, glink, uname or None, is_bot_admin=1, group_id=None)
                    synced_count += 1
                except Exception as inner_err:
                    print(f'[sync_member_groups] å•æ¡å¤±è´¥ {tg_id}: {inner_err}')
            print(f'[sync_member_groups] åŒæ­¥å®Œæˆï¼ˆæ— æœºå™¨äººå®¢æˆ·ç«¯ï¼‰ï¼Œå…±å¤„ç† {len(rows)} æ¡è®°å½•ï¼ŒæˆåŠŸ {synced_count} æ¡')
            return

        # ä½¿ç”¨ç¬¬ä¸€ä¸ªå¯ç”¨çš„æœºå™¨äººå®¢æˆ·ç«¯
        bot = connected_clients[0]
        print(f'[sync_member_groups] ä½¿ç”¨æœºå™¨äººå®¢æˆ·ç«¯è·å–group_id: {bot}')
        print(f'[sync_member_groups] å¼€å§‹åŒæ­¥ {len(rows)} æ¡è®°å½•...')

        synced_count = 0
        for r in rows:
            tg_id, uname, glink = r
            try:
                group_id = None
                group_name = None

                # è§£æé“¾æ¥è·å–group_id
                if glink.startswith('https://t.me/') or glink.startswith('http://t.me/'):
                    tail = glink.replace('https://t.me/', '').replace('http://t.me/', '').split('?')[0]

                    # è·³è¿‡ç§æœ‰é“¾æ¥ï¼ˆæ— æ³•è·å–IDï¼‰
                    if tail.startswith('+') or tail.startswith('joinchat/'):
                        print(f'[sync_member_groups] ç§æœ‰é“¾æ¥ {glink} for user {tg_id}ï¼Œæ— æ³•è·å–group_id')
                    else:
                        # å…¬å¼€ç¾¤ç»„ï¼Œå°è¯•è·å–ID
                        # éªŒè¯ç”¨æˆ·åæ ¼å¼ï¼ˆTelegramç”¨æˆ·åè§„åˆ™ï¼‰
                        # Telegramç”¨æˆ·åï¼š3-32ä¸ªå­—ç¬¦ï¼Œåªèƒ½åŒ…å«a-z, 0-9, _
                        import re
                        if not tail or len(tail) < 3 or len(tail) > 32 or not re.match(r'^[a-zA-Z0-9_]+$', tail):
                            print(f'[sync_member_groups] âš ï¸ ç”¨æˆ·åæ ¼å¼æ— æ•ˆ (ä¸ç¬¦åˆTelegramè§„åˆ™): {tail} for user {tg_id}')
                        elif len(tail) > 20:  # å¯ç–‘çš„é•¿ç”¨æˆ·å
                            print(f'[sync_member_groups] âš ï¸ ç”¨æˆ·åè¿‡é•¿ï¼Œå¯èƒ½æ— æ•ˆ: {tail} ({len(tail)}å­—ç¬¦) for user {tg_id}')
                        else:
                            # é‡è¯•æœºåˆ¶
                            max_retries = 3
                            for attempt in range(max_retries):
                                try:
                                    print(f'[sync_member_groups] å°è¯•è·å–ç¾¤ç»„ID: {tail} for user {tg_id} (å°è¯• {attempt+1}/{max_retries})')

                                    entity = await bot.get_entity(tail)
                                    raw_id = getattr(entity, 'id', None)
                                    # Telegramç¾¤ç»„IDéœ€è¦è½¬æ¢ä¸ºå®Œæ•´æ ¼å¼
                                    if raw_id and raw_id > 0:
                                        # å¯¹äºé¢‘é“å’Œsupergroupï¼Œå®Œæ•´IDæ˜¯ -100 + åŸå§‹ID
                                        group_id = int(f"-100{raw_id}")
                                    else:
                                        group_id = raw_id

                                    group_name = getattr(entity, 'title', tail)
                                    print(f'[sync_member_groups] âœ… è·å–æˆåŠŸ: raw_id={raw_id}, group_id={group_id}, name={group_name}')
                                    break  # æˆåŠŸåé€€å‡ºé‡è¯•å¾ªç¯
                                except Exception as e:
                                    error_msg = str(e)
                                    error_lower = error_msg.lower()

                                    # è¿æ¥ç›¸å…³é”™è¯¯ï¼Œä¸é‡è¯•
                                    if ('cannot send requests' in error_lower or
                                        'disconnected' in error_lower or
                                        'connection' in error_lower and ('closed' in error_lower or 'lost' in error_lower)):
                                        print(f'[sync_member_groups] âŒ è¿æ¥é—®é¢˜ï¼Œè·³è¿‡æ­¤ç¾¤ç»„: {tail} ({error_msg})')
                                        break

                                    # æƒé™æˆ–è®¿é—®é”™è¯¯ï¼Œä¸é‡è¯•
                                    elif ('forbidden' in error_lower or
                                          'unauthorized' in error_lower or
                                          'bot was blocked' in error_lower or
                                          'bot was kicked' in error_lower):
                                        print(f'[sync_member_groups] âŒ æƒé™é—®é¢˜ï¼Œè·³è¿‡æ­¤ç¾¤ç»„: {tail} ({error_msg})')
                                        break

                                    # ç¾¤ç»„ä¸å­˜åœ¨æˆ–å…¶ä»–APIé”™è¯¯ï¼Œé‡è¯•å‡ æ¬¡
                                    elif attempt < max_retries - 1:
                                        print(f'[sync_member_groups] âš ï¸ è·å–å¤±è´¥ {tail}, {attempt+1}ç§’åé‡è¯•: {error_msg}')
                                        await asyncio.sleep(1)
                                    else:
                                        print(f'[sync_member_groups] âŒ è·å–å¤±è´¥ {tail} (å·²é‡è¯•{max_retries}æ¬¡): {error_msg}')
                elif 'Private Group (ID: ' in glink:
                    # ä»ç§æœ‰ç¾¤æ ¼å¼æå–ID
                    try:
                        id_str = glink.split('Private Group (ID: ')[1].split(')')[0]
                        group_id = int(id_str)
                        print(f'[sync_member_groups] ä»ç§æœ‰ç¾¤æ ¼å¼æå–åˆ°group_id: {group_id} for user {tg_id}')
                    except:
                        pass

                upsert_member_group(tg_id, glink, uname or None, is_bot_admin=1, group_id=group_id)

                # å¦‚æœè·å–åˆ°äº†ç¾¤åï¼Œæ›´æ–°ä¸€ä¸‹
                if group_name and group_id:
                    try:
                        conn = get_db_conn()
                        c = conn.cursor()
                        c.execute("UPDATE member_groups SET group_name = ? WHERE group_id = ?", (group_name, group_id))
                        conn.commit()
                        conn.close()
                    except Exception as e:
                        print(f'[sync_member_groups] æ›´æ–°ç¾¤åå¤±è´¥: {e}')

                synced_count += 1
            except Exception as inner_err:
                print(f'[sync_member_groups] å•æ¡å¤±è´¥ {tg_id}: {inner_err}')

        print(f'[sync_member_groups] åŒæ­¥å®Œæˆï¼Œå…±å¤„ç† {len(rows)} æ¡è®°å½•ï¼ŒæˆåŠŸ {synced_count} æ¡')
    except Exception as e:
        print(f'[sync_member_groups] å¤±è´¥: {e}')
        import traceback
        traceback.print_exc()

# åœ¨æ¨¡å—åŠ è½½æ—¶æ‰§è¡Œæ•°æ®åº“å‡çº§
upgrade_members_table()
upgrade_member_groups_table()
upgrade_broadcast_table()


--- File: ./app/payment.py ---
"""
æ”¯ä»˜ç›¸å…³åŠŸèƒ½æ¨¡å—
åŒ…å«USDTå……å€¼ã€æ”¯ä»˜è®¢å•åˆ›å»ºã€æ”¯ä»˜çŠ¶æ€æ£€æŸ¥ç­‰åŠŸèƒ½
"""
import asyncio
import time
import hashlib
import requests as req
import re
from datetime import datetime, timedelta, timezone
from telethon import Button

from .config import ADMIN_IDS, PUBLIC_BASE_URL
from .database import DB, get_cn_time, get_system_config, get_db_conn
from .core_functions import update_level_path, distribute_vip_rewards, get_upline_chain

# æ”¯ä»˜é…ç½® - ä½¿ç”¨æ•°æ®åº“é…ç½®ï¼Œå¸¦é»˜è®¤å€¼
PAYMENT_CONFIG = {
    'api_url': '',
    'partner_id': '',
    'key': '',
    'notify_url': (f"{PUBLIC_BASE_URL}/api/payment/notify" if PUBLIC_BASE_URL else ''),
    'return_url': (f"{PUBLIC_BASE_URL}/payment/success" if PUBLIC_BASE_URL else ''),
    'pay_type': 'trc20',
    'version': '1.0',
    'payment_rate': 1.0
}

def load_payment_config():
    """ä»æ•°æ®åº“åŠ è½½æ”¯ä»˜é…ç½®"""
    try:
        config = get_system_config()
        PAYMENT_CONFIG.update({
            'api_url': config.get('payment_url', ''),
            'partner_id': str(config.get('payment_user_id', '')),
            'key': config.get('payment_token', ''),
            'pay_type': config.get('payment_channel', 'trc20'),
            'payment_rate': float(config.get('payment_rate', 1.0)),
        })
        print(f"[æ”¯ä»˜æ¨¡å—] å·²åŠ è½½é…ç½®: URL={PAYMENT_CONFIG['api_url']}, PartnerID={PAYMENT_CONFIG['partner_id']}, PayType={PAYMENT_CONFIG['pay_type']}")
    except Exception as e:
        print(f"[æ”¯ä»˜æ¨¡å—] åŠ è½½é…ç½®å¤±è´¥ï¼Œä½¿ç”¨é»˜è®¤é…ç½®: {e}")

# åœ¨æ¨¡å—å¯¼å…¥æ—¶è‡ªåŠ¨åŠ è½½é…ç½®
load_payment_config()

# æ”¯ä»˜è®¢å•ç›¸å…³
payment_orders = {}  # å­˜å‚¨å……å€¼è®¢å•
payment_tasks = {}  # å­˜å‚¨æ”¯ä»˜æ£€æŸ¥ä»»åŠ¡
interval_time_in_seconds = 9  # æ£€æŸ¥æ”¯ä»˜é—´éš”ï¼ˆç§’ï¼‰
check_duration_seconds = 1200  # è®¢å•æœ‰æ•ˆæœŸï¼ˆç§’ï¼‰ï¼Œ20åˆ†é’Ÿ

# æ”¯ä»˜ç³»ç»ŸçŠ¶æ€æ§åˆ¶
PAYMENT_ENABLED = True  # å¯ç”¨æ”¯ä»˜åŠŸèƒ½ - å·²æ›´æ–°ä¸ºæ–°æ¥å£

CN_TIMEZONE = timezone(timedelta(hours=8))

def generate_payment_sign(params, key):
    """ç”Ÿæˆæ”¯ä»˜ç­¾å"""
    sorted_params = sorted([(k, v) for k, v in params.items() if v is not None and v != ''])
    sign_str = '&'.join([f'{k}={v}' for k, v in sorted_params])
    sign_str += f'&key={key}'
    return hashlib.md5(sign_str.encode()).hexdigest().upper()

def create_payment_order(amount, out_trade_no, remark=''):
    """åˆ›å»ºæ”¯ä»˜è®¢å•"""
    params = {
        'amount': f'{amount:.2f}',
        'partnerid': PAYMENT_CONFIG['partner_id'],
        'notifyUrl': PAYMENT_CONFIG['notify_url'],
        'out_trade_no': out_trade_no,
        'payType': PAYMENT_CONFIG['pay_type'],
        'returnUrl': PAYMENT_CONFIG['return_url'],
        'version': PAYMENT_CONFIG['version'],
        'format': 'json'
    }

    params['sign'] = generate_payment_sign(params, PAYMENT_CONFIG['key'])

    if remark:
        params['remark'] = remark
    try:
        load_payment_config()
        print(f'[æ”¯ä»˜API] è¯·æ±‚å‚æ•°: {params}')
        if not PAYMENT_CONFIG.get('api_url'):
            raise ValueError('æ”¯ä»˜é…ç½®é”™è¯¯ï¼špayment_url(api_url) ä¸ºç©ºï¼Œè¯·å…ˆåœ¨Webåå°å¡«å†™â€œæ”¯ä»˜ç½‘å…³åœ°å€/æ”¯ä»˜URLâ€å¹¶ä¿å­˜ï¼Œç„¶åé‡è¯•')
        response = req.post(PAYMENT_CONFIG['api_url'], data=params, timeout=15)

        result = response.json()
        print(f'[æ”¯ä»˜API] å“åº”: {result}')
        return result

    except Exception as e:
        print(f'[æ”¯ä»˜APIé”™è¯¯] {e}')
        import traceback
        traceback.print_exc()
        return None

def check_usdt_transaction(usdt_address):
    """æŸ¥è¯¢USDT TRC20åœ°å€çš„äº¤æ˜“è®°å½•"""
    try:
        api_url = f"https://api.trongrid.io/v1/accounts/{usdt_address}/transactions/trc20?limit=200&contract_address=TR7NHqjeKQxGTCi8q8ZY4pL8otSzgjLj6t"
        response = req.get(api_url, timeout=10)
        if response.status_code == 200:
            return response.json()
        return None
    except Exception as e:
        print(f"æŸ¥è¯¢USDTäº¤æ˜“å¤±è´¥: {e}")
        return None

def query_payment_order(out_trade_no):
    """æŸ¥è¯¢æ”¯ä»˜è®¢å•çŠ¶æ€"""
    params = {
        'partnerid': PAYMENT_CONFIG['partner_id'],
        'out_trade_no': out_trade_no,
        'version': PAYMENT_CONFIG['version']
    }

    # ç”Ÿæˆç­¾å
    params['sign'] = generate_payment_sign(params, PAYMENT_CONFIG['key'])

    try:
        print(f'[è®¢å•æŸ¥è¯¢] è¯·æ±‚å‚æ•°: {params}')
        response = req.post(f"{PAYMENT_CONFIG['api_url']}index.php?c=merorderQuery", data=params, timeout=10)
        result = response.json()
        print(f'[è®¢å•æŸ¥è¯¢] å“åº”: {result}')
        return result
    except Exception as e:
        print(f'[è®¢å•æŸ¥è¯¢é”™è¯¯] {e}')
        import traceback
        traceback.print_exc()
        return None

def extract_usdt_address_from_payment_url(payment_url):
    """ä»æ”¯ä»˜é“¾æ¥é¡µé¢è§£æUSDTæ”¶æ¬¾åœ°å€"""
    if not payment_url:
        return None
    
    try:
        headers = {
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
        }
        response = req.get(payment_url, headers=headers, timeout=10, allow_redirects=True)
        
        if response.status_code == 200:
            html = response.text
            # åŒ¹é…TRC20åœ°å€æ ¼å¼ï¼šTå¼€å¤´ï¼Œ34ä¸ªå­—ç¬¦
            pattern = r'T[A-Za-z1-9]{33}'
            matches = re.findall(pattern, html)
            if matches:
                return matches[0]
    except Exception as e:
        print(f'[è§£ææ”¯ä»˜åœ°å€] å¤±è´¥: {e}')
    
    return None

async def check_payment_task(bot, order):
    """æŒç»­æ£€æŸ¥è®¢å•æ”¯ä»˜çŠ¶æ€"""
    print(f"å¼€å§‹æ£€æŸ¥è®¢å• {order['order_number']} çš„æ”¯ä»˜çŠ¶æ€")
    
    while True:
        try:
            print(f"æ­£åœ¨æ£€æŸ¥è®¢å• {order['order_number']} - é‡‘é¢: {order['amount']} U")
            
            # æŸ¥è¯¢äº¤æ˜“è®°å½•
            transaction_data = check_usdt_transaction(order['usdt_address'])
            
            if transaction_data and 'data' in transaction_data:
                current_time = datetime.now(CN_TIMEZONE)
                
                for transaction in transaction_data['data']:
                    # è·å–äº¤æ˜“æ—¶é—´
                    transaction_time = datetime.fromtimestamp(
                        transaction['block_timestamp'] / 2000,
                        tz=CN_TIMEZONE
                    )
                    
                    # æ£€æŸ¥äº¤æ˜“æ˜¯å¦åœ¨è®¢å•åˆ›å»ºåä¸”åœ¨æœ‰æ•ˆæœŸå†…
                    if transaction_time > order['created_at'] and transaction_time < (order['created_at'] + timedelta(seconds=check_duration_seconds)):
                        # è·å–äº¤æ˜“é‡‘é¢ï¼ˆUSDTçš„ç²¾åº¦æ˜¯6ä½å°æ•°ï¼‰
                        amount = float(transaction['value']) / 2000000
                        
                        print(f"å‘ç°äº¤æ˜“ - é‡‘é¢: {amount} U, è®¢å•é‡‘é¢: {order['amount']} U")
                        
                        # æ£€æŸ¥é‡‘é¢æ˜¯å¦åŒ¹é…
                        if abs(float(order['amount']) - amount) < 0.01:  # å…è®¸0.01çš„è¯¯å·®
                            print(f"è®¢å• {order['order_number']} æ”¯ä»˜æˆåŠŸï¼")
                            
                            # å¤„ç†å……å€¼ï¼ˆåˆ¤æ–­æ˜¯å¦ä¸ºVIPè®¢å•ï¼‰
                            is_vip_order = order.get('is_vip_order', False)
                            # å»¶è¿Ÿå¯¼å…¥é¿å…å¾ªç¯ä¾èµ–
                            import importlib
                            bot_logic_module = importlib.import_module('bot_logic')
                            await bot_logic_module.process_recharge(order['telegram_id'], amount, is_vip_order)
                            
                            # æ¸…ç†è®¢å•å’Œä»»åŠ¡
                            order_number = order['order_number']
                            if order_number in payment_tasks:
                                _, timeout_task = payment_tasks[order_number]
                                timeout_task.cancel()
                                del payment_tasks[order_number]
                            
                            if order_number in payment_orders:
                                del payment_orders[order_number]
                            
                            return
            
            print(f"æœªå‘ç°è®¢å• {order['order_number']} çš„æ”¯ä»˜ï¼Œ{interval_time_in_seconds}ç§’åé‡è¯•")
            await asyncio.sleep(interval_time_in_seconds)
            
        except Exception as e:
            print(f"æ£€æŸ¥æ”¯ä»˜å¼‚å¸¸: {e}")
            await asyncio.sleep(interval_time_in_seconds)

async def payment_timeout_handler(bot, order):
    """å¤„ç†è®¢å•è¶…æ—¶ï¼ˆä¿®å¤ç‰ˆï¼šå¢åŠ çŠ¶æ€äºŒæ¬¡æ£€æŸ¥ï¼Œå®Œç¾è§£å†³æ‰‹åŠ¨å…¥æ¬¾å´æç¤ºè¶…æ—¶çš„é—®é¢˜ï¼‰

    é—®é¢˜æ ¹æºï¼š
    - ä¸‰æ–¹æ”¯ä»˜åå°æ˜¾ç¤º"ç­‰å¾…æ”¯ä»˜"æ˜¯æ­£å¸¸çš„ï¼ˆå› ä¸ºç®¡ç†å‘˜æ²¡çœŸä»˜é’±ï¼‰
    - æœ¬åœ°æœºå™¨äººåå°æ˜¾ç¤º"å·²å®Œæˆ"æ˜¯ç®¡ç†å‘˜æ‰‹åŠ¨æ“ä½œçš„ç»“æœ
    - æœºå™¨äººå€’è®¡æ—¶ä»»åŠ¡é†’æ¥åï¼Œæ²¡æœ‰æ£€æŸ¥æ•°æ®åº“çŠ¶æ€å°±å‘è¶…æ—¶é€šçŸ¥

    è§£å†³æ–¹æ¡ˆï¼š
    - åœ¨å‘é€è¶…æ—¶é€šçŸ¥å‰ï¼Œå…ˆå»æ•°æ®åº“æ£€æŸ¥è®¢å•çŠ¶æ€
    - å¦‚æœæ•°æ®åº“çŠ¶æ€å·²æ˜¯completedï¼Œç›´æ¥æ‹¦æˆªè¶…æ—¶é€šçŸ¥
    """
    # 1. ç­‰å¾…è®¢å•æœ‰æ•ˆæœŸï¼ˆä¾‹å¦‚20åˆ†é’Ÿ = 1200ç§’ï¼‰
    check_duration = 1200
    await asyncio.sleep(check_duration)
    
    order_number = order['order_number']
    telegram_id = order['telegram_id']
    
    # 2. æ¸…ç†å†…å­˜ä¸­çš„ä»»åŠ¡è®°å½•ï¼ˆåœæ­¢è½®è¯¢åŒºå—é“¾ï¼‰
    if order_number in payment_orders:
        del payment_orders[order_number]
    if order_number in payment_tasks:
        del payment_tasks[order_number]

    try:
        # 3. ã€å…³é”®æ­¥éª¤ã€‘å»æ•°æ®åº“æŸ¥æœ€æ–°çš„çŠ¶æ€
        conn = get_db_conn()
        c = conn.cursor()
        c.execute("SELECT status FROM recharge_records WHERE order_id = ?", (order_number,))
        row = c.fetchone()
        conn.close()

        # 4. å¦‚æœæ•°æ®åº“æ˜¾ç¤ºå·²å®Œæˆï¼ˆç®¡ç†å‘˜æ‰‹åŠ¨ç‚¹è¿‡æˆ–å›è°ƒæˆåŠŸï¼‰ï¼Œç›´æ¥é€€å‡ºï¼Œä»€ä¹ˆéƒ½ä¸å‘
        if row and row[0] == 'completed':
            print(f"[è¶…æ—¶æ£€æŸ¥] è®¢å• {order_number} å·²ç”±ç®¡ç†å‘˜æ‰‹åŠ¨å®Œæˆæˆ–æ”¯ä»˜æˆåŠŸï¼Œæ‹¦æˆªè¶…æ—¶é€šçŸ¥")
            return
        # 5. åªæœ‰çŠ¶æ€ç¡®å®ä¸æ˜¯ completed æ—¶ï¼Œæ‰å‘è¶…æ—¶é€šçŸ¥
            await bot.send_message(
            telegram_id,
            f'â° è®¢å•å·²å…³é—­\n\nè®¢å•å·: {order_number}\né‡‘é¢: {order["amount"]} U\n\næç¤ºï¼šå¦‚æœæ‚¨å·²æ”¯ä»˜ä½†æœªåˆ°è´¦ï¼Œè¯·è”ç³»äººå·¥å®¢æœå¤„ç†ã€‚'
            )
    except Exception as e:
        print(f"[è¶…æ—¶å¤„ç†é”™è¯¯] {e}")

async def create_recharge_order(bot, event, amount, is_vip_order=False):
    """åˆ›å»ºå……å€¼è®¢å•"""
    # æ£€æŸ¥æ”¯ä»˜ç³»ç»Ÿæ˜¯å¦å¯ç”¨
    if not PAYMENT_ENABLED:
        await event.respond("ğŸ’³ æ”¯ä»˜ç³»ç»Ÿæš‚æ—¶ç»´æŠ¤ä¸­\n\nè¯·ç¨åé‡è¯•æˆ–è”ç³»å®¢æœ")
        return

    telegram_id = event.sender_id
    order_number = f"RCH_{telegram_id}_{int(time.time())}"
    payment_result = create_payment_order(amount, order_number, f"TG{telegram_id}")

    # æ·»åŠ è°ƒè¯•ä¿¡æ¯
    print(f"[æ”¯ä»˜è°ƒè¯•] è®¢å•å·: {order_number}, é‡‘é¢: {amount}")
    print(f"[æ”¯ä»˜è°ƒè¯•] APIå“åº”: {payment_result}")

    if not payment_result:
        print("[æ”¯ä»˜è°ƒè¯•] APIè¿”å›Noneï¼Œå¯èƒ½æ˜¯ç½‘ç»œé”™è¯¯")
        await event.respond("åˆ›å»ºæ”¯ä»˜è®¢å•å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•")
        return

    if payment_result.get("code") != 200:
        error_code = payment_result.get("code")
        error_msg = payment_result.get("msg", "æœªçŸ¥é”™è¯¯")
        print(f"[æ”¯ä»˜è°ƒè¯•] APIé”™è¯¯ {error_code}: {error_msg}")

        # æ ¹æ®é”™è¯¯ä»£ç æä¾›ä¸åŒçš„æç¤º
        if error_code == -5:
            await event.respond("ğŸ’³ æ”¯ä»˜ç½‘å…³æš‚æ—¶ä¸å¯ç”¨\n\nè¯·ç¨åé‡è¯•æˆ–è”ç³»å®¢æœå¤„ç†\né”™è¯¯è¯¦æƒ…ï¼šç½‘å…³è¿æ¥å¤±è´¥")
        elif error_code == 3013:
            await event.respond("ğŸ’³ æ”¯ä»˜é…ç½®é”™è¯¯\n\nè¯·è”ç³»ç®¡ç†å‘˜æ£€æŸ¥æ”¯ä»˜é…ç½®\né”™è¯¯è¯¦æƒ…ï¼šç­¾åé”™è¯¯")
        else:
            await event.respond(f"åˆ›å»ºæ”¯ä»˜è®¢å•å¤±è´¥: {error_msg}")
        return

    # ä¿å­˜å……å€¼è®°å½•åˆ°æ•°æ®åº“
    conn = get_db_conn()
    c = conn.cursor()
    remark = "å¼€é€š" if is_vip_order else ""

    # æ£€æŸ¥è¡¨æ˜¯å¦æœ‰remarkå­—æ®µ
    c.execute("PRAGMA table_info(recharge_records)")
    columns = [col[1] for col in c.fetchall()]
    if 'remark' in columns:
        c.execute('''INSERT INTO recharge_records
                     (member_id, amount, order_id, status, payment_method, remark, create_time)
                     VALUES (?, ?, ?, ?, ?, ?, ?)''',
                  (telegram_id, amount, order_number, 'pending', 'USDT', remark, get_cn_time()))
    else:
        c.execute('''INSERT INTO recharge_records
                     (member_id, amount, order_id, status, payment_method, create_time)
                     VALUES (?, ?, ?, ?, ?, ?)''',
                  (telegram_id, amount, order_number, 'pending', 'USDT', get_cn_time()))
    conn.commit()
    conn.close()
    
    # ä¼˜å…ˆä½¿ç”¨æ”¯ä»˜å¹³å°è¿”å›çš„æ”¯ä»˜é“¾æ¥/äºŒç»´ç 
    payment_url = None
    payment_qrcode = None
    usdt_address = None
    
    if payment_result.get("code") == 200:
        data = payment_result.get("data", {})
        if isinstance(data, dict):
            # å°è¯•è·å–æ”¯ä»˜é“¾æ¥
            payment_url = data.get("url") or data.get("data", {}).get("url") or data.get("data", {}).get("qrcode")
            payment_qrcode = data.get("data", {}).get("qrcode")
            
            # å°è¯•ä»æ”¯ä»˜å¹³å°è¿”å›çš„æ•°æ®ä¸­ç›´æ¥è·å–åœ°å€ï¼ˆå¦‚æœæœ‰çš„è¯ï¼‰
            if "address" in str(data).lower() or "æ”¶æ¬¾åœ°å€" in str(data):
                data_str = str(data)
                pattern = r'T[A-Za-z1-9]{33}'
                matches = re.findall(pattern, data_str)
                if matches:
                    usdt_address = matches[0]
    
    # å¦‚æœæ²¡æœ‰ä»è¿”å›æ•°æ®ä¸­è·å–åˆ°åœ°å€ï¼Œå°è¯•ä»æ”¯ä»˜é“¾æ¥é¡µé¢å®æ—¶è§£æ
    if not usdt_address and payment_url:
        print(f'[æ”¯ä»˜åœ°å€] å¼€å§‹å®æ—¶è§£ææ”¯ä»˜é“¾æ¥: {payment_url}')
        usdt_address = extract_usdt_address_from_payment_url(payment_url)
        if usdt_address:
            print(f'[æ”¯ä»˜åœ°å€] å®æ—¶è§£ææˆåŠŸ: {usdt_address}')
        else:
            print(f'[æ”¯ä»˜åœ°å€] å®æ—¶è§£æå¤±è´¥ï¼Œæœªæ‰¾åˆ°USDTåœ°å€')
    
    # åªä½¿ç”¨å®æ—¶è§£æåˆ°çš„åœ°å€ï¼Œä¸ä½¿ç”¨ä»»ä½•ç¼“å­˜æˆ–æ‰‹åŠ¨é…ç½®
    if usdt_address:
        msg = f'''âœ… æ”¯ä»˜è®¢å•å·²åˆ›å»º

è®¢å•å·: `{order_number}`
æ”¯ä»˜é‡‘é¢: {amount:.2f} USDT

ğŸ“ è¯·è½¬è´¦åˆ°ä»¥ä¸‹åœ°å€ï¼š
`{usdt_address}`
(TRC-20ç½‘ç»œ)

âš ï¸ è®¢å•10åˆ†é’Ÿå†…æœ‰æ•ˆï¼Œè¿‡æœŸåè¯·é‡æ–°åˆ›å»º
âš ï¸ è½¬è´¦é‡‘é¢å¿…é¡»ä¸è®¢å•é‡‘é¢å®Œå…¨ä¸€è‡´
âœ… æ”¯ä»˜å®Œæˆåï¼Œç³»ç»Ÿå°†è‡ªåŠ¨åˆ°è´¦ï¼ˆçº¦1-2åˆ†é’Ÿï¼‰'''
    
        buttons = [[Button.inline("è¿”å›", b"back")]]
        await event.respond(msg, buttons=buttons, parse_mode='markdown')
        
        # ä¿å­˜è®¢å•ä¿¡æ¯å¹¶å¯åŠ¨æ”¯ä»˜æ£€æŸ¥ä»»åŠ¡
        order_info = {
            'order_number': order_number,
            'telegram_id': telegram_id,
            'amount': amount,
            'usdt_address': usdt_address,
            'created_at': datetime.now(CN_TIMEZONE),
            'is_vip_order': is_vip_order
        }
        payment_orders[order_number] = order_info
        
        # å¯åŠ¨æ”¯ä»˜æ£€æŸ¥ä»»åŠ¡
        payment_task = bot.loop.create_task(check_payment_task(bot, order_info))
        timeout_task = bot.loop.create_task(payment_timeout_handler(bot, order_info))
        payment_tasks[order_number] = (payment_task, timeout_task)
    else:
        # å¦‚æœæ— æ³•è§£æåˆ°USDTåœ°å€ï¼Œæç¤ºé”™è¯¯
        error_msg = "âŒ æ— æ³•è·å–æ”¯ä»˜åœ°å€ï¼Œè¯·ç¨åé‡è¯•"
        if payment_url:
            error_msg += f"\n\næ”¯ä»˜é“¾æ¥: {payment_url}\nï¼ˆç³»ç»Ÿæ— æ³•è§£æè¯¥é“¾æ¥ä¸­çš„æ”¶æ¬¾åœ°å€ï¼‰"
        await event.respond(
            error_msg,
            buttons=[[Button.inline("è¿”å›", b"back")]]
        )

__all__ = [
    'create_recharge_order', 'check_payment_task', 'payment_timeout_handler',
    'check_usdt_transaction', 'create_payment_order', 'generate_payment_sign',
    'extract_usdt_address_from_payment_url', 'payment_orders', 'payment_tasks',
    'PAYMENT_CONFIG'
]


--- File: ./app/bot_commands_addon.py ---
"""
æœºå™¨äººå‘½ä»¤æ‰©å±•æ¨¡å—
æ·»åŠ ç¾¤ç»„ç»‘å®šã€æ£€æµ‹ç­‰æ–°åŠŸèƒ½å‘½ä»¤
éœ€è¦åœ¨a.pyä¸­å¯¼å…¥å¹¶æ³¨å†Œè¿™äº›å‘½ä»¤
"""

from telethon import events, Button
from .core_functions import check_bot_is_admin, check_any_bot_in_group, get_upline_chain, get_downline_tree, check_user_conditions
import sqlite3


async def handle_bind_group(event, bot, DB):
    """å¤„ç†ç¾¤ç»„ç»‘å®š"""
    telegram_id = event.sender_id
    member = DB.get_member(telegram_id)

    if not member:
        await event.respond('è¯·å…ˆå‘é€ /start æ³¨å†Œ')
        return

    if not member['is_vip']:
        await event.respond('âš ï¸ è¯·å…ˆå¼€é€šVIPæ‰èƒ½ç»‘å®šç¾¤ç»„')
        return

    # æç¤ºç”¨æˆ·å‘é€ç¾¤é“¾æ¥
    await event.respond(
        'ğŸ“± ç¾¤ç»„ç»‘å®šæ­¥éª¤ï¼š\n\n'
        '1ï¸âƒ£ å°†æœ¬æœºå™¨äººæ‹‰å…¥æ‚¨çš„ç¾¤ç»„\n'
        '2ï¸âƒ£ å°†æœºå™¨äººè®¾ç½®ä¸ºç®¡ç†å‘˜\n'
        '3ï¸âƒ£ åœ¨æ‚¨çš„ç¾¤é‡Œè¾“å…¥ /link è·å–ç¾¤é“¾æ¥\n'
        '4ï¸âƒ£ å°†ç¾¤é“¾æ¥å‘é€ç»™æˆ‘\n\n'
        'ğŸ’¡ ç¾¤é“¾æ¥æ ¼å¼ï¼šhttps://t.me/+xxx æˆ– @groupname'
    )


async def handle_group_link_message(event, bot, DB, clients=None):
    """å¤„ç†ç”¨æˆ·å‘é€çš„ç¾¤é“¾æ¥"""
    telegram_id = event.sender_id
    group_link = event.message.text.strip()

    # éªŒè¯é“¾æ¥æ ¼å¼
    if not (group_link.startswith('https://t.me/') or group_link.startswith('@')):
        await event.respond('âŒ ç¾¤é“¾æ¥æ ¼å¼ä¸æ­£ç¡®\n\nè¯·å‘é€å®Œæ•´çš„ç¾¤é“¾æ¥ï¼Œæ ¼å¼å¦‚ï¼š\nhttps://t.me/+xxx æˆ– @groupname')
        return

    member = DB.get_member(telegram_id)
    if not member or not member['is_vip']:
        return

    # æ£€æµ‹æ˜¯å¦æœ‰æœºå™¨äººåŠ å…¥ç¾¤ç»„ä¸”ä¸ºç®¡ç†å‘˜ï¼ˆç»“æœä»…ä½œæç¤ºï¼Œä¸é˜»æ–­æ“ä½œï¼‰
    if clients and len(clients) > 0:
        # ä½¿ç”¨å¤šæœºå™¨äººé€»è¾‘
        is_any_bot_in_group, admin_bot_id = await check_any_bot_in_group(clients, group_link)
        is_admin = admin_bot_id is not None
    else:
        # å›é€€åˆ°å•æœºå™¨äººé€»è¾‘
        bot_id = (await bot.get_me()).id
        is_admin = await check_bot_is_admin(bot, bot_id, group_link)

    # æ›´æ–°æ•°æ®åº“
    conn = DB.get_conn()
    c = conn.cursor()
    c.execute('''
        UPDATE members
        SET group_link = ?, is_group_bound = 1, is_bot_admin = ?
        WHERE telegram_id = ?
    ''', (group_link, 1 if is_admin else 0, telegram_id))
    conn.commit()
    conn.close()

    if is_admin:
        await event.respond(
            'âœ… ç¾¤ç»„ç»‘å®šæˆåŠŸï¼\n\n'
            f'æ‚¨çš„ç¾¤é“¾æ¥ï¼š{group_link}\n\n'
            'ğŸ‰ æ­å–œï¼æ‚¨å·²å®Œæˆç¾¤ç»„ç»‘å®šå’Œç®¡ç†å‘˜è®¾ç½®\n\n'
            'ä¸‹ä¸€æ­¥ï¼šåŠ å…¥ä¸Šå±‚ç¾¤ç»„\n'
            'å‘é€ /join_upline æŸ¥çœ‹éœ€è¦åŠ å…¥çš„ç¾¤'
        )
    else:
        await event.respond(
            'âœ… ç¾¤ç»„é“¾æ¥å·²è®°å½•\n\n'
            f'é“¾æ¥: {group_link}\n\n'
            'â„¹ï¸ æœªèƒ½è‡ªåŠ¨æ£€æµ‹ç®¡ç†å‘˜æƒé™ï¼Œè¯·ç¡®ä¿æœºå™¨äººå·²åœ¨ç¾¤ä¸”ä¸ºç®¡ç†å‘˜ï¼Œ'
            'å¦åˆ™æŸäº›éªŒè¯åŠŸèƒ½å¯èƒ½ä¸å¯ç”¨ã€‚'
        )


async def handle_join_upline(event, bot, DB, get_system_config):
    """æ˜¾ç¤ºéœ€è¦åŠ å…¥çš„ä¸Šå±‚ç¾¤åˆ—è¡¨"""
    telegram_id = event.sender_id
    member = DB.get_member(telegram_id)

    if not member:
        await event.respond('è¯·å…ˆå‘é€ /start æ³¨å†Œ')
        return

    if not member['is_vip']:
        await event.respond('âš ï¸ è¯·å…ˆå¼€é€šVIP')
        return

    # è·å–ä¸Šçº§é“¾
    config = get_system_config()
    max_level = int(config['level_count'])
    upline_chain = get_upline_chain(telegram_id, max_level)

    if not upline_chain:
        await event.respond('æ‚¨æ²¡æœ‰ä¸Šçº§ï¼Œæ— éœ€åŠ ç¾¤')
        return

    # è·å–ä¸Šå±‚ç¾¤åˆ—è¡¨ï¼ˆæ–°æ ¼å¼ï¼šå­—å…¸åˆ—è¡¨ï¼‰
    upline_groups = []
    for item in upline_chain:
        if item.get('is_fallback'):
            # è·³è¿‡æ¡æ¼è´¦å·
            continue
        upline_id = item['id']
        level = item['level']
        up_member = DB.get_member(upline_id)
        if up_member and up_member['group_link']:
            upline_groups.append({
                'level': level,
                'username': up_member['username'],
                'group_link': up_member['group_link']
            })

    if not upline_groups:
        await event.respond('ä¸Šå±‚æš‚æ— å¯åŠ å…¥çš„ç¾¤')
        return

    # æ„å»ºæŒ‰é’®
    buttons = []
    text = f'ğŸ“‹ éœ€è¦åŠ å…¥çš„ä¸Šå±‚ç¾¤ç»„ï¼ˆå…±{len(upline_groups)}ä¸ªï¼‰\n\n'

    for i, group in enumerate(upline_groups, 1):
        text += f'{i}. ç¬¬{group["level"]}å±‚ - @{group["username"]}çš„ç¾¤\n'
        buttons.append([Button.url(f'åŠ å…¥ç¬¬{group["level"]}å±‚ç¾¤', group['group_link'])])

    text += '\nğŸ’¡ è¯·ä¾æ¬¡åŠ å…¥æ‰€æœ‰ç¾¤ç»„ï¼Œå®Œæˆåå‘é€ /check_status æ£€æŸ¥çŠ¶æ€'

    await event.respond(text, buttons=buttons)


async def handle_check_status(event, bot, DB):
    """æ£€æŸ¥ç”¨æˆ·å®ŒæˆçŠ¶æ€"""
    telegram_id = event.sender_id
    member = DB.get_member(telegram_id)

    if not member:
        await event.respond('è¯·å…ˆå‘é€ /start æ³¨å†Œ')
        return

    # æ£€æŸ¥æ‰€æœ‰æ¡ä»¶
    conditions = await check_user_conditions(bot, telegram_id)

    if not conditions:
        await event.respond('âŒ è·å–çŠ¶æ€å¤±è´¥')
        return

    # ç”ŸæˆçŠ¶æ€æŠ¥å‘Š
    status_text = 'ğŸ“Š æ‚¨çš„å®ŒæˆçŠ¶æ€\n\n'
    status_text += f'âœ… VIPçŠ¶æ€ï¼š{"å·²å¼€é€š" if conditions["is_vip"] else "æœªå¼€é€š"}\n'
    status_text += f'{"âœ…" if conditions["is_group_bound"] else "âŒ"} ç¾¤ç»„ç»‘å®šï¼š{"å·²å®Œæˆ" if conditions["is_group_bound"] else "æœªå®Œæˆ"}\n'
    status_text += f'{"âœ…" if conditions["is_bot_admin"] else "âŒ"} æœºå™¨äººç®¡ç†å‘˜ï¼š{"å·²è®¾ç½®" if conditions["is_bot_admin"] else "æœªè®¾ç½®"}\n'
    status_text += f'{"âœ…" if conditions["is_joined_upline"] else "âŒ"} åŠ å…¥ä¸Šå±‚ç¾¤ï¼š{"å·²å®Œæˆ" if conditions["is_joined_upline"] else "æœªå®Œæˆ"}\n\n'

    if conditions['all_conditions_met']:
        status_text += 'ğŸ‰ æ­å–œï¼æ‚¨å·²å®Œæˆæ‰€æœ‰æ¡ä»¶\nç°åœ¨æ‚¨çš„ä¸‹çº§å¼€é€šVIPæ—¶ï¼Œæ‚¨å°†è·å¾—åˆ†çº¢ï¼'
    else:
        status_text += 'âš ï¸ æœªå®Œæˆçš„æ¡ä»¶ï¼š\n'
        for cond in conditions['missing_conditions']:
            status_text += f'  â€¢ {cond}\n'
        status_text += '\nğŸ’¡ å®Œæˆæ‰€æœ‰æ¡ä»¶åæ‰èƒ½è·å¾—åˆ†çº¢'

    await event.respond(status_text)


async def handle_my_team(event, bot, DB):
    """æŸ¥çœ‹å›¢é˜Ÿæ•°æ®"""
    telegram_id = event.sender_id
    member = DB.get_member(telegram_id)

    if not member:
        await event.respond('è¯·å…ˆå‘é€ /start æ³¨å†Œ')
        return

    if not member['is_vip']:
        await event.respond('âš ï¸ è¯·å…ˆå¼€é€šVIPæ‰èƒ½æŸ¥çœ‹å›¢é˜Ÿæ•°æ®')
        return

    # è·å–ä¸‹çº§æ ‘
    downline_tree = get_downline_tree(telegram_id, 10)

    text = 'ğŸ‘¥ æˆ‘çš„å›¢é˜Ÿæ•°æ®\n\n'
    text += f'ğŸ’ VIPçŠ¶æ€ï¼šå·²å¼€é€š\n'
    text += f'ğŸ’° å½“å‰ä½™é¢ï¼š{member["balance"]} U\n'
    text += f'ğŸ’¸ ç´¯è®¡è·å¾—ï¼š{member.get("total_earned", 0)} U\n'
    text += f'âš ï¸ ç´¯è®¡é”™è¿‡ï¼š{member["missed_balance"]} U\n\n'

    text += 'ğŸ“Š å›¢é˜Ÿå±‚çº§åˆ†å¸ƒï¼š\n\n'

    total_members = 0
    total_vip = 0

    for level in range(1, 11):
        if level in downline_tree:
            members = downline_tree[level]
            vip_count = sum(1 for m in members if m['is_vip'])
            total_members += len(members)
            total_vip += vip_count
            text += f'ç¬¬{level}å±‚ï¼š{len(members)}äºº (VIP:{vip_count}äºº)\n'
        else:
            text += f'ç¬¬{level}å±‚ï¼š0äºº\n'

    text += f'\nğŸ“ˆ å›¢é˜Ÿæ€»è®¡ï¼š{total_members}äºº\n'
    text += f'ğŸ’ VIPæ€»æ•°ï¼š{total_vip}äºº\n'

    await event.respond(text)


# æ·»åŠ å‘½ä»¤è¯´æ˜
COMMAND_HELP = """
ğŸ¤– ç¾¤ç»„ç®¡ç†å‘½ä»¤

/bind_group - ç»‘å®šæ‚¨çš„ç¾¤ç»„
/join_upline - æŸ¥çœ‹éœ€è¦åŠ å…¥çš„ä¸Šå±‚ç¾¤
/check_status - æ£€æŸ¥å®ŒæˆçŠ¶æ€
/my_team - æŸ¥çœ‹å›¢é˜Ÿæ•°æ®

ğŸ’¡ å®Œæˆæ‰€æœ‰æ¡ä»¶åï¼Œæ‚¨çš„ä¸‹çº§å¼€é€šVIPæ—¶
   æ‚¨å°†è·å¾— 1U åˆ†çº¢ï¼
"""

--- File: ./main.py ---
"""
å¯åŠ¨å…¥å£ - ç»Ÿä¸€å¯åŠ¨Botå’ŒWebåå°
"""
import threading
from app.database import init_db, sync_member_groups_from_members
from app.bot_logic import run_bot

def main():
    print("=" * 60)
    print("ğŸ¤– è£‚å˜æ¨å¹¿æœºå™¨äººç³»ç»Ÿå¯åŠ¨ä¸­...")
    print("=" * 60)
    print()
    
    # 1. åˆå§‹åŒ–æ•°æ®åº“
    print("ğŸ“Š åˆå§‹åŒ–æ•°æ®åº“...")
    init_db()
    print("âœ… æ•°æ®åº“åˆå§‹åŒ–å®Œæˆ")
    
    # åŒæ­¥å·²æœ‰ä¼šå‘˜ç¾¤é“¾æ¥åˆ° member_groups
    print("ğŸ”„ åŒæ­¥ä¼šå‘˜ç¾¤ç»„æ•°æ®...")
    try:
        sync_member_groups_from_members()
        print("âœ… ä¼šå‘˜ç¾¤ç»„æ•°æ®åŒæ­¥å®Œæˆ")
    except Exception as e:
        print(f"âš ï¸ ä¼šå‘˜ç¾¤ç»„æ•°æ®åŒæ­¥å¤±è´¥: {e}")
    print()
    
    # 2. å¯åŠ¨ Web åå° (åœ¨ç‹¬ç«‹çº¿ç¨‹ä¸­)
    print("ğŸŒ å¯åŠ¨Webç®¡ç†åå°...")
    try:
        from web_app import run_web
        web_thread = threading.Thread(target=run_web, daemon=True)
        web_thread.start()
        print("âœ… Webç®¡ç†åå°å·²å¯åŠ¨ (ç«¯å£: 5051)")
    except Exception as e:
        print(f"âš ï¸ Webåå°å¯åŠ¨å¤±è´¥: {e}")
        print("ç»§ç»­å¯åŠ¨Bot...")
    print()
    
    # 3. å¯åŠ¨ Bot (ä¸»çº¿ç¨‹)
    print("ğŸš€ Telegramæœºå™¨äººå¯åŠ¨ä¸­...")
    print()
    print("=" * 60)
    print("ğŸ“± è®¿é—®åœ°å€ï¼š")
    print("   Webåå°: http://localhost:5051")
    print("=" * 60)
    print()
    print("ğŸ’¡ æç¤ºï¼š")
    print("   - æ‰€æœ‰æœåŠ¡æ­£åœ¨è¿è¡Œä¸­...")
    print("   - æŒ‰ Ctrl+C åœæ­¢æ‰€æœ‰æœåŠ¡")
    print("=" * 60)
    print()
    
    try:
        run_bot()
    except KeyboardInterrupt:
        print("\nåœæ­¢æœåŠ¡...")
    except Exception as e:
        print(f"âŒ å¯åŠ¨å¤±è´¥: {e}")
        import traceback
        traceback.print_exc()

if __name__ == '__main__':
    main()


--- File: ./concat_files.py ---
#!/usr/bin/env python3
"""
Concatenate all .html and .py files from current directory and subdirectories into a single txt file.
"""

import os
from pathlib import Path


def concat_files(output_file="output.txt"):
    """Concatenate all .html and .py files to a single txt file."""

    extensions = ['.html', '.py']
    file_count = 0

    with open(output_file, 'w', encoding='utf-8') as out:
        for root, dirs, files in os.walk('.'):
            dirs[:] = [d for d in dirs if not d.startswith('.')]

            for file in files:
                file_path = Path(root) / file

                if file_path.suffix.lower() in extensions:
                    file_count += 1

                    out.write(f"\n{'=' * 80}\n")
                    out.write(f"FILE: {file_path}\n")
                    out.write(f"{'=' * 80}\n\n")

                    try:
                        with open(file_path, 'r', encoding='utf-8') as f:
                            content = f.read()
                            out.write(content)
                            out.write('\n')
                    except Exception as e:
                        out.write(f"[ERROR reading file: {e}]\n")
                        print(f"Error reading {file_path}: {e}")

    print(f"Successfully concatenated {file_count} files to {output_file}")


if __name__ == "__main__":
    concat_files()

